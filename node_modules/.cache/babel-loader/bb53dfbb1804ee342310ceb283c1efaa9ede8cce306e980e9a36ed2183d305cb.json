{"ast":null,"code":"import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport { SafeEventEmitter, JRPCEngine, createAsyncMiddleware, mergeMiddleware, createScaffoldMiddleware } from '@toruslabs/openlogin-jrpc';\nimport { serializeError, ethErrors } from 'eth-rpc-errors';\nimport getCreateRandomId from 'json-rpc-random-id';\nimport { BigNumber } from 'bignumber.js';\nimport { fromSigned, bufferToInt, toUnsigned, stripHexPrefix, addHexPrefix, hashPersonalMessage, ecsign, intToBuffer } from 'ethereumjs-util';\nimport log from 'loglevel';\nimport { BroadcastChannel } from '@toruslabs/broadcast-channel';\nimport { get, post, patch, remove } from '@toruslabs/http-helpers';\nimport bowser from 'bowser';\nimport { cloneDeep, pickBy, omitBy } from 'lodash';\nfunction ownKeys$3(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread$3(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys$3(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$3(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\n/**\n * Controller class that provides configuration, state management, and subscriptions\n */\n\nclass BaseController extends SafeEventEmitter {\n  /**\n   * Default options used to configure this controller\n   */\n\n  /**\n   * Default state set on this controller\n   */\n\n  /**\n   * Determines if listeners are notified of state changes\n   */\n\n  /**\n   * Name of this controller used during composition\n   */\n\n  /**\n   * Creates a BaseController instance. Both initial state and initial\n   * configuration options are merged with defaults upon initialization.\n   *\n   * @param config - Initial options used to configure this controller\n   * @param state - Initial state to set on this controller\n   */\n  constructor(_ref) {\n    let {\n      config = {},\n      state = {}\n    } = _ref;\n    super(); // Use assign since generics can't be spread: https://git.io/vpRhY\n\n    _defineProperty(this, \"defaultConfig\", {});\n    _defineProperty(this, \"defaultState\", {});\n    _defineProperty(this, \"disabled\", false);\n    _defineProperty(this, \"name\", \"BaseController\");\n    _defineProperty(this, \"initialConfig\", void 0);\n    _defineProperty(this, \"initialState\", void 0);\n    _defineProperty(this, \"internalConfig\", this.defaultConfig);\n    _defineProperty(this, \"internalState\", this.defaultState);\n    this.initialState = state;\n    this.initialConfig = config;\n  }\n  /**\n   * Retrieves current controller configuration options\n   *\n   * @returns - Current configuration\n   */\n\n  get config() {\n    return this.internalConfig;\n  }\n  /**\n   * Retrieves current controller state\n   *\n   * @returns - Current state\n   */\n\n  get state() {\n    return this.internalState;\n  }\n  /**\n   * Updates controller configuration\n   *\n   * @param config - New configuration options\n   * @param overwrite - Overwrite config instead of merging\n   * @param fullUpdate - Boolean that defines if the update is partial or not\n   */\n\n  configure(config) {\n    let overwrite = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let fullUpdate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    if (fullUpdate) {\n      this.internalConfig = overwrite ? config : Object.assign(this.internalConfig, config);\n      for (const key in this.internalConfig) {\n        if (typeof this.internalConfig[key] !== \"undefined\") {\n          this[key] = this.internalConfig[key];\n        }\n      }\n    } else {\n      for (const key in config) {\n        /* istanbul ignore else */\n        if (typeof this.internalConfig[key] !== \"undefined\") {\n          this.internalConfig[key] = config[key];\n          this[key] = config[key];\n        }\n      }\n    }\n  }\n  /**\n   * Updates controller state\n   *\n   * @param state - New state\n   * @param overwrite - Overwrite state instead of merging\n   */\n\n  update(state) {\n    let overwrite = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    this.internalState = overwrite ? _objectSpread$3({}, state) : _objectSpread$3(_objectSpread$3({}, this.internalState), state);\n    this.emit(\"store\", this.internalState);\n  }\n  /**\n   * Enables the controller. This sets each config option as a member\n   * variable on this instance and triggers any defined setters. This\n   * also sets initial state and triggers any listeners.\n   *\n   * @returns - This controller instance\n   */\n\n  initialize() {\n    this.internalState = this.defaultState;\n    this.internalConfig = this.defaultConfig;\n    this.configure(this.initialConfig);\n    this.update(this.initialState);\n    return this;\n  }\n}\nconst sec = 1000;\nconst calculateSum = (accumulator, currentValue) => accumulator + currentValue;\nconst blockTrackerEvents = [\"sync\", \"latest\"];\nclass BaseBlockTracker extends BaseController {\n  constructor(_ref) {\n    let {\n      config = {},\n      state = {}\n    } = _ref;\n    super({\n      config,\n      state\n    }); // config\n\n    _defineProperty(this, \"name\", \"BaseBlockTracker\");\n    _defineProperty(this, \"_blockResetTimeout\", void 0);\n    this.defaultState = {\n      _currentBlock: {\n        idempotencyKey: \"\"\n      },\n      _isRunning: false\n    };\n    this.defaultConfig = {\n      blockResetDuration: 20 * sec\n    };\n    this.initialize(); // bind functions for internal use\n\n    this._onNewListener = this._onNewListener.bind(this);\n    this._onRemoveListener = this._onRemoveListener.bind(this);\n    this._resetCurrentBlock = this._resetCurrentBlock.bind(this); // listen for handler changes\n\n    this._setupInternalEvents();\n  }\n  isRunning() {\n    return this.state._isRunning;\n  }\n  getCurrentBlock() {\n    return this.state._currentBlock;\n  }\n  async getLatestBlock() {\n    // return if available\n    if (this.state._currentBlock) {\n      return this.state._currentBlock;\n    } // wait for a new latest block\n\n    const latestBlock = await new Promise(resolve => this.once(\"latest\", newState => {\n      if (newState._currentBlock) {\n        resolve(newState._currentBlock);\n      }\n    })); // return newly set current block\n\n    return latestBlock;\n  } // dont allow module consumer to remove our internal event listeners\n\n  removeAllListeners(eventName) {\n    if (eventName) {\n      super.removeAllListeners(eventName);\n    } else {\n      super.removeAllListeners();\n    } // re-add internal events\n\n    this._setupInternalEvents(); // trigger stop check just in case\n\n    this._onRemoveListener();\n    return this;\n  }\n  /**\n   * To be implemented in subclass.\n   */\n\n  _start() {// default behavior is noop\n  }\n  /**\n   * To be implemented in subclass.\n   */\n\n  _end() {// default behavior is noop\n  }\n  _newPotentialLatest(newBlock) {\n    const currentBlock = this.state._currentBlock; // only update if blok number is higher\n\n    if (currentBlock && newBlock.idempotencyKey === currentBlock.idempotencyKey) {\n      return;\n    }\n    this._setCurrentBlock(newBlock);\n  }\n  _setupInternalEvents() {\n    // first remove listeners for idempotency\n    this.removeListener(\"newListener\", this._onNewListener);\n    this.removeListener(\"removeListener\", this._onRemoveListener); // then add them\n\n    this.on(\"removeListener\", this._onRemoveListener);\n    this.on(\"newListener\", this._onNewListener);\n  }\n  _onNewListener() {\n    this._maybeStart();\n  }\n  _onRemoveListener() {\n    // `removeListener` is called *after* the listener is removed\n    if (this._getBlockTrackerEventCount() > 0) {\n      return;\n    }\n    this._maybeEnd();\n  }\n  _maybeStart() {\n    if (this.state._isRunning) {\n      return;\n    }\n    this.state._isRunning = true; // cancel setting latest block to stale\n\n    this._cancelBlockResetTimeout();\n    this._start();\n  }\n  _maybeEnd() {\n    if (!this.state._isRunning) {\n      return;\n    }\n    this.state._isRunning = false;\n    this._setupBlockResetTimeout();\n    this._end();\n  }\n  _getBlockTrackerEventCount() {\n    return blockTrackerEvents.map(eventName => this.listenerCount(eventName)).reduce(calculateSum);\n  }\n  _setCurrentBlock(newBlock) {\n    const oldBlock = this.state._currentBlock;\n    this.update({\n      _currentBlock: newBlock\n    });\n    this.emit(\"latest\", newBlock);\n    this.emit(\"sync\", {\n      oldBlock,\n      newBlock\n    });\n  }\n  _setupBlockResetTimeout() {\n    // clear any existing timeout\n    this._cancelBlockResetTimeout(); // clear latest block when stale\n\n    this._blockResetTimeout = setTimeout(this._resetCurrentBlock, this.config.blockResetDuration); // nodejs - dont hold process open\n\n    if (this._blockResetTimeout.unref) {\n      this._blockResetTimeout.unref();\n    }\n  }\n  _cancelBlockResetTimeout() {\n    if (this._blockResetTimeout) {\n      clearTimeout(this._blockResetTimeout);\n    }\n  }\n  _resetCurrentBlock() {\n    this.update({\n      _currentBlock: {\n        idempotencyKey: \"\"\n      }\n    });\n  }\n}\nconst filterNoop = () => true;\nconst internalEvents = [\"newListener\", \"removeListener\"];\nconst externalEventFilter = name => !internalEvents.includes(name);\nfunction getRawListeners(eventEmitter, name) {\n  // prefer native\n  return eventEmitter.rawListeners(name);\n}\nfunction createEventEmitterProxy(initialTarget, opts) {\n  // parse options\n  const finalOpts = opts || {};\n  let eventFilter = finalOpts.eventFilter || filterNoop;\n  if (typeof eventFilter === \"string\" && eventFilter === \"skipInternal\") eventFilter = externalEventFilter;\n  if (typeof eventFilter !== \"function\") throw new Error(\"createEventEmitterProxy - Invalid eventFilter\");\n  let target = initialTarget;\n  let setTarget = newTarget => {\n    const oldTarget = target;\n    target = newTarget;\n    oldTarget.eventNames().filter(eventFilter).forEach(name => {\n      getRawListeners(oldTarget, name).forEach(handler => newTarget.on(name, handler));\n    }); // remove old listeners\n\n    oldTarget.removeAllListeners();\n  };\n  const proxy = new Proxy({}, {\n    get: (_, name) => {\n      // override `setTarget` access\n      if (name === \"setTarget\") return setTarget;\n      return target[name];\n    },\n    set: (_, name, value) => {\n      // allow `setTarget` overrides\n      if (name === \"setTarget\") {\n        setTarget = value;\n        return true;\n      }\n      target[name] = value;\n      return true;\n    }\n  });\n  return proxy;\n}\nfunction createSwappableProxy(initialTarget) {\n  let target = initialTarget;\n  let setTarget = newTarget => {\n    target = newTarget;\n  };\n  const proxy = new Proxy({}, {\n    get: (_, name) => {\n      // override `setTarget` access\n      if (name === \"setTarget\") return setTarget;\n      return target[name];\n    },\n    set: (_, name, value) => {\n      // allow `setTarget` overrides\n      if (name === \"setTarget\") {\n        setTarget = value;\n        return true;\n      }\n      target[name] = value;\n      return true;\n    }\n  });\n  return proxy;\n}\nconst POLLING_INTERVAL = 600000;\nclass BaseCurrencyController extends BaseController {\n  constructor(_ref) {\n    let {\n      config = {},\n      state\n    } = _ref;\n    super({\n      config,\n      state\n    });\n    this.defaultState = {\n      currentCurrency: \"usd\",\n      conversionRate: 0,\n      conversionDate: \"N/A\",\n      nativeCurrency: \"ETH\"\n    };\n    this.defaultConfig = {\n      pollInterval: POLLING_INTERVAL\n    };\n    this.initialize();\n  } //\n  // PUBLIC METHODS\n  //\n\n  getNativeCurrency() {\n    return this.state.nativeCurrency;\n  }\n  setNativeCurrency(nativeCurrency) {\n    this.update({\n      nativeCurrency,\n      ticker: nativeCurrency\n    });\n  }\n  getCurrentCurrency() {\n    return this.state.currentCurrency;\n  }\n  setCurrentCurrency(currentCurrency) {\n    this.update({\n      currentCurrency\n    });\n  }\n  /**\n   * A getter for the conversionRate property\n   *\n   * @returns The conversion rate from ETH to the selected currency.\n   *\n   */\n\n  getConversionRate() {\n    return this.state.conversionRate;\n  }\n  setConversionRate(conversionRate) {\n    this.update({\n      conversionRate\n    });\n  }\n  /**\n   * A getter for the conversionDate property\n   *\n   * @returns The date at which the conversion rate was set. Expressed in milliseconds since midnight of\n   * January 1, 1970\n   *\n   */\n\n  getConversionDate() {\n    return this.state.conversionDate;\n  }\n  setConversionDate(conversionDate) {\n    this.update({\n      conversionDate\n    });\n  }\n}\nfunction ownKeys$2(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread$2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys$2(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$2(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\nconst createRandomId = getCreateRandomId();\nfunction providerFromEngine(engine) {\n  const provider = new SafeEventEmitter(); // handle both rpc send methods\n\n  provider.sendAsync = async req => {\n    const res = await engine.handle(req);\n    if (res.error) {\n      var _res$error, _res$error2;\n      const err = serializeError(res.error, {\n        fallbackError: {\n          message: ((_res$error = res.error) === null || _res$error === void 0 ? void 0 : _res$error.message) || res.error.toString(),\n          code: ((_res$error2 = res.error) === null || _res$error2 === void 0 ? void 0 : _res$error2.code) || -32603\n        }\n      });\n      throw ethErrors.rpc.internal(err);\n    }\n    return res.result;\n  }; // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n  provider.send = (req, callback) => {\n    if (typeof callback !== \"function\") {\n      throw new Error('Must provide callback to \"send\" method.');\n    }\n    engine.handle(req, callback);\n  }; // forward notifications\n\n  if (engine.on) {\n    engine.on(\"notification\", message => {\n      provider.emit(\"data\", null, message);\n    });\n  }\n  provider.request = async args => {\n    const req = _objectSpread$2(_objectSpread$2({}, args), {}, {\n      id: createRandomId(),\n      jsonrpc: \"2.0\"\n    });\n    const res = await provider.sendAsync(req);\n    return res;\n  };\n  return provider;\n}\nfunction providerFromMiddleware(middleware) {\n  const engine = new JRPCEngine();\n  engine.push(middleware);\n  const provider = providerFromEngine(engine);\n  return provider;\n}\nfunction providerAsMiddleware(provider) {\n  return async (req, res, _next, end) => {\n    // send request to provider\n    try {\n      const providerRes = await provider.sendAsync(req);\n      res.result = providerRes;\n      return end();\n    } catch (error) {\n      return end(error.message);\n    }\n  };\n}\nconst FEATURES_PROVIDER_CHANGE_WINDOW = {\n  height: 660,\n  width: 375\n};\nconst FEATURES_DEFAULT_WALLET_WINDOW = {\n  height: 740,\n  width: 1315\n};\nconst FEATURES_DEFAULT_POPUP_WINDOW = {\n  height: 700,\n  width: 1200\n};\nconst FEATURES_CONFIRM_WINDOW = {\n  height: 700,\n  width: 450\n};\nconst POPUP_LOADED = \"popup_loaded\";\nconst POPUP_RESULT = \"popup_result\";\nconst SETUP_COMPLETE = \"setup_complete\";\nconst ACTIVITY_ACTION_ALL = \"walletActivity.allTransactions\";\nconst ACTIVITY_ACTION_SEND = \"walletActivity.send\";\nconst ACTIVITY_ACTION_BURN = \"walletActivity.burn\";\nconst ACTIVITY_ACTION_RECEIVE = \"walletActivity.receive\";\nconst ACTIVITY_ACTION_TOPUP = \"walletActivity.topup\";\nconst ACTIVITY_PERIOD_ALL = \"walletActivity.all\";\nconst ACTIVITY_PERIOD_WEEK_ONE = \"walletActivity.lastOneWeek\";\nconst ACTIVITY_PERIOD_MONTH_ONE = \"walletActivity.lastOneMonth\";\nconst ACTIVITY_PERIOD_MONTH_SIX = \"walletActivity.lastSixMonts\";\nconst ACTIVITY_STATUS_SUCCESSFUL = \"walletActivity.successful\";\nconst ACTIVITY_STATUS_UNSUCCESSFUL = \"walletActivity.unsuccessful\";\nconst ACTIVITY_STATUS_PENDING = \"walletActivity.pending\";\nconst ACTIVITY_STATUS_CANCELLED = \"walletActivity.cancelled\";\nconst ACTIVITY_STATUS_CANCELLING = \"walletActivity.cancelling\";\nconst COMMUNICATION_NOTIFICATIONS = {\n  IFRAME_STATUS: \"iframe_status\",\n  // Tell embed to create the window\n  CREATE_WINDOW: \"create_window\",\n  // Tell embed to close the window\n  CLOSE_WINDOW: \"close_window\",\n  USER_LOGGED_IN: \"user_logged_in\",\n  USER_LOGGED_OUT: \"user_logged_out\"\n};\nconst COMMUNICATION_JRPC_METHODS = {\n  LOGOUT: \"logout\",\n  WALLET_INSTANCE_ID: \"wallet_instance_id\",\n  USER_INFO: \"user_info\",\n  SET_PROVIDER: \"set_provider\",\n  TOPUP: \"topup\",\n  IFRAME_STATUS: \"iframe_status\",\n  // embed has opened the window as requested\n  OPENED_WINDOW: \"opened_window\",\n  // user has closed the window from embed's side\n  CLOSED_WINDOW: \"closed_window\",\n  GET_PROVIDER_STATE: \"get_provider_state\",\n  LOGIN_WITH_PRIVATE_KEY: \"login_with_private_key\"\n};\nconst PROVIDER_JRPC_METHODS = {\n  GET_PROVIDER_STATE: \"wallet_get_provider_state\"\n};\nconst PROVIDER_NOTIFICATIONS = {\n  ACCOUNTS_CHANGED: \"wallet_accounts_changed\",\n  CHAIN_CHANGED: \"wallet_chain_changed\",\n  UNLOCK_STATE_CHANGED: \"wallet_unlock_state_changed\"\n};\nconst BROADCAST_CHANNELS = {\n  REDIRECT_CHANNEL: \"redirect_channel\",\n  PROVIDER_CHANGE_CHANNEL: \"torus_provider_change_channel\",\n  TRANSACTION_CHANNEL: \"torus_channel\",\n  MESSAGE_CHANNEL: \"torus_message_channel\",\n  WALLET_LOGOUT_CHANNEL: \"wallet_logout_channel\",\n  WALLET_SELECTED_ADDRESS_CHANNEL: \"wallet_selected_address_channel\",\n  WALLET_NETWORK_CHANGE_CHANNEL: \"wallet_network_change_channel\",\n  WALLET_ACCOUNT_IMPORT_CHANNEL: \"wallet_account_import_channel\",\n  THEME_CHANGE: \"theme_change_channel\"\n};\nconst BROADCAST_CHANNELS_MSGS = {\n  LOGOUT: \"logout\",\n  ACCOUNT_IMPORTED: \"account_imported\",\n  SELECTED_ADDRESS_CHANGE: \"selected_address_change\",\n  NETWORK_CHANGE: \"network_change\",\n  SET_THEME: \"set_theme\"\n};\nfunction createChangeProviderMiddlewareMiddleware(_ref) {\n  let {\n    changeProvider\n  } = _ref;\n  return createAsyncMiddleware(async (request, response, next) => {\n    const {\n      method\n    } = request;\n    if (method !== COMMUNICATION_JRPC_METHODS.SET_PROVIDER) return next();\n    if (!changeProvider) throw new Error(\"CommunicationMiddleware - opts.changeProvider not provided\");\n    response.result = await changeProvider(request);\n  });\n}\nfunction createTopupMiddleware(_ref2) {\n  let {\n    topup\n  } = _ref2;\n  return createAsyncMiddleware(async (request, response, next) => {\n    const {\n      method\n    } = request;\n    if (method !== COMMUNICATION_JRPC_METHODS.TOPUP) return next();\n    if (!topup) throw new Error(\"CommunicationMiddleware - opts.topup not provided\");\n    response.result = await topup(request);\n  });\n}\nfunction createGenericJRPCMiddleware(targetMethod, handler) {\n  return createAsyncMiddleware(async (request, response, next) => {\n    const {\n      method\n    } = request;\n    if (method !== targetMethod) return next();\n    if (!handler) throw new Error(\"CommunicationMiddleware - \".concat(targetMethod, \" not provided\"));\n    const result = await handler(request);\n    if (!result) {\n      return next();\n    }\n    response.result = result;\n    return undefined;\n  });\n}\nfunction createCommunicationMiddleware(providerHandlers) {\n  const {\n    getUserInfo,\n    getWalletInstanceId,\n    topup,\n    logout,\n    changeProvider,\n    setIFrameStatus,\n    handleWindowRpc,\n    getProviderState,\n    loginWithPrivateKey\n  } = providerHandlers;\n  return mergeMiddleware([createChangeProviderMiddlewareMiddleware({\n    changeProvider\n  }), createTopupMiddleware({\n    topup\n  }), createScaffoldMiddleware({\n    [COMMUNICATION_JRPC_METHODS.LOGOUT]: logout,\n    [COMMUNICATION_JRPC_METHODS.WALLET_INSTANCE_ID]: getWalletInstanceId,\n    [COMMUNICATION_JRPC_METHODS.USER_INFO]: getUserInfo,\n    [COMMUNICATION_JRPC_METHODS.IFRAME_STATUS]: setIFrameStatus,\n    // Do this in the orchestrator because communicationWindowManager needs to be passed into PopupHandlers\n    [COMMUNICATION_JRPC_METHODS.OPENED_WINDOW]: handleWindowRpc,\n    [COMMUNICATION_JRPC_METHODS.CLOSED_WINDOW]: handleWindowRpc,\n    [COMMUNICATION_JRPC_METHODS.GET_PROVIDER_STATE]: getProviderState\n  }), createGenericJRPCMiddleware(COMMUNICATION_JRPC_METHODS.LOGIN_WITH_PRIVATE_KEY, loginWithPrivateKey)]);\n}\nclass BaseEmbedController extends BaseController {\n  constructor(_ref) {\n    let {\n      config = {},\n      state\n    } = _ref;\n    super({\n      config,\n      state\n    });\n    _defineProperty(this, \"_communicationProviderProxy\", void 0);\n    this.defaultState = {\n      buttonPosition: \"bottom-right\",\n      isIFrameFullScreen: true,\n      apiKey: \"torus-default\",\n      oauthModalVisibility: false,\n      loginInProgress: false,\n      dappMetadata: {\n        name: \"\",\n        icon: \"\"\n      }\n    };\n    this.initialize();\n  }\n  /**\n   * Called by orchestrator once while initializing the class\n   * @param handlers - JRPC handlers for provider\n   * @returns - provider - Returns the providerProxy\n   */\n\n  initializeProvider(handlers) {\n    const engine = new JRPCEngine();\n    const communicationMiddleware = createCommunicationMiddleware(handlers);\n    engine.push(communicationMiddleware);\n    const communicationProvider = providerFromEngine(engine);\n    this.setCommunicationProvider(communicationProvider);\n  }\n  setCommunicationProvider(communicationProvider) {\n    if (this._communicationProviderProxy) {\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      this._communicationProviderProxy.setTarget(communicationProvider);\n    } else {\n      this._communicationProviderProxy = createSwappableProxy(communicationProvider);\n    }\n  }\n}\nclass CommunicationWindowManager extends SafeEventEmitter {\n  constructor() {\n    super(...arguments);\n    _defineProperty(this, \"handleWindowRpc\", (request, response, next, end) => {\n      const {\n        method,\n        params\n      } = request;\n      if (method === COMMUNICATION_JRPC_METHODS.OPENED_WINDOW) {\n        const {\n          windowId\n        } = params; // I've been informed that a window has been opened\n\n        this.emit(\"\".concat(windowId, \":opened\"));\n        response.result = true;\n        end();\n      } else if (method === COMMUNICATION_JRPC_METHODS.CLOSED_WINDOW) {\n        const {\n          windowId\n        } = params; // I've been informed that a window has been closed\n\n        this.emit(\"\".concat(windowId, \":closed\"));\n        response.result = true;\n        end();\n      } else {\n        next();\n      }\n    });\n  }\n}\nconst LOGIN_PROVIDER = {\n  GOOGLE: \"google\",\n  FACEBOOK: \"facebook\",\n  REDDIT: \"reddit\",\n  DISCORD: \"discord\",\n  TWITCH: \"twitch\",\n  APPLE: \"apple\",\n  LINE: \"line\",\n  GITHUB: \"github\",\n  KAKAO: \"kakao\",\n  LINKEDIN: \"linkedin\",\n  TWITTER: \"twitter\",\n  WEIBO: \"weibo\",\n  WECHAT: \"wechat\",\n  EMAIL_PASSWORDLESS: \"email_passwordless\"\n};\nconst PAYMENT_PROVIDER = {\n  MOONPAY: \"moonpay\",\n  WYRE: \"wyre\",\n  RAMPNETWORK: \"rampnetwork\",\n  XANPOOL: \"xanpool\",\n  MERCURYO: \"mercuryo\",\n  TRANSAK: \"transak\"\n};\nconst getTxStatusText = txStatus => {\n  switch (txStatus) {\n    case \"rejected\":\n    case \"unapproved\":\n    case \"failed\":\n      return ACTIVITY_STATUS_UNSUCCESSFUL;\n    case \"confirmed\":\n      return ACTIVITY_STATUS_SUCCESSFUL;\n    case \"submitted\":\n      return ACTIVITY_STATUS_PENDING;\n    case \"cancelled\":\n      return ACTIVITY_STATUS_CANCELLED;\n    default:\n      return \"\";\n  }\n};\n\n/**\n * General utility functions\n */\n\nfunction intToHex(i) {\n  const hex = i.toString(16);\n  return \"0x\".concat(hex);\n}\n/**\n * Returns a random number. Don't use for cryptographic purposes.\n * @returns a random number\n */\n\nconst randomId = () => Math.random().toString(36).slice(2);\n/**\n * Pads the front of the given hex string with zeroes until it reaches the\n * target length. If the input string is already longer than or equal to the\n * target length, it is returned unmodified.\n *\n * If the input string is \"0x\"-prefixed or not a hex string, an error will be\n * thrown.\n *\n * @param hexString - The hexadecimal string to pad with zeroes.\n * @param targetLength - The target length of the hexadecimal string.\n * @returns The input string front-padded with zeroes, or the original string\n * if it was already greater than or equal to to the target length.\n */\n\nfunction padWithZeroes(hexString, targetLength) {\n  if (hexString !== \"\" && !/^[a-f0-9]+$/iu.test(hexString)) {\n    throw new Error(\"Expected an unprefixed hex string. Received: \".concat(hexString));\n  }\n  if (targetLength < 0) {\n    throw new Error(\"Expected a non-negative integer target length. Received: \".concat(targetLength));\n  }\n  return String.prototype.padStart.call(hexString, targetLength, \"0\");\n}\n/**\n * Concatenate an extended ECDSA signature into a hex string.\n *\n * @param v - The 'v' portion of the signature.\n * @param r - The 'r' portion of the signature.\n * @param s - The 's' portion of the signature.\n * @returns The concatenated ECDSA signature.\n */\n\nfunction concatSig(v, r, s) {\n  const rSig = fromSigned(r);\n  const sSig = fromSigned(s);\n  const vSig = bufferToInt(v);\n  const rStr = padWithZeroes(toUnsigned(rSig).toString(\"hex\"), 64);\n  const sStr = padWithZeroes(toUnsigned(sSig).toString(\"hex\"), 64);\n  const vStr = stripHexPrefix(intToHex(vSig));\n  return addHexPrefix(rStr.concat(sStr, vStr));\n}\nfunction timeout$1(duration) {\n  return new Promise(resolve => {\n    const timeoutRef = window.setTimeout(() => {\n      resolve();\n      window.clearTimeout(timeoutRef);\n    }, duration);\n  });\n}\nconst getHeaders = jwt => {\n  return {\n    headers: {\n      Authorization: \"Bearer \".concat(jwt),\n      \"Content-Type\": \"application/json; charset=utf-8\"\n    }\n  };\n};\n/**\n * Text/number formatting utilities\n */\n\nconst formatSmallNumbers = function (number) {\n  let currency = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"usd\";\n  let noTilde = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  const finalNumber = BigNumber.isBigNumber(number) ? number.toNumber() : number;\n  if (!Number.isFinite(finalNumber)) return \"\";\n  const value = currency.toLowerCase() === \"usd\" ? parseFloat(Number(finalNumber).toFixed(2)) : parseFloat(Number(finalNumber).toFixed(5));\n  const tilde = value > 0 ? \"~ \" : \"\";\n  return \"\".concat(currency.toLowerCase() === \"usd\" || noTilde ? \"\" : tilde).concat(Number(value), \" \").concat(currency.toUpperCase());\n};\nconst addressSlicer = function (address) {\n  let sliceLength = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5;\n  if (address.length < 11) {\n    return address;\n  }\n  if (typeof address !== \"string\") return \"\";\n  return \"\".concat(address.slice(0, sliceLength), \"...\").concat(address.slice(-sliceLength));\n};\nconst significantDigits = function (number) {\n  let perc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  let length_ = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 2;\n  let input = !BigNumber.isBigNumber(number) ? new BigNumber(number) : number;\n  if (input.isZero()) return input;\n  if (perc) {\n    input = input.times(new BigNumber(100));\n  }\n  let depth;\n  if (input.gte(new BigNumber(1))) {\n    depth = length_;\n  } else {\n    depth = length_ - 1 + Math.ceil(Math.log10(new BigNumber(\"1\").div(input).toNumber()));\n  }\n  const shift = new BigNumber(10).pow(new BigNumber(depth));\n  const roundedNumber = Math.round(shift.times(input).toNumber()) / shift.toNumber();\n  return roundedNumber;\n};\nconst formatDate = inputDate => {\n  const monthList = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"];\n  const date = new Date(inputDate);\n  const day = date.getDate();\n  const month = monthList[date.getMonth()];\n  const year = date.getFullYear();\n  return \"\".concat(day, \" \").concat(month, \" \").concat(year);\n};\nconst formatTime = time => {\n  return new Date(time).toTimeString().slice(0, 8);\n};\n/**\n * Network utilities\n */\n\nconst transactionMatchesNetwork = (transaction, chainId) => {\n  if (typeof transaction.chainId !== \"undefined\") {\n    return transaction.chainId === chainId;\n  }\n  return false;\n};\n/**\n * Signing utils\n */\n\nconst hashMessage = message => {\n  const bufferedMessage = Buffer.from(message, \"utf8\");\n  const el = hashPersonalMessage(bufferedMessage);\n  return el;\n};\nconst signMessage = (privateKey, data) => {\n  const privKey = Buffer.from(privateKey, \"hex\");\n  const message = stripHexPrefix(data);\n  const msgSig = ecsign(Buffer.from(message, \"hex\"), privKey);\n  const rawMsgSig = concatSig(intToBuffer(msgSig.v), msgSig.r, msgSig.s);\n  return rawMsgSig;\n};\n/**\n * popup handler utils\n */\n\nfunction getPopupFeatures(_ref) {\n  let {\n    width: w,\n    height: h\n  } = _ref;\n  // Fixes dual-screen position                             Most browsers      Firefox\n  const dualScreenLeft = window.screenLeft !== undefined ? window.screenLeft : window.screenX;\n  const dualScreenTop = window.screenTop !== undefined ? window.screenTop : window.screenY;\n  const width = window.innerWidth ? window.innerWidth : document.documentElement.clientWidth ? document.documentElement.clientWidth : window.screen.width;\n  const height = window.innerHeight ? window.innerHeight : document.documentElement.clientHeight ? document.documentElement.clientHeight : window.screen.height;\n  const systemZoom = 1; // No reliable estimate\n\n  const left = Math.abs((width - w) / 2 / systemZoom + dualScreenLeft);\n  const top = Math.abs((height - h) / 2 / systemZoom + dualScreenTop);\n  const features = \"titlebar=0,toolbar=0,status=0,location=0,menubar=0,height=\".concat(h / systemZoom, \",width=\").concat(w / systemZoom, \",top=\").concat(top, \",left=\").concat(left);\n  return features;\n}\nconst broadcastChannelOptions = {\n  // type: 'localstorage', // (optional) enforce a type, oneOf['native', 'idb', 'localstorage', 'node']\n  webWorkerSupport: false // (optional) set this to false if you know that your channel will never be used in a WebWorker (increases performance)\n};\nfunction getCustomDeviceInfo() {\n  var _navigator;\n  if ((_navigator = navigator) !== null && _navigator !== void 0 && _navigator.brave) {\n    return {\n      browser: \"Brave\"\n    };\n  }\n}\nclass UserError extends Error {}\nconst handleRedirectParameters = (hash, queryParameters) => {\n  const hashParameters = {};\n  const hashUrl = new URL(\"\".concat(window.location.origin, \"/?\").concat(hash.slice(1)));\n  hashUrl.searchParams.forEach((value, key) => {\n    hashParameters[key] = value;\n  });\n  let instanceParameters = {};\n  let error = \"\";\n  if (!queryParameters.windowId) {\n    if (Object.keys(hashParameters).length > 0 && hashParameters.state) {\n      instanceParameters = JSON.parse(window.atob(decodeURIComponent(decodeURIComponent(hashParameters.state)))) || {};\n      error = hashParameters.error_description || hashParameters.error || error;\n    } else if (Object.keys(queryParameters).length > 0 && queryParameters.state) {\n      instanceParameters = JSON.parse(window.atob(decodeURIComponent(decodeURIComponent(queryParameters.state)))) || {};\n      if (queryParameters.error) error = queryParameters.error;\n    }\n  }\n  return {\n    error,\n    instanceParameters,\n    hashParameters\n  };\n};\nfunction sleep(ms) {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\nclass BaseKeyringController extends BaseController {\n  constructor(_ref) {\n    var _state$wallets;\n    let {\n      config = {},\n      state\n    } = _ref;\n    super({\n      config,\n      state\n    });\n    this.defaultState = {\n      wallets: (_state$wallets = state.wallets) !== null && _state$wallets !== void 0 ? _state$wallets : []\n    };\n    this.initialize();\n  } // for signing auth message\n\n  signAuthMessage(address, message) {\n    const keyring = this.state.wallets.find(x => x.address === address);\n    if (!keyring) {\n      throw new Error(\"key does not exist\");\n    }\n    const hashedMessage = hashMessage(message).toString(\"hex\");\n    const rawMessageSig = signMessage(keyring.privateKey, hashedMessage);\n    return rawMessageSig;\n  }\n}\nconst RETRIABLE_ERRORS = [\n// ignore server overload errors\n\"Gateway timeout\", \"ETIMEDOUT\",\n// ignore server sent html error pages\n// or truncated json responses\n\"failed to parse response body\",\n// ignore errors where http req failed to establish\n\"Failed to fetch\"];\nfunction checkForHttpErrors(fetchRes) {\n  // check for errors\n  switch (fetchRes.status) {\n    case 405:\n      throw ethErrors.rpc.methodNotFound();\n    case 418:\n      throw ethErrors.rpc.internal({\n        message: \"Request is being rate limited.\"\n      });\n    case 503:\n    case 504:\n      throw ethErrors.rpc.internal({\n        message: \"Gateway timeout. The request took too long to process.\" + \"This can happen when querying over too wide a block range.\"\n      });\n  }\n}\nfunction timeout(duration) {\n  return new Promise(resolve => setTimeout(resolve, duration));\n}\nfunction parseResponse(fetchRes, body) {\n  // check for error code\n  if (fetchRes.status !== 200) {\n    throw ethErrors.rpc.internal({\n      message: \"Non-200 status code: '\".concat(fetchRes.status, \"'\"),\n      data: body\n    });\n  } // check for rpc error\n\n  if (body.error) {\n    throw ethErrors.rpc.internal({\n      data: body.error\n    });\n  } // return successful result\n\n  return body.result;\n}\nfunction createFetchConfigFromReq(_ref) {\n  let {\n    req,\n    rpcTarget,\n    originHttpHeaderKey\n  } = _ref;\n  const parsedUrl = new URL(rpcTarget); // prepare payload\n  // copy only canonical json rpc properties\n\n  const payload = {\n    id: req.id,\n    jsonrpc: req.jsonrpc,\n    method: req.method,\n    params: req.params\n  }; // extract 'origin' parameter from request\n\n  const originDomain = req.origin; // serialize request body\n\n  const serializedPayload = JSON.stringify(payload); // configure fetch params\n\n  const fetchParams = {\n    method: \"POST\",\n    headers: {\n      Accept: \"application/json\",\n      \"Content-Type\": \"application/json\"\n    },\n    body: serializedPayload\n  }; // optional: add request origin as header\n\n  if (originHttpHeaderKey && originDomain) {\n    fetchParams.headers[originHttpHeaderKey] = originDomain;\n  }\n  return {\n    fetchUrl: parsedUrl.href,\n    fetchParams\n  };\n}\nfunction createFetchMiddleware(_ref2) {\n  let {\n    rpcTarget,\n    originHttpHeaderKey\n  } = _ref2;\n  return createAsyncMiddleware(async (req, res, _next) => {\n    const {\n      fetchUrl,\n      fetchParams\n    } = createFetchConfigFromReq({\n      req,\n      rpcTarget,\n      originHttpHeaderKey\n    }); // attempt request multiple times\n\n    const maxAttempts = 5;\n    const retryInterval = 1000;\n    for (let attempt = 0; attempt < maxAttempts; attempt++) {\n      try {\n        const fetchRes = await fetch(fetchUrl, fetchParams); // check for http errrors\n\n        checkForHttpErrors(fetchRes); // parse response body\n\n        const fetchBody = await fetchRes.json();\n        const result = parseResponse(fetchRes, fetchBody); // set result and exit retry loop\n\n        res.result = result;\n        return;\n      } catch (err) {\n        const errMsg = err.toString();\n        const isRetriable = RETRIABLE_ERRORS.some(phrase => errMsg.includes(phrase)); // re-throw error if not retriable\n\n        if (!isRetriable) {\n          throw err;\n        }\n      } // delay before retrying\n\n      await timeout(retryInterval);\n    }\n  });\n}\nfunction createLoggerMiddleware(options) {\n  return function loggerMiddleware(request, response, next) {\n    next(callback => {\n      if (response.error) {\n        log.warn(\"Error in RPC response:\\n\", response);\n      }\n      if (request.isTorusInternal) return;\n      log.info(\"RPC (\".concat(options.origin, \"):\"), request, \"->\", response);\n      callback();\n    });\n  };\n}\nfunction createOriginMiddleware(options) {\n  return function originMiddleware(request, _, next) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    request.origin = options.origin;\n    next();\n  };\n}\nclass BroadcastChannelHandler {\n  constructor(channelPrefix) {\n    _defineProperty(this, \"bc\", void 0);\n    _defineProperty(this, \"channel\", void 0);\n    const queryParameters = new URLSearchParams(window.location.search);\n    const instanceId = queryParameters.get(\"instanceId\");\n    this.channel = \"\".concat(channelPrefix, \"_\").concat(instanceId);\n    this.bc = new BroadcastChannel(this.channel, broadcastChannelOptions);\n  }\n  getMessageFromChannel() {\n    return new Promise((resolve, reject) => {\n      this.bc.addEventListener(\"message\", async ev => {\n        this.bc.close();\n        if (ev.error) {\n          reject(ev.error);\n        } else {\n          resolve(ev.data);\n        }\n      });\n      this.bc.postMessage({\n        data: {\n          type: POPUP_LOADED\n        }\n      });\n    });\n  }\n}\nclass StreamWindow extends BaseController {\n  // if window has been closed by users\n  constructor(_ref) {\n    let {\n      config,\n      state = {}\n    } = _ref;\n    super({\n      config,\n      state\n    });\n    _defineProperty(this, \"closed\", false);\n    this.initialize();\n  }\n  async open() {\n    return new Promise((resolve, reject) => {\n      const {\n        communicationEngine,\n        communicationWindowManager\n      } = this.config;\n      let popupSuccess = false;\n      communicationWindowManager.once(\"\".concat(this.state.windowId, \":closed\"), () => {\n        this.closed = true;\n      }); // Window is not open yet\n\n      if (!this.state.windowId) {\n        this.update({\n          windowId: randomId()\n        });\n        communicationWindowManager.once(\"\".concat(this.state.windowId, \":opened\"), () => {\n          resolve(this);\n        }); // Tell the other party to create a window by prompting the user to click on something\n\n        communicationEngine.emit(\"notification\", {\n          method: COMMUNICATION_NOTIFICATIONS.CREATE_WINDOW,\n          params: {\n            windowId: this.state.windowId,\n            url: this.state.url.href\n          }\n        });\n      } else {\n        // Send this window with `windowId` the url to open via bc\n        const bc = new BroadcastChannel(this.state.windowId, broadcastChannelOptions);\n        bc.addEventListener(\"message\", async ev => {\n          try {\n            log.info(ev, \"receiving data on channel: \".concat(bc.name));\n            const {\n              error\n            } = ev;\n            if (error) {\n              // Popup says some error. so, we say it's not really opened\n              reject(new Error(error));\n              return;\n            }\n            const {\n              message\n            } = ev.data;\n            if (message === POPUP_LOADED) {\n              popupSuccess = true;\n              await bc.postMessage({\n                data: {\n                  url: this.state.url.href,\n                  message: \"\" // No need of a msg\n                }\n              });\n              resolve(this);\n              bc.close();\n            }\n          } catch (error) {\n            reject(error);\n            bc.close(); // Something went wrong. so, we close that window\n\n            this.close();\n          }\n        }); // We don't know if the other end is ready to receive this msg. So, we keep writing until it receives and sends back something\n        // we need backoff strategy\n        // we need to wait for first attempt to succeed/fail until the second attempt\n        // If we get 429, we need to wait for a while and then try again\n\n        const postMsg = async () => {\n          // this never throws\n          const localResponse = await bc.postMessage({\n            data: {\n              message: SETUP_COMPLETE\n            }\n          });\n          return localResponse;\n        };\n        let currentDelay = bc.type === \"server\" ? 1000 : 200;\n        const recursiveFn = async () => {\n          if (!popupSuccess && !this.closed) {\n            const localResponse = await postMsg();\n            if (bc.type === \"server\") {\n              const serverResponse = localResponse;\n              if (serverResponse.status >= 400) {\n                // We need to wait for a while and then try again\n                currentDelay = Math.round(currentDelay * 1.5);\n              }\n            }\n            await sleep(currentDelay);\n            await recursiveFn();\n          }\n        };\n        recursiveFn();\n      }\n    });\n  }\n  close() {\n    const {\n      communicationEngine\n    } = this.config;\n    communicationEngine.emit(\"notification\", {\n      method: COMMUNICATION_NOTIFICATIONS.CLOSE_WINDOW,\n      params: {\n        windowId: this.state.windowId\n      }\n    });\n  }\n}\n\n/*\nScenarios:\n1. Open a normal popup window and no communication with it - Use PopupHandler\n2. Open a popup window and communicate with it - Use PopupWithBcHandler (can initiate communication by waiting for window to open or not)\n\n3. If window is already opened, pass in windowId to the popup handler.\n   This will establish communication with the popup window and sends it a new url to redirect to\n\n\nIf you're trying to open a window and it gets blocked (happens if you're in iframe or delay b/w click and opening window),\nStreamWindow is invoked and it writes in a channel to display a message to the user\n\nOnce user clicks on that modal/dialog, we pre-open the window and pass in the windowId (goes to 3)\n*/\n\n/**\n * Handles popup window management.\n * For broadcast channel communication, use url with `instanceId` coded into state parameter.\n * This state parameter will be passed across redirects according to OAuth spec.\n */\n\nclass PopupHandler extends BaseController {\n  constructor(_ref) {\n    let {\n      config,\n      state\n    } = _ref;\n    super({\n      config,\n      state\n    }); // this.id = randomId()\n    // Add in dapp storage key to all popups as a hash parameter\n\n    this.defaultConfig = {\n      dappStorageKey: \"\",\n      features: getPopupFeatures(FEATURES_DEFAULT_POPUP_WINDOW),\n      target: \"_blank\",\n      communicationEngine: null,\n      communicationWindowManager: null\n    };\n    this.defaultState = {\n      windowTimer: null,\n      window: null,\n      iClosedWindow: false,\n      windowId: \"\",\n      url: state.url\n    };\n    this.initialize();\n    this._setupTimer();\n  }\n  async open() {\n    // if window is already open\n    const {\n      target,\n      features,\n      dappStorageKey,\n      communicationEngine,\n      communicationWindowManager\n    } = this.config;\n    const {\n      windowId,\n      url\n    } = this.state;\n    if (dappStorageKey) {\n      const urlHashParams = new URLSearchParams(url.hash.slice(1));\n      urlHashParams.append(\"dappStorageKey\", dappStorageKey);\n      url.hash = urlHashParams.toString();\n      this.update({\n        url\n      });\n    } // No window has been pre-opened\n\n    if (!windowId) {\n      // try to open a window first\n      let localWindow = window.open(url.href, target, features);\n      if (!localWindow) {\n        // if it's blocked, open StreamWindow\n        localWindow = new StreamWindow({\n          config: {\n            communicationEngine,\n            communicationWindowManager\n          },\n          state: {\n            url\n          }\n        });\n        localWindow.open();\n      }\n      this.update({\n        window: localWindow\n      });\n      return;\n    } // A window has been pre-opened with a query parameter `windowId`\n\n    const localWindow = new StreamWindow({\n      config: {\n        communicationEngine,\n        communicationWindowManager\n      },\n      state: {\n        url,\n        windowId\n      }\n    });\n    this.update({\n      window: localWindow\n    });\n    await localWindow.open();\n  }\n  close() {\n    this.update({\n      iClosedWindow: true\n    });\n    const {\n      window\n    } = this.state;\n    if (window) window.close();\n  }\n  _setupTimer() {\n    const timer = window.setInterval(() => {\n      const {\n        window,\n        windowTimer,\n        iClosedWindow\n      } = this.state;\n      if (window && window.closed) {\n        if (windowTimer) clearInterval(windowTimer);\n        if (!iClosedWindow) {\n          this.emit(\"close\");\n        }\n        this.update({\n          iClosedWindow: false,\n          window: null\n        });\n      }\n      if (window === null && windowTimer) clearInterval(windowTimer);\n    }, 500);\n    this.update({\n      windowTimer: timer\n    });\n  }\n}\nclass PopupStoreChannel {\n  constructor(_ref) {\n    let {\n      instanceId,\n      handleLogout,\n      handleAccountImport,\n      handleNetworkChange,\n      handleSelectedAddressChange,\n      handleThemeChange\n    } = _ref;\n    _defineProperty(this, \"handleLogout\", void 0);\n    _defineProperty(this, \"handleAccountImport\", void 0);\n    _defineProperty(this, \"handleNetworkChange\", void 0);\n    _defineProperty(this, \"handleThemeChange\", void 0);\n    _defineProperty(this, \"handleSelectedAddressChange\", void 0);\n    _defineProperty(this, \"instanceId\", void 0);\n    this.instanceId = instanceId;\n    this.handleLogout = handleLogout;\n    this.handleAccountImport = handleAccountImport;\n    this.handleNetworkChange = handleNetworkChange;\n    this.handleSelectedAddressChange = handleSelectedAddressChange;\n    this.handleThemeChange = handleThemeChange;\n  }\n  setupStoreChannels() {\n    this.logoutChannel();\n    this.importAccountChannel();\n    this.networkChangeChannel();\n    this.selectedAddressChangeChannel();\n    this.themeChangedChannel();\n  }\n  logoutChannel() {\n    const logoutChannel = new BroadcastChannel(\"\".concat(BROADCAST_CHANNELS.WALLET_LOGOUT_CHANNEL, \"_\").concat(this.instanceId), broadcastChannelOptions);\n    logoutChannel.addEventListener(\"message\", ev => {\n      var _ev$data;\n      log.info(\"received logout message\", ev);\n      if (!ev.error && ((_ev$data = ev.data) === null || _ev$data === void 0 ? void 0 : _ev$data.type) === BROADCAST_CHANNELS_MSGS.LOGOUT) {\n        log.info(\"Logging Out\");\n        this.handleLogout();\n      }\n    });\n  }\n  importAccountChannel() {\n    const walletAccountImportChannel = new BroadcastChannel(\"\".concat(BROADCAST_CHANNELS.WALLET_ACCOUNT_IMPORT_CHANNEL, \"_\").concat(this.instanceId), broadcastChannelOptions);\n    walletAccountImportChannel.addEventListener(\"message\", ev => {\n      var _ev$data2;\n      if (!ev.error && ((_ev$data2 = ev.data) === null || _ev$data2 === void 0 ? void 0 : _ev$data2.type) === BROADCAST_CHANNELS_MSGS.ACCOUNT_IMPORTED) {\n        var _ev$data3;\n        this.handleAccountImport((_ev$data3 = ev.data) === null || _ev$data3 === void 0 ? void 0 : _ev$data3.privKey);\n      }\n    });\n  }\n  networkChangeChannel() {\n    const walletAccountImportChannel = new BroadcastChannel(\"\".concat(BROADCAST_CHANNELS.WALLET_NETWORK_CHANGE_CHANNEL, \"_\").concat(this.instanceId), broadcastChannelOptions);\n    walletAccountImportChannel.addEventListener(\"message\", ev => {\n      var _ev$data4;\n      if (!ev.error && ((_ev$data4 = ev.data) === null || _ev$data4 === void 0 ? void 0 : _ev$data4.type) === BROADCAST_CHANNELS_MSGS.NETWORK_CHANGE) {\n        var _ev$data5;\n        this.handleNetworkChange((_ev$data5 = ev.data) === null || _ev$data5 === void 0 ? void 0 : _ev$data5.network);\n      }\n    });\n  }\n  themeChangedChannel() {\n    const walletAccountImportChannel = new BroadcastChannel(\"\".concat(BROADCAST_CHANNELS.THEME_CHANGE, \"_\").concat(this.instanceId), broadcastChannelOptions);\n    walletAccountImportChannel.addEventListener(\"message\", ev => {\n      var _ev$data6;\n      log.info({\n        ev\n      });\n      if (!ev.error && ((_ev$data6 = ev.data) === null || _ev$data6 === void 0 ? void 0 : _ev$data6.type) === BROADCAST_CHANNELS_MSGS.SET_THEME) {\n        var _ev$data7;\n        this.handleThemeChange((_ev$data7 = ev.data) === null || _ev$data7 === void 0 ? void 0 : _ev$data7.theme);\n      }\n    });\n  }\n  selectedAddressChangeChannel() {\n    const walletAccountImportChannel = new BroadcastChannel(\"\".concat(BROADCAST_CHANNELS.WALLET_SELECTED_ADDRESS_CHANNEL, \"_\").concat(this.instanceId), broadcastChannelOptions);\n    walletAccountImportChannel.addEventListener(\"message\", ev => {\n      var _ev$data8;\n      if (!ev.error && ((_ev$data8 = ev.data) === null || _ev$data8 === void 0 ? void 0 : _ev$data8.type) === BROADCAST_CHANNELS_MSGS.SELECTED_ADDRESS_CHANGE) {\n        var _ev$data9;\n        this.handleSelectedAddressChange((_ev$data9 = ev.data) === null || _ev$data9 === void 0 ? void 0 : _ev$data9.selectedAddress);\n      }\n    });\n  }\n}\n\n/**\n * PopupWithBcHandler is a PopupHandler which uses broadcast channel to communicate with the popup window.\n */\n\nclass PopupWithBcHandler extends PopupHandler {\n  constructor(_ref) {\n    let {\n      config,\n      state,\n      instanceId\n    } = _ref;\n    super({\n      config,\n      state\n    });\n    _defineProperty(this, \"bc\", void 0);\n    this.bc = new BroadcastChannel(instanceId, broadcastChannelOptions);\n  }\n  /**\n   * Receives the data from popup window and closes the window\n   * @param successExtraFn - Extra function to be called after the data is received\n   * @returns The data to be received\n   */\n\n  handle(successExtraFn) {\n    return new Promise((resolve, reject) => {\n      const closeListener = () => {\n        this.bc.close();\n        reject(new UserError(\"user closed popup\"));\n        this.removeListener(\"close\", closeListener);\n      };\n      this.on(\"close\", closeListener);\n      this.bc.addEventListener(\"message\", async ev => {\n        log.info(ev, \"receiving data on channel: \".concat(this.bc.name));\n        try {\n          const {\n            error,\n            data\n          } = ev;\n          if (error) {\n            reject(new Error(error));\n            return;\n          }\n          if (successExtraFn) await successExtraFn.call(this, data);\n          resolve(data);\n        } catch (error) {\n          reject(error);\n        } finally {\n          this.bc.close();\n          this.close();\n        }\n      });\n      this.open().then(() => {\n        log.info(\"opened window \".concat(this.bc.name)); // Opened window. yay.  let the bc events do their job\n\n        return undefined;\n      }).catch(err => {\n        log.error(err, \"something went wrong while opening window\");\n        reject(err);\n      });\n    });\n  }\n  /**\n   * Use this if we have to send large payloads which don't fit in query/hash params.\n   * Waits for ack that popup window is ready to receive data.\n   * Receives the data from popup window and closes the window\n   * @param payload - The data to be sent to the popup window once we have ack that window is ready to receive data\n   * @param successExtraFn - Extra function to be called after the data is received\n   * @returns The data to be received\n   */\n\n  handleWithHandshake(payload, successExtraFn) {\n    return new Promise((resolve, reject) => {\n      const closeListener = () => {\n        this.bc.close();\n        reject(new UserError(\"user closed popup\"));\n        this.removeListener(\"close\", closeListener);\n      };\n      this.on(\"close\", closeListener);\n      this.bc.addEventListener(\"message\", async ev => {\n        try {\n          log.info(ev, \"receiving data on channel: \".concat(this.bc.name));\n          const {\n            error,\n            data\n          } = ev;\n          if (error) {\n            reject(new Error(error));\n            return;\n          } // Do handshake\n\n          const {\n            type = \"\"\n          } = data;\n          if (type === POPUP_LOADED) {\n            // Hack with generic to use the same type for both send and receive\n            await this.bc.postMessage({\n              data: payload\n            });\n          } else if (type === POPUP_RESULT) {\n            if (successExtraFn) await successExtraFn.call(this, data);\n            resolve(data); // Must only close the bc after result is done\n\n            this.bc.close();\n            this.close();\n          }\n        } catch (error) {\n          reject(error);\n          this.bc.close();\n          this.close();\n        }\n      });\n      this.open().then(() => {\n        log.info(\"opened window \".concat(this.bc.name)); // Opened window. yay.  let the bc events do their job\n\n        return undefined;\n      }).catch(err => {\n        log.error(err, \"something went wrong while opening window\");\n        reject(err);\n      });\n    });\n  }\n}\nclass RedirectHandler {\n  constructor() {\n    _defineProperty(this, \"error\", void 0);\n    _defineProperty(this, \"finalQueryParams\", {});\n    _defineProperty(this, \"instanceParameters\", void 0);\n    _defineProperty(this, \"hashParameters\", void 0);\n    const {\n      hash\n    } = window.location;\n    const queryParameters = new URLSearchParams(window.location.search);\n    queryParameters.forEach((value, key) => {\n      this.finalQueryParams[key] = value;\n    });\n    const {\n      error,\n      instanceParameters,\n      hashParameters\n    } = handleRedirectParameters(hash, this.finalQueryParams);\n    this.error = error;\n    this.instanceParameters = instanceParameters;\n    this.hashParameters = hashParameters;\n  }\n  async handle() {\n    return new Promise((resolve, reject) => {\n      const {\n        finalQueryParams,\n        instanceParameters,\n        hashParameters,\n        error\n      } = this;\n      let bc;\n      try {\n        if (!finalQueryParams.windowId) {\n          bc = new BroadcastChannel(\"\".concat(BROADCAST_CHANNELS.REDIRECT_CHANNEL, \"_\").concat(instanceParameters.instanceId), broadcastChannelOptions);\n          bc.addEventListener(\"message\", async ev => {\n            if (ev.error) {\n              reject(ev.error);\n              window.close();\n            } else {\n              resolve();\n              bc.close();\n              log.info(\"posted\", {\n                finalQueryParams,\n                hashParameters,\n                instanceParameters\n              });\n            }\n          });\n          bc.postMessage({\n            data: {\n              instanceParams: instanceParameters,\n              hashParams: hashParameters,\n              queryParams: finalQueryParams\n            },\n            error\n          });\n          setTimeout(() => {\n            resolve();\n            window.location.href = window.location.origin + window.location.search + window.location.hash;\n          }, 5000);\n        } else {\n          bc = new BroadcastChannel(\"\".concat(finalQueryParams.windowId), broadcastChannelOptions);\n          bc.addEventListener(\"message\", async ev => {\n            const {\n              url,\n              message\n            } = ev.data;\n            if (url) {\n              resolve();\n              window.location.href = url;\n            } else if (message === SETUP_COMPLETE) {\n              await bc.postMessage({\n                data: {\n                  windowId: finalQueryParams.windowId,\n                  message: POPUP_LOADED\n                }\n              });\n            }\n            if (ev.error && ev.error !== \"\") {\n              log.error(ev.error);\n              resolve();\n              bc.close();\n            }\n          });\n        }\n      } catch (err) {\n        log.info(err, \"something went wrong\");\n        reject(err);\n        if (bc) bc.close();\n        window.close();\n      }\n    });\n  }\n}\nconst ACTIVITY_ACTION = {\n  ACTIVITY_ACTION_ALL: \"walletActivity.allTransactions\",\n  ACTIVITY_ACTION_SEND: \"walletActivity.send\",\n  ACTIVITY_ACTION_RECEIVE: \"walletActivity.receive\",\n  ACTIVITY_ACTION_TOPUP: \"walletActivity.topup\"\n};\nconst ACCOUNT_CATEGORY = {\n  NORMAL: \"normal\",\n  THRESHOLD: \"threshold\",\n  IMPORTED: \"imported\"\n};\nfunction ownKeys$1(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread$1(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys$1(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\nconst DEFAULT_INTERVAL = 180 * 1000;\nconst DEFAULT_PREFERENCES = {\n  selectedCurrency: \"USD\",\n  theme: \"dark\",\n  locale: \"en-US\",\n  accountType: ACCOUNT_CATEGORY.NORMAL,\n  contacts: [],\n  jwtToken: \"\",\n  fetchedPastTx: [],\n  pastTransactions: [],\n  paymentTx: [],\n  defaultPublicAddress: \"\",\n  customTokens: [],\n  customNfts: [],\n  crashReport: true,\n  userInfo: {\n    aggregateVerifier: \"\",\n    email: \"\",\n    name: \"\",\n    profileImage: \"\",\n    typeOfLogin: LOGIN_PROVIDER.GOOGLE,\n    verifier: \"\",\n    verifierId: \"\"\n  }\n};\n/**\n * Controller that stores shared settings and exposes convenience methods\n */\n\nclass BasePreferencesController extends BaseController {\n  /**\n   * Name of this controller used during composition\n   */\n\n  /**\n   * Creates a PreferencesController instance\n   *\n   * @param config - Initial options used to configure this controller\n   * @param state - Initial state to set on this controller\n   */\n  constructor(_ref) {\n    let {\n      config,\n      state,\n      defaultPreferences,\n      signAuthMessage\n    } = _ref;\n    super({\n      config,\n      state\n    });\n    _defineProperty(this, \"name\", \"PreferencesController\");\n    _defineProperty(this, \"iframeOrigin\", void 0);\n    _defineProperty(this, \"signAuthMessage\", void 0);\n    _defineProperty(this, \"defaultPreferences\", void 0);\n    if (!config.api) {\n      throw new Error(\"PreferencesController - no api specified in config.\");\n    }\n    this.defaultState = {\n      identities: {},\n      selectedAddress: \"\",\n      lastErrorMessage: \"\",\n      lastSuccessMessage: \"\"\n    };\n    this.defaultConfig = {\n      api: config.api,\n      pollInterval: DEFAULT_INTERVAL\n    };\n    this.initialize();\n    this.defaultPreferences = _objectSpread$1(_objectSpread$1({}, DEFAULT_PREFERENCES), defaultPreferences);\n    this.signAuthMessage = signAuthMessage;\n  }\n  setIframeOrigin(origin) {\n    this.iframeOrigin = origin;\n  }\n  getAddressState(address) {\n    const selectedAddress = address || this.state.selectedAddress;\n    return this.state.identities[selectedAddress];\n  }\n  /**\n   * Sets selected address\n   *\n   * @param selectedAddress - casper account hash\n   */\n\n  setSelectedAddress(selectedAddress) {\n    this.update({\n      selectedAddress\n    });\n  }\n  async getUser(address) {\n    const user = await get(\"\".concat(this.config.api, \"/user?fetchTx=false\"), this.headers(address), {\n      useAPIKey: true\n    });\n    return user.data;\n  }\n  async createUser(params) {\n    const {\n      selectedCurrency,\n      theme,\n      verifier,\n      verifierId,\n      locale,\n      address,\n      idToken\n    } = params;\n    const userPayload = {\n      default_currency: selectedCurrency,\n      theme,\n      verifier,\n      verifier_id: verifierId,\n      locale,\n      idToken\n    };\n    await post(\"\".concat(this.config.api, \"/user\"), userPayload, this.headers(address), {\n      useAPIKey: true\n    });\n    this.updateState({\n      theme,\n      defaultPublicAddress: address,\n      selectedCurrency,\n      locale\n    }, address);\n  }\n  async storeUserLogin(params) {\n    const {\n      verifierId,\n      verifier,\n      options,\n      address,\n      idToken\n    } = params;\n    if (!options.rehydrate) {\n      const browser = bowser.getParser(window.navigator.userAgent);\n      const specialBrowser = getCustomDeviceInfo();\n      const recordLoginPayload = {\n        os: browser.getOSName(),\n        os_version: browser.getOSVersion() || \"unidentified\",\n        browser: (specialBrowser === null || specialBrowser === void 0 ? void 0 : specialBrowser.browser) || browser.getBrowserName() || \"unidentified\",\n        browser_version: browser.getBrowserVersion() || \"unidentified\",\n        platform: browser.getPlatform().type || \"desktop\",\n        hostname: this.iframeOrigin,\n        verifier,\n        verifier_id: verifierId,\n        idToken\n      };\n      await post(\"\".concat(this.config.api, \"/user/recordLogin\"), recordLoginPayload, this.headers(address), {\n        useAPIKey: true\n      });\n    }\n  }\n  async setCrashReport(isEnabled) {\n    var _this$getAddressState;\n    if (isEnabled === ((_this$getAddressState = this.getAddressState()) === null || _this$getAddressState === void 0 ? void 0 : _this$getAddressState.crashReport)) return true;\n    try {\n      await patch(\"\".concat(this.config.api, \"/user\"), {\n        enable_crash_reporter: isEnabled\n      }, this.headers(), {\n        useAPIKey: true\n      });\n      this.updateState({\n        crashReport: isEnabled\n      });\n      return true;\n    } catch (error) {\n      log.error(error);\n      return false;\n    }\n  }\n  async setUserTheme(theme) {\n    var _this$getAddressState2;\n    if (theme === ((_this$getAddressState2 = this.getAddressState()) === null || _this$getAddressState2 === void 0 ? void 0 : _this$getAddressState2.theme)) return true;\n    try {\n      await patch(\"\".concat(this.config.api, \"/user\"), {\n        theme\n      }, this.headers(), {\n        useAPIKey: true\n      });\n      this.updateState({\n        theme\n      });\n      return true;\n    } catch (error) {\n      log.error(error);\n      return false;\n    }\n  }\n  async setUserLocale(locale) {\n    var _this$getAddressState3;\n    if (locale === ((_this$getAddressState3 = this.getAddressState()) === null || _this$getAddressState3 === void 0 ? void 0 : _this$getAddressState3.locale)) return;\n    try {\n      await patch(\"\".concat(this.config.api, \"/user\"), {\n        locale\n      }, this.headers(), {\n        useAPIKey: true\n      });\n      this.updateState({\n        locale\n      });\n      return true;\n    } catch (error) {\n      log.error(\"unable to set locale\", error);\n      return false;\n    }\n  }\n  async setSelectedCurrency(payload) {\n    var _this$getAddressState4;\n    if (payload.selectedCurrency === ((_this$getAddressState4 = this.getAddressState()) === null || _this$getAddressState4 === void 0 ? void 0 : _this$getAddressState4.selectedCurrency)) return true;\n    try {\n      await patch(\"\".concat(this.config.api, \"/user\"), {\n        default_currency: payload.selectedCurrency\n      }, this.headers(), {\n        useAPIKey: true\n      });\n      this.updateState({\n        selectedCurrency: payload.selectedCurrency\n      });\n      return true;\n    } catch (error) {\n      log.error(error);\n      return false;\n    }\n  }\n  async addContact(contact) {\n    try {\n      var _this$getAddressState5;\n      const response = await post(\"\".concat(this.config.api, \"/contact\"), contact, this.headers(), {\n        useAPIKey: true\n      });\n      this.updateState({\n        contacts: [...(((_this$getAddressState5 = this.getAddressState()) === null || _this$getAddressState5 === void 0 ? void 0 : _this$getAddressState5.contacts) || []), response.data]\n      });\n      return true;\n    } catch (error) {\n      log.error(\"unable to add contact\", error);\n      return false;\n    }\n  }\n  async deleteContact(contactId) {\n    try {\n      var _this$getAddressState6;\n      const response = await remove(\"\".concat(this.config.api, \"/contact/\").concat(contactId), {}, this.headers(), {\n        useAPIKey: true\n      });\n      const finalContacts = (_this$getAddressState6 = this.getAddressState()) === null || _this$getAddressState6 === void 0 ? void 0 : _this$getAddressState6.contacts.filter(contact => contact.id !== response.data.id);\n      if (finalContacts) this.updateState({\n        contacts: [...finalContacts]\n      });\n      return true;\n    } catch (error) {\n      log.error(\"unable to delete contact\", error);\n      return false;\n    }\n  }\n  async revokeDiscord(idToken) {\n    try {\n      const resp = await post(\"\".concat(this.config.api, \"/revoke/discord\"), {\n        token: idToken\n      }, this.headers(), {\n        useAPIKey: true\n      });\n      log.info(resp);\n    } catch (error) {\n      log.error(error);\n    }\n  }\n  async patchPastTx(body, address) {\n    try {\n      const response = await patch(\"\".concat(this.config.api, \"/transaction\"), body, this.headers(address), {\n        useAPIKey: true\n      });\n      log.info(\"successfully patched\", response);\n    } catch (error) {\n      log.error(\"unable to patch tx\", error);\n    }\n  }\n  async postPastTx(tx, address) {\n    try {\n      const response = await post(\"\".concat(this.config.api, \"/transaction\"), tx, this.headers(address), {\n        useAPIKey: true\n      });\n      log.info(\"successfully posted tx\", response);\n      return response;\n    } catch (error) {\n      log.error(error, \"unable to insert transaction\");\n    }\n  }\n  async getWalletOrders(address) {\n    try {\n      const response = await get(\"\".concat(this.config.api, \"/transaction\"), this.headers(address), {\n        useAPIKey: true\n      });\n      return response.success ? response.data ? response.data : [] : [];\n    } catch (error) {\n      log.error(\"unable to get wallet orders tx\", error);\n      return [];\n    }\n  }\n  async getTopUpOrders(address) {\n    try {\n      const response = await get(\"\".concat(this.config.commonApiHost, \"/transaction\"), this.headers(address), {\n        useAPIKey: true\n      });\n      return response.data || [];\n    } catch (error) {\n      log.error(\"unable to fetch past Top up orders\", error);\n    }\n  }\n  async getBillBoardData() {\n    try {\n      const response = await get(\"\".concat(this.config.api, \"/billboard\"), this.headers(), {\n        useAPIKey: true\n      });\n      return response.success ? response.data : [];\n    } catch (error) {\n      log.error(\"unable to get billboard data\", error);\n      return [];\n    }\n  }\n  async getMessageForSigning(publicAddress) {\n    const response = await post(\"\".concat(this.config.api, \"/auth/message\"), {\n      public_address: publicAddress\n    }, {}, {\n      useAPIKey: true\n    });\n    return response.message;\n  }\n  async getTwitterId(payload) {\n    const res = await get(\"\".concat(this.config.api, \"/twitter?screen_name=\").concat(payload.nick), this.headers(), {\n      useAPIKey: true\n    });\n    return \"\".concat(payload.typeOfLogin.toLowerCase(), \"|\").concat(res.data.toString());\n  }\n  async sendEmail(payload) {\n    return post(\"\".concat(this.config.api, \"/transaction/sendemail\"), payload.emailObject, this.headers(), {\n      useAPIKey: true\n    });\n  }\n  async refreshJwt() {\n    const address = this.state.selectedAddress;\n    const messageToSign = await this.getMessageForSigning(address);\n    if (!messageToSign.startsWith(this.config.signInPrefix)) throw new Error(\"Cannot sign on invalid message\");\n    const signedMessage = this.signAuthMessage(address, messageToSign);\n    const response = await post(\"\".concat(this.config.api, \"/auth/verify\"), {\n      public_address: address,\n      signed_message: signedMessage\n    }, {}, {\n      useAPIKey: true\n    });\n    this.updateState({\n      jwtToken: response.token\n    }, address);\n  }\n  async getDappList() {\n    try {\n      const response = await get(\"\".concat(this.config.api, \"/dapps\"), this.headers(), {\n        useAPIKey: true\n      });\n      return response.success ? response.data : [];\n    } catch (error) {\n      log.error(\"unable to get billboard data\", error);\n      return [];\n    }\n  }\n  async init(address, userInfo, jwtToken) {\n    let response = {\n      token: jwtToken\n    };\n    if (this.getAddressState(address)) return;\n    if (!jwtToken) {\n      const messageToSign = await this.getMessageForSigning(address);\n      if (!messageToSign.startsWith(this.config.signInPrefix)) throw new Error(\"Cannot sign on invalid message\");\n      const signedMessage = this.signAuthMessage(address, messageToSign);\n      response = await post(\"\".concat(this.config.api, \"/auth/verify\"), {\n        public_address: address,\n        signed_message: signedMessage\n      }, {}, {\n        useAPIKey: true\n      });\n    }\n    this.updateState({\n      jwtToken: response.token,\n      userInfo\n    }, address);\n  }\n  updateState(preferences, address) {\n    const selectedAddress = address || this.state.selectedAddress;\n    const currentState = this.getAddressState(selectedAddress) || cloneDeep(this.defaultPreferences);\n    const mergedState = _objectSpread$1(_objectSpread$1({}, currentState), preferences);\n    this.update({\n      identities: _objectSpread$1(_objectSpread$1({}, this.state.identities), {}, {\n        [selectedAddress]: mergedState\n      })\n    });\n    return mergedState;\n  }\n  headers(address) {\n    var _this$getAddressState7;\n    const selectedAddress = address || this.state.selectedAddress;\n    return getHeaders(((_this$getAddressState7 = this.getAddressState(selectedAddress)) === null || _this$getAddressState7 === void 0 ? void 0 : _this$getAddressState7.jwtToken) || \"\");\n  }\n}\n\n/**\n * The status of the transaction. Each status represents the state of the transaction internally\n * in the wallet. Some of these correspond with the state of the transaction on the network, but\n * some are wallet-specific.\n */\nvar TransactionStatus;\n(function (TransactionStatus) {\n  TransactionStatus[\"approved\"] = \"approved\";\n  TransactionStatus[\"cancelled\"] = \"cancelled\";\n  TransactionStatus[\"confirmed\"] = \"confirmed\";\n  TransactionStatus[\"failed\"] = \"failed\";\n  TransactionStatus[\"finalized\"] = \"finalized\";\n  TransactionStatus[\"processed\"] = \"processed\";\n  TransactionStatus[\"rejected\"] = \"rejected\";\n  TransactionStatus[\"signed\"] = \"signed\";\n  TransactionStatus[\"submitted\"] = \"submitted\";\n  TransactionStatus[\"unapproved\"] = \"unapproved\";\n  TransactionStatus[\"dropped\"] = \"dropped\";\n  TransactionStatus[\"expired\"] = \"expired\";\n})(TransactionStatus || (TransactionStatus = {}));\nconst TRANSACTION_TYPES = {\n  CONTRACT_INTERACTION: \"contractInteraction\",\n  DEPLOY_CONTRACT: \"contractDeployment\",\n  WASM_BASED_DEPLOY: \"wasmBasedDeploy\",\n  STANDARD_TRANSACTION: \"transaction\",\n  STANDARD_PAYMENT_TRANSACTION: \"payment_transaction\" // specific to chains like solana and casper\n};\nconst TX_EVENTS = {\n  TX_WARNING: \"tx:warning\",\n  TX_ERROR: \"tx:error\",\n  TX_FAILED: \"tx:failed\",\n  TX_CONFIRMED: \"tx:confirmed\",\n  TX_DROPPED: \"tx:dropped\",\n  TX_EXPIRED: \"tx:expired\",\n  TX_STATUS_UPDATE: \"tx:status_update\",\n  TX_UNAPPROVED: \"tx:unapproved\"\n};\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\nclass BaseTransactionStateManager extends BaseController {\n  constructor(_ref) {\n    let {\n      config,\n      state,\n      getCurrentChainId\n    } = _ref;\n    super({\n      config,\n      state\n    });\n    _defineProperty(this, \"getCurrentChainId\", void 0);\n    this.defaultConfig = {\n      txHistoryLimit: 40\n    };\n    this.defaultState = {\n      transactions: {},\n      unapprovedTxs: {},\n      currentNetworkTxsList: []\n    };\n    this.initialize();\n    this.getCurrentChainId = getCurrentChainId;\n  }\n  getUnapprovedTxList() {\n    const chainId = this.getCurrentChainId();\n    return pickBy(this.state.transactions, transaction => transaction.status === TransactionStatus.unapproved && transactionMatchesNetwork(transaction, chainId));\n  }\n  getTransaction(txId) {\n    const {\n      transactions\n    } = this.state;\n    return transactions[txId];\n  }\n  updateTransaction(txMeta) {\n    // commit txMeta to state\n    const txId = txMeta.id;\n    txMeta.updated_at = new Date().toISOString();\n    this.update({\n      transactions: _objectSpread(_objectSpread({}, this.state.transactions), {}, {\n        [txId]: txMeta\n      })\n    });\n  }\n  setTxStatusRejected(txId) {\n    this._setTransactionStatus(txId, TransactionStatus.rejected);\n    this._deleteTransaction(txId);\n  }\n  /**\n   * The implementing controller can override this functionality and add custom logic + call super.()\n   */\n\n  setTxStatusUnapproved(txId) {\n    this._setTransactionStatus(txId, TransactionStatus.unapproved);\n  }\n  setTxStatusApproved(txId) {\n    this._setTransactionStatus(txId, TransactionStatus.approved);\n  }\n  setTxStatusSigned(txId) {\n    this._setTransactionStatus(txId, TransactionStatus.signed);\n  }\n  setTxStatusSubmitted(txId) {\n    this._setTransactionStatus(txId, TransactionStatus.submitted);\n  }\n  setTxStatusDropped(txId) {\n    this._setTransactionStatus(txId, TransactionStatus.dropped);\n  }\n  setTxStatusExpired(txId) {\n    this._setTransactionStatus(txId, TransactionStatus.expired);\n  }\n  setTxStatusConfirmed(txId) {\n    this._setTransactionStatus(txId, TransactionStatus.confirmed);\n  }\n  setTxStatusFailed(txId, error_) {\n    const error = !error_ ? new Error(\"Internal torus failure\") : error_;\n    const txMeta = this.getTransaction(txId);\n    txMeta.error = error;\n    this.updateTransaction(txMeta);\n    this._setTransactionStatus(txId, TransactionStatus.failed);\n  }\n  /**\n   * Method to determine if the transaction is in a final state\n   * @param status - Transaction status\n   * @returns boolean if the transaction is in a final state\n   */\n\n  isFinalState(status) {\n    return status === TransactionStatus.rejected || status === TransactionStatus.submitted || status === TransactionStatus.confirmed || status === TransactionStatus.failed || status === TransactionStatus.cancelled || status === TransactionStatus.expired;\n  }\n  /**\n   * Filters out the unapproved transactions from state\n   */\n\n  clearUnapprovedTxs() {\n    this.update({\n      transactions: omitBy(this.state.transactions, transaction => transaction.status === TransactionStatus.unapproved)\n    });\n  }\n  /**\n   * will append new transactions to old txns.\n   */\n\n  _addTransactionsToState(transactions) {\n    this.update({\n      transactions: transactions.reduce((result, newTx) => {\n        result[newTx.id] = newTx;\n        return result;\n      }, this.state.transactions)\n    });\n  }\n  /**\n   * will set new txns, override existing if any in state.\n   */\n\n  _setTransactionsToState(transactions) {\n    this.update({\n      transactions: transactions.reduce((result, newTx) => {\n        result[newTx.id] = newTx;\n        return result;\n      }, {})\n    });\n  }\n  _deleteTransaction(targetTransactionId) {\n    const {\n      transactions\n    } = this.state;\n    delete transactions[targetTransactionId];\n    this.update({\n      transactions\n    });\n  }\n  _deleteTransactions(targetTransactionIds) {\n    const {\n      transactions\n    } = this.state;\n    targetTransactionIds.forEach(transactionId => {\n      delete transactions[transactionId];\n    });\n    this.update({\n      transactions\n    });\n  }\n  _setTransactionStatus(txId, status) {\n    const txMeta = this.getTransaction(txId);\n    if (!txMeta) {\n      return;\n    }\n    txMeta.status = status; // only updating status so no validation required on txn.\n\n    this.updateTransaction(txMeta);\n    this.emit(TX_EVENTS.TX_STATUS_UPDATE, {\n      txId,\n      status\n    });\n    if (this.isFinalState(status)) {\n      this.emit(\"\".concat(txMeta.id, \":finished\"), txMeta);\n    } else {\n      this.emit(\"\".concat(txMeta.id, \":\").concat(status), txId);\n    }\n  }\n}\nexport { ACCOUNT_CATEGORY, ACTIVITY_ACTION, ACTIVITY_ACTION_ALL, ACTIVITY_ACTION_BURN, ACTIVITY_ACTION_RECEIVE, ACTIVITY_ACTION_SEND, ACTIVITY_ACTION_TOPUP, ACTIVITY_PERIOD_ALL, ACTIVITY_PERIOD_MONTH_ONE, ACTIVITY_PERIOD_MONTH_SIX, ACTIVITY_PERIOD_WEEK_ONE, ACTIVITY_STATUS_CANCELLED, ACTIVITY_STATUS_CANCELLING, ACTIVITY_STATUS_PENDING, ACTIVITY_STATUS_SUCCESSFUL, ACTIVITY_STATUS_UNSUCCESSFUL, BROADCAST_CHANNELS, BROADCAST_CHANNELS_MSGS, BaseBlockTracker, BaseController, BaseCurrencyController, BaseEmbedController, BaseKeyringController, BasePreferencesController, BaseTransactionStateManager, BroadcastChannelHandler, COMMUNICATION_JRPC_METHODS, COMMUNICATION_NOTIFICATIONS, CommunicationWindowManager, DEFAULT_PREFERENCES, FEATURES_CONFIRM_WINDOW, FEATURES_DEFAULT_POPUP_WINDOW, FEATURES_DEFAULT_WALLET_WINDOW, FEATURES_PROVIDER_CHANGE_WINDOW, LOGIN_PROVIDER, PAYMENT_PROVIDER, POPUP_LOADED, POPUP_RESULT, PROVIDER_JRPC_METHODS, PROVIDER_NOTIFICATIONS, PopupHandler, PopupStoreChannel, PopupWithBcHandler, RedirectHandler, SETUP_COMPLETE, StreamWindow, TRANSACTION_TYPES, TX_EVENTS, TransactionStatus, UserError, addressSlicer, broadcastChannelOptions, concatSig, createChangeProviderMiddlewareMiddleware, createCommunicationMiddleware, createEventEmitterProxy, createFetchConfigFromReq, createFetchMiddleware, createGenericJRPCMiddleware, createLoggerMiddleware, createOriginMiddleware, createRandomId, createSwappableProxy, createTopupMiddleware, formatDate, formatSmallNumbers, formatTime, getCustomDeviceInfo, getHeaders, getPopupFeatures, getTxStatusText, handleRedirectParameters, hashMessage, intToHex, padWithZeroes, providerAsMiddleware, providerFromEngine, providerFromMiddleware, randomId, signMessage, significantDigits, sleep, timeout$1 as timeout, transactionMatchesNetwork };","map":{"version":3,"names":["BaseController","SafeEventEmitter","constructor","_ref","config","state","_defineProperty","defaultConfig","defaultState","initialState","initialConfig","internalConfig","internalState","configure","overwrite","arguments","length","undefined","fullUpdate","Object","assign","key","update","_objectSpread$3","emit","initialize","sec","calculateSum","accumulator","currentValue","blockTrackerEvents","BaseBlockTracker","_currentBlock","idempotencyKey","_isRunning","blockResetDuration","_onNewListener","bind","_onRemoveListener","_resetCurrentBlock","_setupInternalEvents","isRunning","getCurrentBlock","getLatestBlock","latestBlock","Promise","resolve","once","newState","removeAllListeners","eventName","_start","_end","_newPotentialLatest","newBlock","currentBlock","_setCurrentBlock","removeListener","on","_maybeStart","_getBlockTrackerEventCount","_maybeEnd","_cancelBlockResetTimeout","_setupBlockResetTimeout","map","listenerCount","reduce","oldBlock","_blockResetTimeout","setTimeout","unref","clearTimeout","filterNoop","internalEvents","externalEventFilter","name","includes","getRawListeners","eventEmitter","rawListeners","createEventEmitterProxy","initialTarget","opts","finalOpts","eventFilter","Error","target","setTarget","newTarget","oldTarget","eventNames","filter","forEach","handler","proxy","Proxy","get","_","set","value","createSwappableProxy","POLLING_INTERVAL","BaseCurrencyController","currentCurrency","conversionRate","conversionDate","nativeCurrency","pollInterval","getNativeCurrency","setNativeCurrency","ticker","getCurrentCurrency","setCurrentCurrency","getConversionRate","setConversionRate","getConversionDate","setConversionDate","createRandomId","getCreateRandomId","providerFromEngine","engine","provider","sendAsync","req","res","handle","error","_res$error","_res$error2","err","serializeError","fallbackError","message","toString","code","ethErrors","rpc","internal","result","send","callback","request","args","_objectSpread$2","id","jsonrpc","providerFromMiddleware","middleware","JRPCEngine","push","providerAsMiddleware","_next","end","providerRes","FEATURES_PROVIDER_CHANGE_WINDOW","height","width","FEATURES_DEFAULT_WALLET_WINDOW","FEATURES_DEFAULT_POPUP_WINDOW","FEATURES_CONFIRM_WINDOW","POPUP_LOADED","POPUP_RESULT","SETUP_COMPLETE","ACTIVITY_ACTION_ALL","ACTIVITY_ACTION_SEND","ACTIVITY_ACTION_BURN","ACTIVITY_ACTION_RECEIVE","ACTIVITY_ACTION_TOPUP","ACTIVITY_PERIOD_ALL","ACTIVITY_PERIOD_WEEK_ONE","ACTIVITY_PERIOD_MONTH_ONE","ACTIVITY_PERIOD_MONTH_SIX","ACTIVITY_STATUS_SUCCESSFUL","ACTIVITY_STATUS_UNSUCCESSFUL","ACTIVITY_STATUS_PENDING","ACTIVITY_STATUS_CANCELLED","ACTIVITY_STATUS_CANCELLING","COMMUNICATION_NOTIFICATIONS","IFRAME_STATUS","CREATE_WINDOW","CLOSE_WINDOW","USER_LOGGED_IN","USER_LOGGED_OUT","COMMUNICATION_JRPC_METHODS","LOGOUT","WALLET_INSTANCE_ID","USER_INFO","SET_PROVIDER","TOPUP","OPENED_WINDOW","CLOSED_WINDOW","GET_PROVIDER_STATE","LOGIN_WITH_PRIVATE_KEY","PROVIDER_JRPC_METHODS","PROVIDER_NOTIFICATIONS","ACCOUNTS_CHANGED","CHAIN_CHANGED","UNLOCK_STATE_CHANGED","BROADCAST_CHANNELS","REDIRECT_CHANNEL","PROVIDER_CHANGE_CHANNEL","TRANSACTION_CHANNEL","MESSAGE_CHANNEL","WALLET_LOGOUT_CHANNEL","WALLET_SELECTED_ADDRESS_CHANNEL","WALLET_NETWORK_CHANGE_CHANNEL","WALLET_ACCOUNT_IMPORT_CHANNEL","THEME_CHANGE","BROADCAST_CHANNELS_MSGS","ACCOUNT_IMPORTED","SELECTED_ADDRESS_CHANGE","NETWORK_CHANGE","SET_THEME","createChangeProviderMiddlewareMiddleware","changeProvider","createAsyncMiddleware","response","next","method","createTopupMiddleware","_ref2","topup","createGenericJRPCMiddleware","targetMethod","concat","createCommunicationMiddleware","providerHandlers","getUserInfo","getWalletInstanceId","logout","setIFrameStatus","handleWindowRpc","getProviderState","loginWithPrivateKey","mergeMiddleware","createScaffoldMiddleware","BaseEmbedController","buttonPosition","isIFrameFullScreen","apiKey","oauthModalVisibility","loginInProgress","dappMetadata","icon","initializeProvider","handlers","communicationMiddleware","communicationProvider","setCommunicationProvider","_communicationProviderProxy","CommunicationWindowManager","params","windowId","LOGIN_PROVIDER","GOOGLE","FACEBOOK","REDDIT","DISCORD","TWITCH","APPLE","LINE","GITHUB","KAKAO","LINKEDIN","TWITTER","WEIBO","WECHAT","EMAIL_PASSWORDLESS","PAYMENT_PROVIDER","MOONPAY","WYRE","RAMPNETWORK","XANPOOL","MERCURYO","TRANSAK","getTxStatusText","txStatus","intToHex","i","hex","randomId","Math","random","slice","padWithZeroes","hexString","targetLength","test","String","prototype","padStart","call","concatSig","v","r","s","rSig","fromSigned","sSig","vSig","bufferToInt","rStr","toUnsigned","sStr","vStr","stripHexPrefix","addHexPrefix","timeout$1","timeout","duration","timeoutRef","window","getHeaders","jwt","headers","Authorization","formatSmallNumbers","number","currency","noTilde","finalNumber","BigNumber","isBigNumber","toNumber","Number","isFinite","toLowerCase","parseFloat","toFixed","tilde","toUpperCase","addressSlicer","address","sliceLength","significantDigits","perc","length_","input","isZero","times","depth","gte","ceil","log10","div","shift","pow","roundedNumber","round","formatDate","inputDate","monthList","date","Date","day","getDate","month","getMonth","year","getFullYear","formatTime","time","toTimeString","transactionMatchesNetwork","transaction","chainId","hashMessage","bufferedMessage","Buffer","from","el","hashPersonalMessage","signMessage","privateKey","data","privKey","msgSig","ecsign","rawMsgSig","intToBuffer","getPopupFeatures","w","h","dualScreenLeft","screenLeft","screenX","dualScreenTop","screenTop","screenY","innerWidth","document","documentElement","clientWidth","screen","innerHeight","clientHeight","systemZoom","left","abs","top","features","broadcastChannelOptions","webWorkerSupport","getCustomDeviceInfo","_navigator","navigator","brave","browser","UserError","handleRedirectParameters","hash","queryParameters","hashParameters","hashUrl","URL","location","origin","searchParams","instanceParameters","keys","JSON","parse","atob","decodeURIComponent","error_description","sleep","ms","BaseKeyringController","_state$wallets","wallets","signAuthMessage","keyring","find","x","hashedMessage","rawMessageSig","RETRIABLE_ERRORS","checkForHttpErrors","fetchRes","status","methodNotFound","parseResponse","body","createFetchConfigFromReq","rpcTarget","originHttpHeaderKey","parsedUrl","payload","originDomain","serializedPayload","stringify","fetchParams","Accept","fetchUrl","href","createFetchMiddleware","maxAttempts","retryInterval","attempt","fetch","fetchBody","json","errMsg","isRetriable","some","phrase","createLoggerMiddleware","options","loggerMiddleware","log","warn","isTorusInternal","info","createOriginMiddleware","originMiddleware","BroadcastChannelHandler","channelPrefix","URLSearchParams","search","instanceId","channel","bc","BroadcastChannel","getMessageFromChannel","reject","addEventListener","ev","close","postMessage","type","StreamWindow","open","communicationEngine","communicationWindowManager","popupSuccess","closed","url","postMsg","localResponse","currentDelay","recursiveFn","serverResponse","PopupHandler","dappStorageKey","windowTimer","iClosedWindow","_setupTimer","urlHashParams","append","localWindow","timer","setInterval","clearInterval","PopupStoreChannel","handleLogout","handleAccountImport","handleNetworkChange","handleSelectedAddressChange","handleThemeChange","setupStoreChannels","logoutChannel","importAccountChannel","networkChangeChannel","selectedAddressChangeChannel","themeChangedChannel","_ev$data","walletAccountImportChannel","_ev$data2","_ev$data3","_ev$data4","_ev$data5","network","_ev$data6","_ev$data7","theme","_ev$data8","_ev$data9","selectedAddress","PopupWithBcHandler","successExtraFn","closeListener","then","catch","handleWithHandshake","RedirectHandler","finalQueryParams","instanceParams","hashParams","queryParams","ACTIVITY_ACTION","ACCOUNT_CATEGORY","NORMAL","THRESHOLD","IMPORTED","DEFAULT_INTERVAL","DEFAULT_PREFERENCES","selectedCurrency","locale","accountType","contacts","jwtToken","fetchedPastTx","pastTransactions","paymentTx","defaultPublicAddress","customTokens","customNfts","crashReport","userInfo","aggregateVerifier","email","profileImage","typeOfLogin","verifier","verifierId","BasePreferencesController","defaultPreferences","api","identities","lastErrorMessage","lastSuccessMessage","_objectSpread$1","setIframeOrigin","iframeOrigin","getAddressState","setSelectedAddress","getUser","user","useAPIKey","createUser","idToken","userPayload","default_currency","verifier_id","post","updateState","storeUserLogin","rehydrate","bowser","getParser","userAgent","specialBrowser","recordLoginPayload","os","getOSName","os_version","getOSVersion","getBrowserName","browser_version","getBrowserVersion","platform","getPlatform","hostname","setCrashReport","isEnabled","_this$getAddressState","patch","enable_crash_reporter","setUserTheme","_this$getAddressState2","setUserLocale","_this$getAddressState3","setSelectedCurrency","_this$getAddressState4","addContact","contact","_this$getAddressState5","deleteContact","contactId","_this$getAddressState6","remove","finalContacts","revokeDiscord","resp","token","patchPastTx","postPastTx","tx","getWalletOrders","success","getTopUpOrders","commonApiHost","getBillBoardData","getMessageForSigning","publicAddress","public_address","getTwitterId","nick","sendEmail","emailObject","refreshJwt","messageToSign","startsWith","signInPrefix","signedMessage","signed_message","getDappList","init","preferences","currentState","cloneDeep","mergedState","_this$getAddressState7","TransactionStatus","TRANSACTION_TYPES","CONTRACT_INTERACTION","DEPLOY_CONTRACT","WASM_BASED_DEPLOY","STANDARD_TRANSACTION","STANDARD_PAYMENT_TRANSACTION","TX_EVENTS","TX_WARNING","TX_ERROR","TX_FAILED","TX_CONFIRMED","TX_DROPPED","TX_EXPIRED","TX_STATUS_UPDATE","TX_UNAPPROVED","BaseTransactionStateManager","getCurrentChainId","txHistoryLimit","transactions","unapprovedTxs","currentNetworkTxsList","getUnapprovedTxList","pickBy","unapproved","getTransaction","txId","updateTransaction","txMeta","updated_at","toISOString","_objectSpread","setTxStatusRejected","_setTransactionStatus","rejected","_deleteTransaction","setTxStatusUnapproved","setTxStatusApproved","approved","setTxStatusSigned","signed","setTxStatusSubmitted","submitted","setTxStatusDropped","dropped","setTxStatusExpired","expired","setTxStatusConfirmed","confirmed","setTxStatusFailed","error_","failed","isFinalState","cancelled","clearUnapprovedTxs","omitBy","_addTransactionsToState","newTx","_setTransactionsToState","targetTransactionId","_deleteTransactions","targetTransactionIds","transactionId"],"sources":["C:\\Users\\user\\Desktop\\BCEndterm\\node_modules\\@toruslabs\\base-controllers\\src\\BaseController.ts","C:\\Users\\user\\Desktop\\BCEndterm\\node_modules\\@toruslabs\\base-controllers\\src\\Block\\BaseBlockTracker.ts","C:\\Users\\user\\Desktop\\BCEndterm\\node_modules\\@toruslabs\\base-controllers\\src\\createEventEmitterProxy.ts","C:\\Users\\user\\Desktop\\BCEndterm\\node_modules\\@toruslabs\\base-controllers\\src\\createSwappableProxy.ts","C:\\Users\\user\\Desktop\\BCEndterm\\node_modules\\@toruslabs\\base-controllers\\src\\Currency\\BaseCurrencyController.ts","C:\\Users\\user\\Desktop\\BCEndterm\\node_modules\\@toruslabs\\base-controllers\\src\\Network\\INetworkController.ts","C:\\Users\\user\\Desktop\\BCEndterm\\node_modules\\@toruslabs\\base-controllers\\src\\enums.ts","C:\\Users\\user\\Desktop\\BCEndterm\\node_modules\\@toruslabs\\base-controllers\\src\\Embed\\CommunicationMethodMiddleware.ts","C:\\Users\\user\\Desktop\\BCEndterm\\node_modules\\@toruslabs\\base-controllers\\src\\Embed\\BaseEmbedController.ts","C:\\Users\\user\\Desktop\\BCEndterm\\node_modules\\@toruslabs\\base-controllers\\src\\Embed\\CommunicationWindowManager.ts","C:\\Users\\user\\Desktop\\BCEndterm\\node_modules\\@toruslabs\\base-controllers\\src\\interfaces.ts","C:\\Users\\user\\Desktop\\BCEndterm\\node_modules\\@toruslabs\\base-controllers\\src\\utils\\txUtils.ts","C:\\Users\\user\\Desktop\\BCEndterm\\node_modules\\@toruslabs\\base-controllers\\src\\utils\\utils.ts","C:\\Users\\user\\Desktop\\BCEndterm\\node_modules\\@toruslabs\\base-controllers\\src\\Keyring\\BaseKeyringController.ts","C:\\Users\\user\\Desktop\\BCEndterm\\node_modules\\@toruslabs\\base-controllers\\src\\Network\\createFetchMiddleware.ts","C:\\Users\\user\\Desktop\\BCEndterm\\node_modules\\@toruslabs\\base-controllers\\src\\Network\\createLoggerMiddleware.ts","C:\\Users\\user\\Desktop\\BCEndterm\\node_modules\\@toruslabs\\base-controllers\\src\\Network\\createOriginMiddleware.ts","C:\\Users\\user\\Desktop\\BCEndterm\\node_modules\\@toruslabs\\base-controllers\\src\\Popup\\BroadcastChannelHandler.ts","C:\\Users\\user\\Desktop\\BCEndterm\\node_modules\\@toruslabs\\base-controllers\\src\\Popup\\StreamWindow.ts","C:\\Users\\user\\Desktop\\BCEndterm\\node_modules\\@toruslabs\\base-controllers\\src\\Popup\\PopupHandler.ts","C:\\Users\\user\\Desktop\\BCEndterm\\node_modules\\@toruslabs\\base-controllers\\src\\Popup\\PopupStoreChannel.ts","C:\\Users\\user\\Desktop\\BCEndterm\\node_modules\\@toruslabs\\base-controllers\\src\\Popup\\PopupWithBcHandler.ts","C:\\Users\\user\\Desktop\\BCEndterm\\node_modules\\@toruslabs\\base-controllers\\src\\Popup\\RedirectHandler.ts","C:\\Users\\user\\Desktop\\BCEndterm\\node_modules\\@toruslabs\\base-controllers\\src\\Preferences\\IPreferencesController.ts","C:\\Users\\user\\Desktop\\BCEndterm\\node_modules\\@toruslabs\\base-controllers\\src\\Preferences\\BasePreferencesController.ts","C:\\Users\\user\\Desktop\\BCEndterm\\node_modules\\@toruslabs\\base-controllers\\src\\Transaction\\ITransactionController.ts","C:\\Users\\user\\Desktop\\BCEndterm\\node_modules\\@toruslabs\\base-controllers\\src\\Transaction\\BaseTransactionStateController.ts"],"sourcesContent":["import { SafeEventEmitter } from \"@toruslabs/openlogin-jrpc\";\n\nimport { BaseConfig, BaseState, IController } from \"./interfaces\";\n\n/**\n * Controller class that provides configuration, state management, and subscriptions\n */\nclass BaseController<C extends BaseConfig, S extends BaseState> extends SafeEventEmitter implements IController<C, S> {\n  /**\n   * Default options used to configure this controller\n   */\n  defaultConfig: C = {} as C;\n\n  /**\n   * Default state set on this controller\n   */\n  defaultState: S = {} as S;\n\n  /**\n   * Determines if listeners are notified of state changes\n   */\n  disabled = false;\n\n  /**\n   * Name of this controller used during composition\n   */\n  name = \"BaseController\";\n\n  private readonly initialConfig: C;\n\n  private readonly initialState: S;\n\n  private internalConfig: C = this.defaultConfig;\n\n  private internalState: S = this.defaultState;\n\n  /**\n   * Creates a BaseController instance. Both initial state and initial\n   * configuration options are merged with defaults upon initialization.\n   *\n   * @param config - Initial options used to configure this controller\n   * @param state - Initial state to set on this controller\n   */\n  constructor({ config = {} as C, state = {} as S }: { config?: Partial<C>; state?: Partial<S> }) {\n    super();\n    // Use assign since generics can't be spread: https://git.io/vpRhY\n    this.initialState = state as S;\n    this.initialConfig = config as C;\n  }\n\n  /**\n   * Retrieves current controller configuration options\n   *\n   * @returns - Current configuration\n   */\n  get config(): C {\n    return this.internalConfig;\n  }\n\n  /**\n   * Retrieves current controller state\n   *\n   * @returns - Current state\n   */\n  get state(): S {\n    return this.internalState;\n  }\n\n  /**\n   * Updates controller configuration\n   *\n   * @param config - New configuration options\n   * @param overwrite - Overwrite config instead of merging\n   * @param fullUpdate - Boolean that defines if the update is partial or not\n   */\n  configure(config: Partial<C>, overwrite = false, fullUpdate = true): void {\n    if (fullUpdate) {\n      this.internalConfig = overwrite ? (config as C) : Object.assign(this.internalConfig, config);\n\n      for (const key in this.internalConfig) {\n        if (typeof this.internalConfig[key] !== \"undefined\") {\n          this[key as string] = this.internalConfig[key];\n        }\n      }\n    } else {\n      for (const key in config) {\n        /* istanbul ignore else */\n        if (typeof this.internalConfig[key] !== \"undefined\") {\n          this.internalConfig[key] = config[key];\n          this[key as string] = config[key];\n        }\n      }\n    }\n  }\n\n  /**\n   * Updates controller state\n   *\n   * @param state - New state\n   * @param overwrite - Overwrite state instead of merging\n   */\n  update(state: Partial<S>, overwrite = false): void {\n    this.internalState = overwrite ? { ...(state as S) } : { ...this.internalState, ...state };\n    this.emit(\"store\", this.internalState);\n  }\n\n  /**\n   * Enables the controller. This sets each config option as a member\n   * variable on this instance and triggers any defined setters. This\n   * also sets initial state and triggers any listeners.\n   *\n   * @returns - This controller instance\n   */\n  protected initialize(): this {\n    this.internalState = this.defaultState;\n    this.internalConfig = this.defaultConfig;\n    this.configure(this.initialConfig);\n    this.update(this.initialState);\n    return this;\n  }\n}\n\nexport default BaseController;\n","import BaseController from \"../BaseController\";\nimport { BaseBlockTrackerConfig, BaseBlockTrackerState } from \"./IBlockTrackerController\";\n\nconst sec = 1000;\n\nconst calculateSum = (accumulator: number, currentValue: number) => accumulator + currentValue;\nconst blockTrackerEvents: string[] = [\"sync\", \"latest\"];\n\nexport class BaseBlockTracker<\n  T extends { idempotencyKey: string },\n  C extends BaseBlockTrackerConfig,\n  S extends BaseBlockTrackerState<T>\n> extends BaseController<C, S> {\n  name = \"BaseBlockTracker\";\n\n  private _blockResetTimeout?: ReturnType<typeof setTimeout>;\n\n  constructor({ config = {}, state = {} }: { config: Partial<C>; state: Partial<S> }) {\n    super({ config, state });\n\n    // config\n\n    this.defaultState = {\n      _currentBlock: { idempotencyKey: \"\" },\n      _isRunning: false,\n    } as S;\n\n    this.defaultConfig = {\n      blockResetDuration: 20 * sec,\n    } as C;\n\n    this.initialize();\n\n    // bind functions for internal use\n    this._onNewListener = this._onNewListener.bind(this);\n    this._onRemoveListener = this._onRemoveListener.bind(this);\n    this._resetCurrentBlock = this._resetCurrentBlock.bind(this);\n\n    // listen for handler changes\n    this._setupInternalEvents();\n  }\n\n  isRunning(): boolean {\n    return this.state._isRunning;\n  }\n\n  getCurrentBlock(): T {\n    return this.state._currentBlock;\n  }\n\n  async getLatestBlock(): Promise<T> {\n    // return if available\n    if (this.state._currentBlock) {\n      return this.state._currentBlock;\n    }\n    // wait for a new latest block\n    const latestBlock = await new Promise((resolve: (state: T) => void) =>\n      this.once(\"latest\", (newState: BaseBlockTrackerState<T>) => {\n        if (newState._currentBlock) {\n          resolve(newState._currentBlock);\n        }\n      })\n    );\n    // return newly set current block\n    return latestBlock;\n  }\n\n  // dont allow module consumer to remove our internal event listeners\n  removeAllListeners(eventName?: string): this {\n    if (eventName) {\n      super.removeAllListeners(eventName);\n    } else {\n      super.removeAllListeners();\n    }\n    // re-add internal events\n    this._setupInternalEvents();\n    // trigger stop check just in case\n    this._onRemoveListener();\n    return this;\n  }\n\n  /**\n   * To be implemented in subclass.\n   */\n  protected _start(): void {\n    // default behavior is noop\n  }\n\n  /**\n   * To be implemented in subclass.\n   */\n  protected _end(): void {\n    // default behavior is noop\n  }\n\n  protected _newPotentialLatest(newBlock: T): void {\n    const currentBlock = this.state._currentBlock;\n    // only update if blok number is higher\n    if (currentBlock && newBlock.idempotencyKey === currentBlock.idempotencyKey) {\n      return;\n    }\n    this._setCurrentBlock(newBlock);\n  }\n\n  private _setupInternalEvents(): void {\n    // first remove listeners for idempotency\n    this.removeListener(\"newListener\", this._onNewListener);\n    this.removeListener(\"removeListener\", this._onRemoveListener);\n    // then add them\n    this.on(\"removeListener\", this._onRemoveListener);\n    this.on(\"newListener\", this._onNewListener);\n  }\n\n  private _onNewListener(): void {\n    this._maybeStart();\n  }\n\n  private _onRemoveListener(): void {\n    // `removeListener` is called *after* the listener is removed\n    if (this._getBlockTrackerEventCount() > 0) {\n      return;\n    }\n    this._maybeEnd();\n  }\n\n  private _maybeStart(): void {\n    if (this.state._isRunning) {\n      return;\n    }\n    this.state._isRunning = true;\n    // cancel setting latest block to stale\n    this._cancelBlockResetTimeout();\n    this._start();\n  }\n\n  private _maybeEnd(): void {\n    if (!this.state._isRunning) {\n      return;\n    }\n    this.state._isRunning = false;\n    this._setupBlockResetTimeout();\n    this._end();\n  }\n\n  private _getBlockTrackerEventCount(): number {\n    return blockTrackerEvents.map((eventName) => this.listenerCount(eventName)).reduce(calculateSum);\n  }\n\n  private _setCurrentBlock(newBlock: T): void {\n    const oldBlock = this.state._currentBlock;\n    this.update({\n      _currentBlock: newBlock,\n    } as S);\n    this.emit(\"latest\", newBlock);\n    this.emit(\"sync\", { oldBlock, newBlock });\n  }\n\n  private _setupBlockResetTimeout(): void {\n    // clear any existing timeout\n    this._cancelBlockResetTimeout();\n    // clear latest block when stale\n    this._blockResetTimeout = setTimeout(this._resetCurrentBlock, this.config.blockResetDuration);\n\n    // nodejs - dont hold process open\n    if (this._blockResetTimeout.unref) {\n      this._blockResetTimeout.unref();\n    }\n  }\n\n  private _cancelBlockResetTimeout(): void {\n    if (this._blockResetTimeout) {\n      clearTimeout(this._blockResetTimeout);\n    }\n  }\n\n  private _resetCurrentBlock(): void {\n    this.update({ _currentBlock: { idempotencyKey: \"\" } } as Partial<S>);\n  }\n}\n","import { SafeEventEmitter } from \"@toruslabs/openlogin-jrpc\";\nconst filterNoop = () => true;\nconst internalEvents = [\"newListener\", \"removeListener\"];\nconst externalEventFilter = (name: string) => !internalEvents.includes(name);\n\ninterface EventEmitterProxyOpts {\n  eventFilter?: ((name: string) => boolean) | string;\n}\n\nfunction getRawListeners<T extends SafeEventEmitter>(eventEmitter: T, name: string) {\n  // prefer native\n  return eventEmitter.rawListeners(name);\n}\n\nexport default function createEventEmitterProxy<T extends SafeEventEmitter>(initialTarget: T, opts?: EventEmitterProxyOpts): T {\n  // parse options\n  const finalOpts = opts || {};\n  let eventFilter = finalOpts.eventFilter || filterNoop;\n  if (typeof eventFilter === \"string\" && eventFilter === \"skipInternal\") eventFilter = externalEventFilter;\n  if (typeof eventFilter !== \"function\") throw new Error(\"createEventEmitterProxy - Invalid eventFilter\");\n\n  let target = initialTarget;\n\n  let setTarget = (newTarget: T) => {\n    const oldTarget = target;\n    target = newTarget;\n\n    oldTarget\n      .eventNames()\n      .filter(eventFilter as (name: string) => boolean)\n      .forEach((name: string) => {\n        getRawListeners(oldTarget, name).forEach((handler: (...args: any[]) => void) => newTarget.on(name, handler));\n      });\n\n    // remove old listeners\n    oldTarget.removeAllListeners();\n  };\n\n  const proxy = new Proxy<T>({} as T, {\n    get: (_, name) => {\n      // override `setTarget` access\n      if (name === \"setTarget\") return setTarget;\n      return target[name];\n    },\n    set: (_, name, value) => {\n      // allow `setTarget` overrides\n      if (name === \"setTarget\") {\n        setTarget = value;\n        return true;\n      }\n      target[name] = value;\n      return true;\n    },\n  });\n\n  return proxy;\n}\n","export default function createSwappableProxy<T extends object>(initialTarget: T): T {\n  let target = initialTarget;\n\n  let setTarget = (newTarget: T) => {\n    target = newTarget;\n  };\n\n  const proxy = new Proxy<T>({} as T, {\n    get: (_, name) => {\n      // override `setTarget` access\n      if (name === \"setTarget\") return setTarget;\n      return target[name];\n    },\n    set: (_, name, value) => {\n      // allow `setTarget` overrides\n      if (name === \"setTarget\") {\n        setTarget = value;\n        return true;\n      }\n      target[name] = value;\n      return true;\n    },\n  });\n\n  return proxy;\n}\n","import BaseController from \"../BaseController\";\nimport { BaseCurrencyControllerConfig, BaseCurrencyControllerState } from \"./ICurrencyController\";\n\n// every ten minutes\nconst POLLING_INTERVAL = 600_000;\n\nexport class BaseCurrencyController<C extends BaseCurrencyControllerConfig, S extends BaseCurrencyControllerState> extends BaseController<C, S> {\n  constructor({ config = {}, state }: { config: Partial<C>; state?: Partial<S> }) {\n    super({ config, state });\n    this.defaultState = {\n      currentCurrency: \"usd\",\n      conversionRate: 0,\n      conversionDate: \"N/A\",\n      nativeCurrency: \"ETH\",\n    } as S;\n\n    this.defaultConfig = {\n      pollInterval: POLLING_INTERVAL,\n    } as C;\n    this.initialize();\n  }\n\n  //\n  // PUBLIC METHODS\n  //\n\n  public getNativeCurrency(): string {\n    return this.state.nativeCurrency;\n  }\n\n  public setNativeCurrency(nativeCurrency: string): void {\n    this.update({\n      nativeCurrency,\n      ticker: nativeCurrency,\n    } as S);\n  }\n\n  public getCurrentCurrency(): string {\n    return this.state.currentCurrency;\n  }\n\n  public setCurrentCurrency(currentCurrency: string): void {\n    this.update({ currentCurrency } as S);\n  }\n\n  /**\n   * A getter for the conversionRate property\n   *\n   * @returns The conversion rate from ETH to the selected currency.\n   *\n   */\n  public getConversionRate(): number {\n    return this.state.conversionRate;\n  }\n\n  public setConversionRate(conversionRate: number): void {\n    this.update({ conversionRate } as S);\n  }\n\n  /**\n   * A getter for the conversionDate property\n   *\n   * @returns The date at which the conversion rate was set. Expressed in milliseconds since midnight of\n   * January 1, 1970\n   *\n   */\n  public getConversionDate(): string {\n    return this.state.conversionDate;\n  }\n\n  public setConversionDate(conversionDate: string): void {\n    this.update({ conversionDate } as S);\n  }\n}\n","import { JRPCEngine, JRPCMiddleware, JRPCRequest, JRPCResponse, SafeEventEmitter } from \"@toruslabs/openlogin-jrpc\";\nimport { ethErrors, serializeError } from \"eth-rpc-errors\";\nimport getCreateRandomId from \"json-rpc-random-id\";\n\nimport { BaseConfig, BaseState, IController } from \"../interfaces\";\nexport const createRandomId = getCreateRandomId();\n\nexport interface ProviderConfig {\n  /**\n   * Block explorer url for the chain\n   * @example https://ropsten.etherscan.io\n   */\n  blockExplorerUrl: string;\n  /**\n   * Logo url for the base token\n   */\n  logo: string;\n  /**\n   * Name for ticker\n   * @example 'Binance Token', 'Ethereum', 'Matic Network Token'\n   */\n  tickerName: string;\n  /**\n   * Symbol for ticker\n   * @example BNB, ETH\n   */\n  ticker: string;\n  /**\n   * RPC target Url for the chain\n   * @example https://ropsten.infura.io/v3/YOUR_API_KEY\n   */\n  rpcTarget: string;\n  /**\n   * Chain Id parameter(hex with 0x prefix) for the network. Mandatory for all networks. (assign one with a map to network identifier for platforms)\n   * @example 0x1 for mainnet, 'loading' if not connected to anything yet or connection fails\n   * @defaultValue 'loading'\n   */\n  chainId: string;\n  /**\n   * Display name for the network\n   */\n  displayName: string;\n}\n\n/**\n * Custom network properties\n * @example isEIP1559Compatible: true etc.\n */\nexport interface NetworkProperties {\n  [key: string]: number | string | boolean;\n}\n\n/**\n *\n */\nexport interface NetworkState extends BaseState {\n  /**\n   * Chain Id for the current network\n   */\n  chainId: string;\n  providerConfig: ProviderConfig;\n  properties: NetworkProperties;\n}\n\nexport interface NetworkConfig extends BaseConfig {\n  providerConfig: ProviderConfig;\n}\n\nexport interface INetworkController<C, S> extends IController<C, S> {\n  /**\n   * Gets the chainId of the network\n   */\n  getNetworkIdentifier(): string;\n\n  /**\n   * Sets provider for the current network controller\n   * @param providerConfig - Provider config object\n   */\n  setProviderConfig(providerConfig: ProviderConfig): void;\n  /**\n   * Connects to the rpcUrl for the current selected provider\n   */\n  lookupNetwork(): Promise<void>;\n}\n\nexport type BlockData = string | string[];\n\nexport type Block = Record<string, BlockData>;\n\nexport type SendAsyncCallBack = (err: Error, providerRes: JRPCResponse<Block>) => void;\n\nexport type SendCallBack<U> = (err: any, providerRes: U) => void;\n\nexport type Payload = Partial<JRPCRequest<string[]>>;\n\nexport interface RequestArguments<T> {\n  method: string;\n  params?: T;\n}\nexport type Maybe<T> = T | Partial<T> | null | undefined;\n\nexport interface SafeEventEmitterProvider extends SafeEventEmitter {\n  sendAsync: <T, U>(req: JRPCRequest<T>) => Promise<U>;\n  send: <T, U>(req: JRPCRequest<T>, callback: SendCallBack<U>) => void;\n  request: <T, U>(args: RequestArguments<T>) => Promise<Maybe<U>>;\n}\n\nexport interface ExtendedJsonRpcRequest<T> extends JRPCRequest<T> {\n  skipCache?: boolean;\n}\n\nexport function providerFromEngine(engine: JRPCEngine): SafeEventEmitterProvider {\n  const provider: SafeEventEmitterProvider = new SafeEventEmitter() as SafeEventEmitterProvider;\n  // handle both rpc send methods\n  provider.sendAsync = async <T, U>(req: JRPCRequest<T>) => {\n    const res = await engine.handle(req);\n    if (res.error) {\n      const err = serializeError(res.error, {\n        fallbackError: {\n          message: res.error?.message || res.error.toString(),\n          code: res.error?.code || -32603,\n        },\n      });\n\n      throw ethErrors.rpc.internal(err);\n    }\n    return res.result as U;\n  };\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  provider.send = <T, U>(req: JRPCRequest<T>, callback: (error: any, providerRes: U) => void) => {\n    if (typeof callback !== \"function\") {\n      throw new Error('Must provide callback to \"send\" method.');\n    }\n    engine.handle(req, callback);\n  };\n  // forward notifications\n  if (engine.on) {\n    engine.on(\"notification\", (message: string) => {\n      provider.emit(\"data\", null, message);\n    });\n  }\n\n  provider.request = async <T, U>(args: RequestArguments<T>) => {\n    const req: JRPCRequest<T> = {\n      ...args,\n      id: createRandomId(),\n      jsonrpc: \"2.0\",\n    };\n    const res = await provider.sendAsync(req);\n    return res as U;\n  };\n  return provider;\n}\n\nexport function providerFromMiddleware(middleware: JRPCMiddleware<string[], unknown>): SafeEventEmitterProvider {\n  const engine = new JRPCEngine();\n  engine.push(middleware);\n  const provider: SafeEventEmitterProvider = providerFromEngine(engine);\n  return provider;\n}\n\nexport function providerAsMiddleware(provider: SafeEventEmitterProvider): JRPCMiddleware<unknown, unknown> {\n  return async (req, res, _next, end) => {\n    // send request to provider\n    try {\n      const providerRes: unknown = await provider.sendAsync<unknown, unknown>(req);\n      res.result = providerRes;\n      return end();\n    } catch (error) {\n      return end(error.message);\n    }\n  };\n}\n","export const FEATURES_PROVIDER_CHANGE_WINDOW = { height: 660, width: 375 };\nexport const FEATURES_DEFAULT_WALLET_WINDOW = { height: 740, width: 1315 };\nexport const FEATURES_DEFAULT_POPUP_WINDOW = { height: 700, width: 1200 };\nexport const FEATURES_CONFIRM_WINDOW = { height: 700, width: 450 };\n\nexport const POPUP_LOADED = \"popup_loaded\";\nexport const POPUP_RESULT = \"popup_result\";\n\nexport const SETUP_COMPLETE = \"setup_complete\";\n\nexport const ACTIVITY_ACTION_ALL = \"walletActivity.allTransactions\";\nexport const ACTIVITY_ACTION_SEND = \"walletActivity.send\";\nexport const ACTIVITY_ACTION_BURN = \"walletActivity.burn\";\nexport const ACTIVITY_ACTION_RECEIVE = \"walletActivity.receive\";\nexport const ACTIVITY_ACTION_TOPUP = \"walletActivity.topup\";\n\nexport const ACTIVITY_PERIOD_ALL = \"walletActivity.all\";\nexport const ACTIVITY_PERIOD_WEEK_ONE = \"walletActivity.lastOneWeek\";\nexport const ACTIVITY_PERIOD_MONTH_ONE = \"walletActivity.lastOneMonth\";\nexport const ACTIVITY_PERIOD_MONTH_SIX = \"walletActivity.lastSixMonts\";\n\nexport const ACTIVITY_STATUS_SUCCESSFUL = \"walletActivity.successful\";\nexport const ACTIVITY_STATUS_UNSUCCESSFUL = \"walletActivity.unsuccessful\";\nexport const ACTIVITY_STATUS_PENDING = \"walletActivity.pending\";\nexport const ACTIVITY_STATUS_CANCELLED = \"walletActivity.cancelled\";\nexport const ACTIVITY_STATUS_CANCELLING = \"walletActivity.cancelling\";\n\nexport const COMMUNICATION_NOTIFICATIONS = {\n  IFRAME_STATUS: \"iframe_status\",\n\n  // Tell embed to create the window\n  CREATE_WINDOW: \"create_window\",\n  // Tell embed to close the window\n  CLOSE_WINDOW: \"close_window\",\n\n  USER_LOGGED_IN: \"user_logged_in\",\n  USER_LOGGED_OUT: \"user_logged_out\",\n};\n\nexport const COMMUNICATION_JRPC_METHODS = {\n  LOGOUT: \"logout\",\n  WALLET_INSTANCE_ID: \"wallet_instance_id\",\n  USER_INFO: \"user_info\",\n  SET_PROVIDER: \"set_provider\",\n  TOPUP: \"topup\",\n  IFRAME_STATUS: \"iframe_status\",\n  // embed has opened the window as requested\n  OPENED_WINDOW: \"opened_window\",\n  // user has closed the window from embed's side\n  CLOSED_WINDOW: \"closed_window\",\n  GET_PROVIDER_STATE: \"get_provider_state\",\n  LOGIN_WITH_PRIVATE_KEY: \"login_with_private_key\",\n};\n\nexport const PROVIDER_JRPC_METHODS = {\n  GET_PROVIDER_STATE: \"wallet_get_provider_state\",\n};\n\nexport const PROVIDER_NOTIFICATIONS = {\n  ACCOUNTS_CHANGED: \"wallet_accounts_changed\",\n  CHAIN_CHANGED: \"wallet_chain_changed\",\n  UNLOCK_STATE_CHANGED: \"wallet_unlock_state_changed\",\n};\n\nexport const BROADCAST_CHANNELS = {\n  REDIRECT_CHANNEL: \"redirect_channel\",\n  PROVIDER_CHANGE_CHANNEL: \"torus_provider_change_channel\",\n  TRANSACTION_CHANNEL: \"torus_channel\",\n  MESSAGE_CHANNEL: \"torus_message_channel\",\n  WALLET_LOGOUT_CHANNEL: \"wallet_logout_channel\",\n  WALLET_SELECTED_ADDRESS_CHANNEL: \"wallet_selected_address_channel\",\n  WALLET_NETWORK_CHANGE_CHANNEL: \"wallet_network_change_channel\",\n  WALLET_ACCOUNT_IMPORT_CHANNEL: \"wallet_account_import_channel\",\n  THEME_CHANGE: \"theme_change_channel\",\n};\nexport const BROADCAST_CHANNELS_MSGS = {\n  LOGOUT: \"logout\",\n  ACCOUNT_IMPORTED: \"account_imported\",\n  SELECTED_ADDRESS_CHANGE: \"selected_address_change\",\n  NETWORK_CHANGE: \"network_change\",\n  SET_THEME: \"set_theme\",\n};\n\nexport type BROADCAST_CHANNELS_MSGS_TYPE = typeof BROADCAST_CHANNELS_MSGS[keyof typeof BROADCAST_CHANNELS_MSGS];\n","import { createAsyncMiddleware, createScaffoldMiddleware, JRPCMiddleware, mergeMiddleware } from \"@toruslabs/openlogin-jrpc\";\n\nimport { COMMUNICATION_JRPC_METHODS } from \"../enums\";\nimport type { ProviderConfig } from \"../Network/INetworkController\";\nimport { ICommunicationProviderHandlers, Ihandler, TopupInput } from \"./IEmbedController\";\n\nexport function createChangeProviderMiddlewareMiddleware({\n  changeProvider,\n}: {\n  changeProvider: ICommunicationProviderHandlers[\"changeProvider\"];\n}): JRPCMiddleware<unknown, unknown> {\n  return createAsyncMiddleware<ProviderConfig & { windowId: string }, boolean>(async (request, response, next) => {\n    const { method } = request;\n    if (method !== COMMUNICATION_JRPC_METHODS.SET_PROVIDER) return next();\n\n    if (!changeProvider) throw new Error(\"CommunicationMiddleware - opts.changeProvider not provided\");\n    response.result = await changeProvider(request);\n  });\n}\n\nexport function createTopupMiddleware({ topup }: { topup: ICommunicationProviderHandlers[\"topup\"] }): JRPCMiddleware<unknown, unknown> {\n  return createAsyncMiddleware<TopupInput, boolean>(async (request, response, next) => {\n    const { method } = request;\n    if (method !== COMMUNICATION_JRPC_METHODS.TOPUP) return next();\n\n    if (!topup) throw new Error(\"CommunicationMiddleware - opts.topup not provided\");\n    response.result = await topup(request);\n  });\n}\n\nexport function createGenericJRPCMiddleware<T>(\n  targetMethod: string,\n  handler: (req: Ihandler<T>) => Promise<unknown>\n): JRPCMiddleware<unknown, unknown> {\n  return createAsyncMiddleware<T, unknown>(async (request, response, next) => {\n    const { method } = request;\n    if (method !== targetMethod) return next();\n\n    if (!handler) throw new Error(`CommunicationMiddleware - ${targetMethod} not provided`);\n\n    const result = await handler(request);\n    if (!result) {\n      return next();\n    }\n    response.result = result;\n    return undefined;\n  });\n}\n\nexport function createCommunicationMiddleware(providerHandlers: ICommunicationProviderHandlers): JRPCMiddleware<unknown, unknown> {\n  const { getUserInfo, getWalletInstanceId, topup, logout, changeProvider, setIFrameStatus, handleWindowRpc, getProviderState, loginWithPrivateKey } =\n    providerHandlers;\n  return mergeMiddleware([\n    createChangeProviderMiddlewareMiddleware({ changeProvider }),\n    createTopupMiddleware({ topup }),\n    createScaffoldMiddleware({\n      [COMMUNICATION_JRPC_METHODS.LOGOUT]: logout,\n      [COMMUNICATION_JRPC_METHODS.WALLET_INSTANCE_ID]: getWalletInstanceId,\n      [COMMUNICATION_JRPC_METHODS.USER_INFO]: getUserInfo,\n      [COMMUNICATION_JRPC_METHODS.IFRAME_STATUS]: setIFrameStatus,\n      // Do this in the orchestrator because communicationWindowManager needs to be passed into PopupHandlers\n      [COMMUNICATION_JRPC_METHODS.OPENED_WINDOW]: handleWindowRpc,\n      [COMMUNICATION_JRPC_METHODS.CLOSED_WINDOW]: handleWindowRpc,\n      [COMMUNICATION_JRPC_METHODS.GET_PROVIDER_STATE]: getProviderState,\n    }),\n    createGenericJRPCMiddleware(COMMUNICATION_JRPC_METHODS.LOGIN_WITH_PRIVATE_KEY, loginWithPrivateKey),\n  ]);\n}\n","import { JRPCEngine } from \"@toruslabs/openlogin-jrpc\";\n\nimport BaseController from \"../BaseController\";\nimport createSwappableProxy from \"../createSwappableProxy\";\nimport type { BaseConfig } from \"../interfaces\";\nimport { providerFromEngine, SafeEventEmitterProvider } from \"../Network/INetworkController\";\nimport { createCommunicationMiddleware } from \"./CommunicationMethodMiddleware\";\nimport { BaseEmbedControllerState, ICommunicationProviderHandlers } from \"./IEmbedController\";\n\nexport class BaseEmbedController<C extends BaseConfig, S extends BaseEmbedControllerState> extends BaseController<C, S> {\n  public _communicationProviderProxy: SafeEventEmitterProvider;\n\n  constructor({ config = {}, state }: { config: Partial<C>; state?: Partial<S> }) {\n    super({ config, state });\n    this.defaultState = {\n      buttonPosition: \"bottom-right\",\n      isIFrameFullScreen: true,\n      apiKey: \"torus-default\",\n      oauthModalVisibility: false,\n      loginInProgress: false,\n      dappMetadata: {\n        name: \"\",\n        icon: \"\",\n      },\n    } as S;\n    this.initialize();\n  }\n\n  /**\n   * Called by orchestrator once while initializing the class\n   * @param handlers - JRPC handlers for provider\n   * @returns - provider - Returns the providerProxy\n   */\n  public initializeProvider(handlers: ICommunicationProviderHandlers): void {\n    const engine = new JRPCEngine();\n    const communicationMiddleware = createCommunicationMiddleware(handlers);\n    engine.push(communicationMiddleware);\n    const communicationProvider = providerFromEngine(engine);\n    this.setCommunicationProvider(communicationProvider);\n  }\n\n  private setCommunicationProvider(communicationProvider: SafeEventEmitterProvider): void {\n    if (this._communicationProviderProxy) {\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      this._communicationProviderProxy.setTarget(communicationProvider);\n    } else {\n      this._communicationProviderProxy = createSwappableProxy<SafeEventEmitterProvider>(communicationProvider);\n    }\n  }\n}\n","import { JRPCEngineEndCallback, JRPCEngineNextCallback, JRPCRequest, JRPCResponse, SafeEventEmitter } from \"@toruslabs/openlogin-jrpc\";\n\nimport { COMMUNICATION_JRPC_METHODS } from \"../enums\";\n\nclass CommunicationWindowManager extends SafeEventEmitter {\n  handleWindowRpc = (\n    request: JRPCRequest<{ windowId: string }>,\n    response: JRPCResponse<boolean>,\n    next: JRPCEngineNextCallback,\n    end: JRPCEngineEndCallback\n  ): void => {\n    const { method, params } = request;\n    if (method === COMMUNICATION_JRPC_METHODS.OPENED_WINDOW) {\n      const { windowId } = params;\n      // I've been informed that a window has been opened\n      this.emit(`${windowId}:opened`);\n      response.result = true;\n      end();\n    } else if (method === COMMUNICATION_JRPC_METHODS.CLOSED_WINDOW) {\n      const { windowId } = params;\n      // I've been informed that a window has been closed\n      this.emit(`${windowId}:closed`);\n      response.result = true;\n      end();\n    } else {\n      next();\n    }\n  };\n}\n\nexport default CommunicationWindowManager;\n","import type { EventEmitter } from \"events\";\n\nimport { THEME } from \"./Preferences/IPreferencesController\";\n\n/**\n * State change callbacks\n */\nexport type Listener<T> = (state: T) => void;\n\n/**\n * Base controller configuration\n */\nexport interface BaseConfig {\n  /**\n   *  Determines if this controller is enabled\n   */\n  disabled?: boolean;\n}\n\n/**\n * Base state representation\n */\nexport interface BaseState {\n  /**\n   * Unique name for this controller\n   */\n  name?: string;\n}\n\nexport interface IController<C, S> {\n  defaultConfig: C;\n\n  defaultState: S;\n\n  name: string;\n\n  get state(): S;\n\n  get config(): C;\n\n  update(state: Partial<S>, overwrite?: boolean): void;\n\n  configure(config: Partial<C>, overwrite?: boolean, fullUpdate?: boolean): void;\n}\n\nexport type generic<T> = () => T;\n\nexport type EmailObject = {\n  link: string;\n  from_name: string;\n  to_email: string;\n  total_amount: string;\n  token: string;\n  currency: string;\n  currency_amount: number;\n};\n\nexport interface IWindow {\n  closed: boolean;\n  open(): IWindow | Promise<IWindow>;\n  close(): void;\n}\n\nexport interface IStreamWindow extends IWindow, EventEmitter {}\n\nexport const LOGIN_PROVIDER = {\n  GOOGLE: \"google\",\n  FACEBOOK: \"facebook\",\n  REDDIT: \"reddit\",\n  DISCORD: \"discord\",\n  TWITCH: \"twitch\",\n  APPLE: \"apple\",\n  LINE: \"line\",\n  GITHUB: \"github\",\n  KAKAO: \"kakao\",\n  LINKEDIN: \"linkedin\",\n  TWITTER: \"twitter\",\n  WEIBO: \"weibo\",\n  WECHAT: \"wechat\",\n  EMAIL_PASSWORDLESS: \"email_passwordless\",\n};\n/**\n * {@label loginProviderType}\n */\nexport type LOGIN_PROVIDER_TYPE = typeof LOGIN_PROVIDER[keyof typeof LOGIN_PROVIDER];\n\nexport interface UserInfo {\n  /**\n   * Email of the logged in user\n   */\n  email: string;\n  /**\n   * Full name of the logged in user\n   */\n  name: string;\n  /**\n   * Profile image of the logged in user\n   */\n  profileImage: string;\n  /**\n   * aggregate verifier of the logged in user (google, facebook etc)\n   */\n  aggregateVerifier?: string;\n  /**\n   * verifier of the logged in user (google, facebook etc)\n   */\n  verifier: string;\n  /**\n   * Verifier Id of the logged in user\n   *\n   * email for google,\n   * id for facebook,\n   * username for reddit,\n   * id for twitch,\n   * id for discord\n   */\n  verifierId: string;\n\n  typeOfLogin: LOGIN_PROVIDER_TYPE;\n\n  dappShare?: string;\n  /**\n   * Token issued by Web3Auth.\n   */\n  idToken?: string;\n  /**\n   * Token issued by OAuth provider. Will be available only if you are using\n   * custom verifiers.\n   */\n  oAuthIdToken?: string;\n  /**\n   * Access Token issued by OAuth provider. Will be available only if you are using\n   * custom verifiers.\n   */\n  oAuthAccessToken?: string;\n}\n\nexport interface PaymentParams {\n  /**\n   * Address to send the funds to\n   */\n  selectedAddress?: string;\n  /**\n   * Default fiat currency for the user to make the payment in\n   */\n  selectedCurrency?: string;\n  /**\n   * Amount to buy in the selectedCurrency\n   */\n  fiatValue?: number;\n  /**\n   * Cryptocurrency to buy\n   */\n  selectedCryptoCurrency?: string;\n  /**\n   * Amount Cryptocurrency to buy\n   */\n  cryptoAmount?: number;\n}\n\nexport const PAYMENT_PROVIDER = {\n  MOONPAY: \"moonpay\",\n  WYRE: \"wyre\",\n  RAMPNETWORK: \"rampnetwork\",\n  XANPOOL: \"xanpool\",\n  MERCURYO: \"mercuryo\",\n  TRANSAK: \"transak\",\n} as const;\n\nexport type PAYMENT_PROVIDER_TYPE = typeof PAYMENT_PROVIDER[keyof typeof PAYMENT_PROVIDER];\n\nexport type InPageWalletProviderState = {\n  accounts: string[];\n  chainId: string;\n  isUnlocked: boolean;\n};\n\nexport type CommunicationWalletProviderState = {\n  isLoggedIn: boolean;\n  currentLoginProvider: LOGIN_PROVIDER_TYPE;\n};\n\nexport interface PopupWhitelabelData {\n  theme: THEME;\n}\n","import { ACTIVITY_STATUS_CANCELLED, ACTIVITY_STATUS_PENDING, ACTIVITY_STATUS_SUCCESSFUL, ACTIVITY_STATUS_UNSUCCESSFUL } from \"../enums\";\nimport { TransactionStatus } from \"../Transaction/ITransactionController\";\n\nexport const getTxStatusText = (txStatus: TransactionStatus): string => {\n  switch (txStatus) {\n    case \"rejected\":\n    case \"unapproved\":\n    case \"failed\":\n      return ACTIVITY_STATUS_UNSUCCESSFUL;\n    case \"confirmed\":\n      return ACTIVITY_STATUS_SUCCESSFUL;\n    case \"submitted\":\n      return ACTIVITY_STATUS_PENDING;\n    case \"cancelled\":\n      return ACTIVITY_STATUS_CANCELLED;\n    default:\n      return \"\";\n  }\n};\n","import { BigNumber } from \"bignumber.js\";\nimport { addHexPrefix, bufferToInt, ecsign, fromSigned, hashPersonalMessage, intToBuffer, stripHexPrefix, toUnsigned } from \"ethereumjs-util\";\n\nimport { TransactionMeta } from \"../Transaction/ITransactionController\";\n\n/**\n * General utility functions\n */\n\nexport function intToHex(i: number): string {\n  const hex = i.toString(16);\n  return `0x${hex}`;\n}\n\n/**\n * Returns a random number. Don't use for cryptographic purposes.\n * @returns a random number\n */\nexport const randomId = (): string => Math.random().toString(36).slice(2);\n\n/**\n * Pads the front of the given hex string with zeroes until it reaches the\n * target length. If the input string is already longer than or equal to the\n * target length, it is returned unmodified.\n *\n * If the input string is \"0x\"-prefixed or not a hex string, an error will be\n * thrown.\n *\n * @param hexString - The hexadecimal string to pad with zeroes.\n * @param targetLength - The target length of the hexadecimal string.\n * @returns The input string front-padded with zeroes, or the original string\n * if it was already greater than or equal to to the target length.\n */\nexport function padWithZeroes(hexString: string, targetLength: number): string {\n  if (hexString !== \"\" && !/^[a-f0-9]+$/iu.test(hexString)) {\n    throw new Error(`Expected an unprefixed hex string. Received: ${hexString}`);\n  }\n\n  if (targetLength < 0) {\n    throw new Error(`Expected a non-negative integer target length. Received: ${targetLength}`);\n  }\n\n  return String.prototype.padStart.call(hexString, targetLength, \"0\");\n}\n/**\n * Concatenate an extended ECDSA signature into a hex string.\n *\n * @param v - The 'v' portion of the signature.\n * @param r - The 'r' portion of the signature.\n * @param s - The 's' portion of the signature.\n * @returns The concatenated ECDSA signature.\n */\nexport function concatSig(v: Buffer, r: Buffer, s: Buffer): string {\n  const rSig = fromSigned(r);\n  const sSig = fromSigned(s);\n  const vSig = bufferToInt(v);\n  const rStr = padWithZeroes(toUnsigned(rSig).toString(\"hex\"), 64);\n  const sStr = padWithZeroes(toUnsigned(sSig).toString(\"hex\"), 64);\n  const vStr = stripHexPrefix(intToHex(vSig));\n  return addHexPrefix(rStr.concat(sStr, vStr));\n}\n\nexport function timeout(duration: number): Promise<void> {\n  return new Promise((resolve) => {\n    const timeoutRef = window.setTimeout(() => {\n      resolve();\n      window.clearTimeout(timeoutRef);\n    }, duration);\n  });\n}\n\nexport const getHeaders = (jwt: string) => {\n  return {\n    headers: {\n      Authorization: `Bearer ${jwt}`,\n      \"Content-Type\": \"application/json; charset=utf-8\",\n    },\n  };\n};\n\n/**\n * Text/number formatting utilities\n */\nexport const formatSmallNumbers = (number: number, currency = \"usd\", noTilde = false): string => {\n  const finalNumber = BigNumber.isBigNumber(number) ? number.toNumber() : number;\n  if (!Number.isFinite(finalNumber)) return \"\";\n  const value = currency.toLowerCase() === \"usd\" ? parseFloat(Number(finalNumber).toFixed(2)) : parseFloat(Number(finalNumber).toFixed(5));\n  const tilde = value > 0 ? \"~ \" : \"\";\n  return `${currency.toLowerCase() === \"usd\" || noTilde ? \"\" : tilde}${Number(value)} ${currency.toUpperCase()}`;\n};\n\nexport const addressSlicer = (address: string, sliceLength = 5): string => {\n  if (address.length < 11) {\n    return address;\n  }\n  if (typeof address !== \"string\") return \"\";\n  return `${address.slice(0, sliceLength)}...${address.slice(-sliceLength)}`;\n};\n\nexport const significantDigits = (number: number | BigNumber, perc = false, length_ = 2): number | BigNumber => {\n  let input = !BigNumber.isBigNumber(number) ? new BigNumber(number) : number;\n  if (input.isZero()) return input;\n  if (perc) {\n    input = input.times(new BigNumber(100));\n  }\n  let depth;\n  if (input.gte(new BigNumber(1))) {\n    depth = length_;\n  } else {\n    depth = length_ - 1 + Math.ceil(Math.log10(new BigNumber(\"1\").div(input).toNumber()));\n  }\n  const shift = new BigNumber(10).pow(new BigNumber(depth));\n  const roundedNumber = Math.round(shift.times(input).toNumber()) / shift.toNumber();\n  return roundedNumber;\n};\nexport const formatDate = (inputDate: string): string => {\n  const monthList = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"];\n  const date = new Date(inputDate);\n  const day = date.getDate();\n  const month = monthList[date.getMonth()];\n  const year = date.getFullYear();\n  return `${day} ${month} ${year}`;\n};\n\nexport const formatTime = (time: string): string => {\n  return new Date(time).toTimeString().slice(0, 8);\n};\n\n/**\n * Network utilities\n */\nexport const transactionMatchesNetwork = <T>(transaction: TransactionMeta<T>, chainId: string): boolean => {\n  if (typeof transaction.chainId !== \"undefined\") {\n    return transaction.chainId === chainId;\n  }\n  return false;\n};\n\n/**\n * Signing utils\n */\nexport const hashMessage = (message: string): Buffer => {\n  const bufferedMessage = Buffer.from(message, \"utf8\");\n  const el = hashPersonalMessage(bufferedMessage);\n  return el;\n};\n\nexport const signMessage = (privateKey: string, data: string): string => {\n  const privKey = Buffer.from(privateKey, \"hex\");\n  const message = stripHexPrefix(data);\n  const msgSig = ecsign(Buffer.from(message, \"hex\"), privKey);\n  const rawMsgSig = concatSig(intToBuffer(msgSig.v), msgSig.r, msgSig.s);\n  return rawMsgSig;\n};\n\n/**\n * popup handler utils\n */\nexport function getPopupFeatures({ width: w, height: h }: { width: number; height: number }): string {\n  // Fixes dual-screen position                             Most browsers      Firefox\n  const dualScreenLeft = window.screenLeft !== undefined ? window.screenLeft : window.screenX;\n  const dualScreenTop = window.screenTop !== undefined ? window.screenTop : window.screenY;\n\n  const width = window.innerWidth\n    ? window.innerWidth\n    : document.documentElement.clientWidth\n    ? document.documentElement.clientWidth\n    : window.screen.width;\n\n  const height = window.innerHeight\n    ? window.innerHeight\n    : document.documentElement.clientHeight\n    ? document.documentElement.clientHeight\n    : window.screen.height;\n\n  const systemZoom = 1; // No reliable estimate\n\n  const left = Math.abs((width - w) / 2 / systemZoom + dualScreenLeft);\n  const top = Math.abs((height - h) / 2 / systemZoom + dualScreenTop);\n  const features = `titlebar=0,toolbar=0,status=0,location=0,menubar=0,height=${h / systemZoom},width=${w / systemZoom},top=${top},left=${left}`;\n  return features;\n}\n\nexport const broadcastChannelOptions = {\n  // type: 'localstorage', // (optional) enforce a type, oneOf['native', 'idb', 'localstorage', 'node']\n  webWorkerSupport: false, // (optional) set this to false if you know that your channel will never be used in a WebWorker (increases performance)\n};\n\nexport function getCustomDeviceInfo(): Record<string, string> | undefined {\n  if ((navigator as any)?.brave) {\n    return {\n      browser: \"Brave\",\n    };\n  }\n}\nexport class UserError extends Error {}\n\nexport const handleRedirectParameters = (\n  hash: string,\n  queryParameters: Record<string, string>\n): { error: string; instanceParameters: Record<string, string>; hashParameters: Record<string, string> } => {\n  const hashParameters: Record<string, string> = {};\n  const hashUrl = new URL(`${window.location.origin}/?${hash.slice(1)}`);\n  hashUrl.searchParams.forEach((value, key) => {\n    hashParameters[key] = value;\n  });\n  let instanceParameters = {};\n  let error = \"\";\n  if (!queryParameters.windowId) {\n    if (Object.keys(hashParameters).length > 0 && hashParameters.state) {\n      instanceParameters = JSON.parse(window.atob(decodeURIComponent(decodeURIComponent(hashParameters.state)))) || {};\n      error = hashParameters.error_description || hashParameters.error || error;\n    } else if (Object.keys(queryParameters).length > 0 && queryParameters.state) {\n      instanceParameters = JSON.parse(window.atob(decodeURIComponent(decodeURIComponent(queryParameters.state)))) || {};\n      if (queryParameters.error) error = queryParameters.error;\n    }\n  }\n  return { error, instanceParameters, hashParameters };\n};\n\nexport function sleep<T>(ms: number): Promise<T> {\n  return new Promise<T>((resolve) => setTimeout(resolve, ms));\n}\n","import BaseController from \"../BaseController\";\nimport { BaseConfig } from \"../interfaces\";\nimport { hashMessage, signMessage } from \"../utils\";\nimport { KeyringControllerState } from \"./IKeyringController\";\nexport class BaseKeyringController<C extends BaseConfig, S extends KeyringControllerState> extends BaseController<C, S> {\n  constructor({ config = {}, state }: { config: Partial<C>; state?: Partial<S> }) {\n    super({ config, state });\n    this.defaultState = {\n      wallets: state.wallets ?? [],\n    } as S;\n    this.initialize();\n  }\n\n  // for signing auth message\n  signAuthMessage(address: string, message: string): string {\n    const keyring = this.state.wallets.find((x) => x.address === address);\n    if (!keyring) {\n      throw new Error(\"key does not exist\");\n    }\n    const hashedMessage = hashMessage(message).toString(\"hex\");\n    const rawMessageSig = signMessage(keyring.privateKey, hashedMessage);\n    return rawMessageSig;\n  }\n}\n","import { createAsyncMiddleware, JRPCEngineNextCallback, JRPCMiddleware, JRPCRequest, JRPCResponse } from \"@toruslabs/openlogin-jrpc\";\nimport { ethErrors } from \"eth-rpc-errors\";\n\nimport { Block, Payload } from \"./INetworkController\";\n\nexport interface FetchMiddlewareOptions {\n  rpcTarget: string;\n  originHttpHeaderKey?: string;\n}\n\nexport interface PayloadwithOrgin extends Payload {\n  origin?: string;\n}\nexport interface FetchMiddlewareFromReqOptions extends FetchMiddlewareOptions {\n  req: PayloadwithOrgin;\n}\n\nexport interface FetchConfig {\n  fetchUrl: string;\n  fetchParams: Record<string, unknown>;\n}\n\nconst RETRIABLE_ERRORS: string[] = [\n  // ignore server overload errors\n  \"Gateway timeout\",\n  \"ETIMEDOUT\",\n  // ignore server sent html error pages\n  // or truncated json responses\n  \"failed to parse response body\",\n  // ignore errors where http req failed to establish\n  \"Failed to fetch\",\n];\n\nfunction checkForHttpErrors(fetchRes: Response): void {\n  // check for errors\n  switch (fetchRes.status) {\n    case 405:\n      throw ethErrors.rpc.methodNotFound();\n\n    case 418:\n      throw ethErrors.rpc.internal({ message: `Request is being rate limited.` });\n\n    case 503:\n    case 504:\n      throw ethErrors.rpc.internal({\n        message: `Gateway timeout. The request took too long to process.` + `This can happen when querying over too wide a block range.`,\n      });\n\n    default:\n      break;\n  }\n}\n\nfunction timeout(duration: number): Promise<number> {\n  return new Promise((resolve) => setTimeout(resolve, duration));\n}\n\nfunction parseResponse(fetchRes: Response, body: Record<string, Block>): Block {\n  // check for error code\n  if (fetchRes.status !== 200) {\n    throw ethErrors.rpc.internal({\n      message: `Non-200 status code: '${fetchRes.status}'`,\n      data: body,\n    });\n  }\n  // check for rpc error\n  if (body.error) {\n    throw ethErrors.rpc.internal({\n      data: body.error,\n    });\n  }\n  // return successful result\n  return body.result;\n}\n\nexport function createFetchConfigFromReq({ req, rpcTarget, originHttpHeaderKey }: FetchMiddlewareFromReqOptions): FetchConfig {\n  const parsedUrl: URL = new URL(rpcTarget);\n\n  // prepare payload\n  // copy only canonical json rpc properties\n  const payload: Payload = {\n    id: req.id,\n    jsonrpc: req.jsonrpc,\n    method: req.method,\n    params: req.params,\n  };\n\n  // extract 'origin' parameter from request\n  const originDomain: string | undefined = req.origin;\n\n  // serialize request body\n  const serializedPayload: string = JSON.stringify(payload);\n\n  // configure fetch params\n  const fetchParams = {\n    method: \"POST\",\n    headers: {\n      Accept: \"application/json\",\n      \"Content-Type\": \"application/json\",\n    },\n    body: serializedPayload,\n  };\n\n  // optional: add request origin as header\n  if (originHttpHeaderKey && originDomain) {\n    fetchParams.headers[originHttpHeaderKey] = originDomain;\n  }\n\n  return { fetchUrl: parsedUrl.href, fetchParams };\n}\n\nexport function createFetchMiddleware({ rpcTarget, originHttpHeaderKey }: FetchMiddlewareOptions): JRPCMiddleware<string[], Block> {\n  return createAsyncMiddleware(async (req: JRPCRequest<string[]>, res: JRPCResponse<unknown>, _next: JRPCEngineNextCallback) => {\n    const { fetchUrl, fetchParams } = createFetchConfigFromReq({\n      req,\n      rpcTarget,\n      originHttpHeaderKey,\n    });\n\n    // attempt request multiple times\n    const maxAttempts = 5;\n    const retryInterval = 1000;\n    for (let attempt = 0; attempt < maxAttempts; attempt++) {\n      try {\n        const fetchRes: Response = await fetch(fetchUrl, fetchParams);\n        // check for http errrors\n        checkForHttpErrors(fetchRes);\n        // parse response body\n        const fetchBody: Record<string, Block> = await fetchRes.json();\n        const result: Block = parseResponse(fetchRes, fetchBody);\n        // set result and exit retry loop\n        res.result = result;\n        return;\n      } catch (err) {\n        const errMsg: string = err.toString();\n        const isRetriable: boolean = RETRIABLE_ERRORS.some((phrase) => errMsg.includes(phrase));\n        // re-throw error if not retriable\n        if (!isRetriable) {\n          throw err;\n        }\n      }\n      // delay before retrying\n      await timeout(retryInterval);\n    }\n  });\n}\n","import { JRPCEngineNextCallback, JRPCRequest, JRPCResponse } from \"@toruslabs/openlogin-jrpc\";\nimport log from \"loglevel\";\n\nexport interface LoggerMiddlewareOptions {\n  origin: string;\n}\n\nexport function createLoggerMiddleware(options: LoggerMiddlewareOptions) {\n  return function loggerMiddleware(request: JRPCRequest<unknown>, response: JRPCResponse<unknown>, next: JRPCEngineNextCallback): void {\n    next((callback) => {\n      if (response.error) {\n        log.warn(\"Error in RPC response:\\n\", response);\n      }\n      if ((request as unknown as { isTorusInternal: boolean }).isTorusInternal) return;\n      log.info(`RPC (${options.origin}):`, request, \"->\", response);\n      callback();\n    });\n  };\n}\n","import { JRPCEngineNextCallback, JRPCRequest, JRPCResponse } from \"@toruslabs/openlogin-jrpc\";\n\nexport interface OriginMiddlewareOptions {\n  origin: string;\n}\nexport function createOriginMiddleware(options: OriginMiddlewareOptions) {\n  return function originMiddleware(request: JRPCRequest<unknown>, _: JRPCResponse<unknown>, next: JRPCEngineNextCallback): void {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    (request as any).origin = options.origin;\n    next();\n  };\n}\n","import { BroadcastChannel } from \"@toruslabs/broadcast-channel\";\n\nimport { POPUP_LOADED } from \"../enums\";\nimport { broadcastChannelOptions } from \"../utils\";\nimport { PopupData } from \"./interfaces\";\n\nexport default class BroadcastChannelHandler {\n  public bc: BroadcastChannel<PopupData<unknown>>;\n\n  private channel: string;\n\n  constructor(channelPrefix: string) {\n    const queryParameters = new URLSearchParams(window.location.search);\n    const instanceId = queryParameters.get(\"instanceId\");\n    this.channel = `${channelPrefix}_${instanceId}`;\n    this.bc = new BroadcastChannel(this.channel, broadcastChannelOptions);\n  }\n\n  public getMessageFromChannel<T>(): Promise<T> {\n    return new Promise((resolve, reject) => {\n      this.bc.addEventListener(\"message\", async (ev) => {\n        this.bc.close();\n        if (ev.error) {\n          reject(ev.error);\n        } else {\n          resolve(ev.data as T);\n        }\n      });\n      this.bc.postMessage({ data: { type: POPUP_LOADED } });\n    });\n  }\n}\n","import { BroadcastChannel } from \"@toruslabs/broadcast-channel\";\nimport log from \"loglevel\";\n\nimport BaseController from \"../BaseController\";\nimport { COMMUNICATION_NOTIFICATIONS, POPUP_LOADED, SETUP_COMPLETE } from \"../enums\";\nimport { IWindow } from \"../interfaces\";\nimport { broadcastChannelOptions, randomId, sleep } from \"../utils\";\nimport { PopupData, StreamWindowConfig, StreamWindowState } from \"./interfaces\";\n\nclass StreamWindow extends BaseController<StreamWindowConfig, StreamWindowState> implements IWindow {\n  // if window has been closed by users\n  closed = false;\n\n  constructor({\n    config,\n    state = {},\n  }: {\n    config: Partial<StreamWindowConfig> & Pick<StreamWindowConfig, \"communicationEngine\" | \"communicationWindowManager\">;\n    state?: Partial<StreamWindowState>;\n  }) {\n    super({ config, state });\n    this.initialize();\n  }\n\n  async open(): Promise<this> {\n    return new Promise((resolve, reject) => {\n      const { communicationEngine, communicationWindowManager } = this.config;\n      let popupSuccess = false;\n\n      communicationWindowManager.once(`${this.state.windowId}:closed`, () => {\n        this.closed = true;\n      });\n\n      // Window is not open yet\n      if (!this.state.windowId) {\n        this.update({ windowId: randomId() });\n\n        communicationWindowManager.once(`${this.state.windowId}:opened`, () => {\n          resolve(this);\n        });\n\n        // Tell the other party to create a window by prompting the user to click on something\n        communicationEngine.emit(\"notification\", {\n          method: COMMUNICATION_NOTIFICATIONS.CREATE_WINDOW,\n          params: {\n            windowId: this.state.windowId,\n            url: this.state.url.href,\n          },\n        });\n      } else {\n        // Send this window with `windowId` the url to open via bc\n        const bc = new BroadcastChannel<PopupData<{ message: string }>>(this.state.windowId, broadcastChannelOptions);\n\n        bc.addEventListener(\"message\", async (ev) => {\n          try {\n            log.info(ev, `receiving data on channel: ${bc.name}`);\n            const { error } = ev;\n            if (error) {\n              // Popup says some error. so, we say it's not really opened\n              reject(new Error(error));\n              return;\n            }\n            const { message } = ev.data;\n            if (message === POPUP_LOADED) {\n              popupSuccess = true;\n              await bc.postMessage({\n                data: {\n                  url: this.state.url.href,\n                  message: \"\", // No need of a msg\n                },\n              } as PopupData<{ message: string }>);\n              resolve(this);\n              bc.close();\n            }\n          } catch (error) {\n            reject(error);\n            bc.close();\n            // Something went wrong. so, we close that window\n            this.close();\n          }\n        });\n\n        // We don't know if the other end is ready to receive this msg. So, we keep writing until it receives and sends back something\n        // we need backoff strategy\n        // we need to wait for first attempt to succeed/fail until the second attempt\n        // If we get 429, we need to wait for a while and then try again\n\n        const postMsg = async () => {\n          // this never throws\n          const localResponse = await bc.postMessage({\n            data: {\n              message: SETUP_COMPLETE,\n            },\n          } as PopupData<{ message: string }>);\n          return localResponse;\n        };\n\n        let currentDelay = bc.type === \"server\" ? 1000 : 200;\n\n        const recursiveFn = async (): Promise<void> => {\n          if (!popupSuccess && !this.closed) {\n            const localResponse = await postMsg();\n            if (bc.type === \"server\") {\n              const serverResponse = localResponse as unknown as Response;\n              if (serverResponse.status >= 400) {\n                // We need to wait for a while and then try again\n                currentDelay = Math.round(currentDelay * 1.5);\n              }\n            }\n            await sleep<void>(currentDelay);\n            await recursiveFn();\n          }\n        };\n        recursiveFn();\n      }\n    });\n  }\n\n  close(): void {\n    const { communicationEngine } = this.config;\n    communicationEngine.emit(\"notification\", {\n      method: COMMUNICATION_NOTIFICATIONS.CLOSE_WINDOW,\n      params: {\n        windowId: this.state.windowId,\n      },\n    });\n  }\n}\n\nexport default StreamWindow;\n","import BaseController from \"../BaseController\";\nimport { FEATURES_DEFAULT_POPUP_WINDOW } from \"../enums\";\nimport { IWindow } from \"../interfaces\";\nimport { getPopupFeatures } from \"../utils\";\nimport { PopupHandlerConfig, PopupHandlerState } from \"./interfaces\";\nimport StreamWindow from \"./StreamWindow\";\n/*\nScenarios:\n1. Open a normal popup window and no communication with it - Use PopupHandler\n2. Open a popup window and communicate with it - Use PopupWithBcHandler (can initiate communication by waiting for window to open or not)\n\n3. If window is already opened, pass in windowId to the popup handler. \n   This will establish communication with the popup window and sends it a new url to redirect to\n\n\nIf you're trying to open a window and it gets blocked (happens if you're in iframe or delay b/w click and opening window),\nStreamWindow is invoked and it writes in a channel to display a message to the user\n\nOnce user clicks on that modal/dialog, we pre-open the window and pass in the windowId (goes to 3)\n*/\n\n/**\n * Handles popup window management.\n * For broadcast channel communication, use url with `instanceId` coded into state parameter.\n * This state parameter will be passed across redirects according to OAuth spec.\n */\nclass PopupHandler extends BaseController<PopupHandlerConfig, PopupHandlerState> {\n  constructor({ config, state }: { config: Partial<PopupHandlerConfig>; state: Partial<PopupHandlerState> & Pick<PopupHandlerState, \"url\"> }) {\n    super({ config, state });\n    // this.id = randomId()\n    // Add in dapp storage key to all popups as a hash parameter\n    this.defaultConfig = {\n      dappStorageKey: \"\",\n      features: getPopupFeatures(FEATURES_DEFAULT_POPUP_WINDOW),\n      target: \"_blank\",\n      communicationEngine: null,\n      communicationWindowManager: null,\n    };\n    this.defaultState = {\n      windowTimer: null,\n      window: null,\n      iClosedWindow: false,\n      windowId: \"\",\n      url: state.url,\n    };\n    this.initialize();\n    this._setupTimer();\n  }\n\n  async open(): Promise<void> {\n    // if window is already open\n    const { target, features, dappStorageKey, communicationEngine, communicationWindowManager } = this.config;\n    const { windowId, url } = this.state;\n    if (dappStorageKey) {\n      const urlHashParams = new URLSearchParams(url.hash.slice(1));\n      urlHashParams.append(\"dappStorageKey\", dappStorageKey);\n      url.hash = urlHashParams.toString();\n      this.update({ url });\n    }\n    // No window has been pre-opened\n    if (!windowId) {\n      // try to open a window first\n      let localWindow: IWindow = window.open(url.href, target, features);\n      if (!localWindow) {\n        // if it's blocked, open StreamWindow\n        localWindow = new StreamWindow({ config: { communicationEngine, communicationWindowManager }, state: { url } });\n        localWindow.open();\n      }\n      this.update({ window: localWindow });\n      return;\n    }\n    // A window has been pre-opened with a query parameter `windowId`\n    const localWindow = new StreamWindow({ config: { communicationEngine, communicationWindowManager }, state: { url, windowId } });\n    this.update({ window: localWindow });\n    await localWindow.open();\n  }\n\n  close(): void {\n    this.update({ iClosedWindow: true });\n    const { window } = this.state;\n    if (window) window.close();\n  }\n\n  private _setupTimer(): void {\n    const timer = window.setInterval(() => {\n      const { window, windowTimer, iClosedWindow } = this.state;\n      if (window && window.closed) {\n        if (windowTimer) clearInterval(windowTimer);\n        if (!iClosedWindow) {\n          this.emit(\"close\");\n        }\n        this.update({ iClosedWindow: false, window: null });\n      }\n      if (window === null && windowTimer) clearInterval(windowTimer);\n    }, 500);\n    this.update({ windowTimer: timer });\n  }\n}\n\nexport default PopupHandler;\n","import { BroadcastChannel } from \"@toruslabs/broadcast-channel\";\nimport log from \"loglevel\";\n\nimport { BROADCAST_CHANNELS, BROADCAST_CHANNELS_MSGS } from \"../enums\";\nimport { broadcastChannelOptions } from \"../utils\";\nimport {\n  AccountImportedChannelData,\n  BasePopupChannelData,\n  NetworkChangeChannelData,\n  PopupData,\n  PopupStoreChannelHandlers,\n  SelectedAddresssChangeChannelData,\n  ThemeChannelData,\n} from \"./interfaces\";\n\nexport default class PopupStoreChannel {\n  private handleLogout: PopupStoreChannelHandlers[\"handleLogout\"];\n\n  private handleAccountImport: PopupStoreChannelHandlers[\"handleAccountImport\"];\n\n  private handleNetworkChange: PopupStoreChannelHandlers[\"handleNetworkChange\"];\n\n  private handleThemeChange: PopupStoreChannelHandlers[\"handleThemeChange\"];\n\n  private handleSelectedAddressChange: PopupStoreChannelHandlers[\"handleSelectedAddressChange\"];\n\n  private instanceId: string;\n\n  constructor({\n    instanceId,\n    handleLogout,\n    handleAccountImport,\n    handleNetworkChange,\n    handleSelectedAddressChange,\n    handleThemeChange,\n  }: {\n    instanceId: string;\n    handleLogout: PopupStoreChannelHandlers[\"handleLogout\"];\n    handleAccountImport: PopupStoreChannelHandlers[\"handleAccountImport\"];\n    handleNetworkChange: PopupStoreChannelHandlers[\"handleNetworkChange\"];\n    handleSelectedAddressChange: PopupStoreChannelHandlers[\"handleSelectedAddressChange\"];\n    handleThemeChange: PopupStoreChannelHandlers[\"handleThemeChange\"];\n  }) {\n    this.instanceId = instanceId;\n    this.handleLogout = handleLogout;\n    this.handleAccountImport = handleAccountImport;\n    this.handleNetworkChange = handleNetworkChange;\n    this.handleSelectedAddressChange = handleSelectedAddressChange;\n    this.handleThemeChange = handleThemeChange;\n  }\n\n  public setupStoreChannels(): void {\n    this.logoutChannel();\n    this.importAccountChannel();\n    this.networkChangeChannel();\n    this.selectedAddressChangeChannel();\n    this.themeChangedChannel();\n  }\n\n  private logoutChannel(): void {\n    const logoutChannel = new BroadcastChannel<PopupData<BasePopupChannelData>>(\n      `${BROADCAST_CHANNELS.WALLET_LOGOUT_CHANNEL}_${this.instanceId}`,\n      broadcastChannelOptions\n    );\n    logoutChannel.addEventListener(\"message\", (ev) => {\n      log.info(\"received logout message\", ev);\n      if (!ev.error && ev.data?.type === BROADCAST_CHANNELS_MSGS.LOGOUT) {\n        log.info(\"Logging Out\");\n        this.handleLogout();\n      }\n    });\n  }\n\n  private importAccountChannel(): void {\n    const walletAccountImportChannel = new BroadcastChannel<PopupData<AccountImportedChannelData>>(\n      `${BROADCAST_CHANNELS.WALLET_ACCOUNT_IMPORT_CHANNEL}_${this.instanceId}`,\n      broadcastChannelOptions\n    );\n    walletAccountImportChannel.addEventListener(\"message\", (ev) => {\n      if (!ev.error && ev.data?.type === BROADCAST_CHANNELS_MSGS.ACCOUNT_IMPORTED) {\n        this.handleAccountImport(ev.data?.privKey);\n      }\n    });\n  }\n\n  private networkChangeChannel(): void {\n    const walletAccountImportChannel = new BroadcastChannel<PopupData<NetworkChangeChannelData>>(\n      `${BROADCAST_CHANNELS.WALLET_NETWORK_CHANGE_CHANNEL}_${this.instanceId}`,\n      broadcastChannelOptions\n    );\n    walletAccountImportChannel.addEventListener(\"message\", (ev) => {\n      if (!ev.error && ev.data?.type === BROADCAST_CHANNELS_MSGS.NETWORK_CHANGE) {\n        this.handleNetworkChange(ev.data?.network);\n      }\n    });\n  }\n\n  private themeChangedChannel(): void {\n    const walletAccountImportChannel = new BroadcastChannel<PopupData<ThemeChannelData>>(\n      `${BROADCAST_CHANNELS.THEME_CHANGE}_${this.instanceId}`,\n      broadcastChannelOptions\n    );\n    walletAccountImportChannel.addEventListener(\"message\", (ev) => {\n      log.info({ ev });\n      if (!ev.error && ev.data?.type === BROADCAST_CHANNELS_MSGS.SET_THEME) {\n        this.handleThemeChange(ev.data?.theme);\n      }\n    });\n  }\n\n  private selectedAddressChangeChannel(): void {\n    const walletAccountImportChannel = new BroadcastChannel<PopupData<SelectedAddresssChangeChannelData>>(\n      `${BROADCAST_CHANNELS.WALLET_SELECTED_ADDRESS_CHANNEL}_${this.instanceId}`,\n      broadcastChannelOptions\n    );\n    walletAccountImportChannel.addEventListener(\"message\", (ev) => {\n      if (!ev.error && ev.data?.type === BROADCAST_CHANNELS_MSGS.SELECTED_ADDRESS_CHANGE) {\n        this.handleSelectedAddressChange(ev.data?.selectedAddress);\n      }\n    });\n  }\n}\n","import { BroadcastChannel } from \"@toruslabs/broadcast-channel\";\nimport log from \"loglevel\";\n\nimport { POPUP_LOADED, POPUP_RESULT } from \"../enums\";\nimport { broadcastChannelOptions, UserError } from \"../utils\";\nimport { PopupData, PopupHandlerConfig, PopupHandlerState, SuccessExtraFn } from \"./interfaces\";\nimport PopupHandler from \"./PopupHandler\";\n/**\n * PopupWithBcHandler is a PopupHandler which uses broadcast channel to communicate with the popup window.\n */\nclass PopupWithBcHandler<ReceiveData, SendData = unknown> extends PopupHandler {\n  bc: BroadcastChannel<PopupData<ReceiveData>>;\n\n  constructor({\n    config,\n    state,\n    instanceId,\n  }: {\n    config: Partial<PopupHandlerConfig>;\n    state: Partial<PopupHandlerState> & Pick<PopupHandlerState, \"url\">;\n    instanceId: string;\n  }) {\n    super({ config, state });\n    this.bc = new BroadcastChannel(instanceId, broadcastChannelOptions);\n  }\n\n  /**\n   * Receives the data from popup window and closes the window\n   * @param successExtraFn - Extra function to be called after the data is received\n   * @returns The data to be received\n   */\n  handle(successExtraFn?: SuccessExtraFn<ReceiveData>): Promise<ReceiveData> {\n    return new Promise((resolve, reject) => {\n      const closeListener = () => {\n        this.bc.close();\n        reject(new UserError(\"user closed popup\"));\n        this.removeListener(\"close\", closeListener);\n      };\n      this.on(\"close\", closeListener);\n\n      this.bc.addEventListener(\"message\", async (ev) => {\n        log.info(ev, `receiving data on channel: ${this.bc.name}`);\n        try {\n          const { error, data } = ev;\n          if (error) {\n            reject(new Error(error));\n            return;\n          }\n          if (successExtraFn) await successExtraFn.call(this, data);\n          resolve(data);\n        } catch (error) {\n          reject(error);\n        } finally {\n          this.bc.close();\n          this.close();\n        }\n      });\n      this.open()\n        .then(() => {\n          log.info(`opened window ${this.bc.name}`);\n          // Opened window. yay.  let the bc events do their job\n          return undefined;\n        })\n        .catch((err) => {\n          log.error(err, \"something went wrong while opening window\");\n          reject(err);\n        });\n    });\n  }\n\n  /**\n   * Use this if we have to send large payloads which don't fit in query/hash params.\n   * Waits for ack that popup window is ready to receive data.\n   * Receives the data from popup window and closes the window\n   * @param payload - The data to be sent to the popup window once we have ack that window is ready to receive data\n   * @param successExtraFn - Extra function to be called after the data is received\n   * @returns The data to be received\n   */\n  handleWithHandshake(payload: SendData, successExtraFn?: SuccessExtraFn<ReceiveData>): Promise<ReceiveData> {\n    return new Promise((resolve, reject) => {\n      const closeListener = () => {\n        this.bc.close();\n        reject(new UserError(\"user closed popup\"));\n        this.removeListener(\"close\", closeListener);\n      };\n      this.on(\"close\", closeListener);\n      this.bc.addEventListener(\"message\", async (ev) => {\n        try {\n          log.info(ev, `receiving data on channel: ${this.bc.name}`);\n          const { error, data } = ev;\n          if (error) {\n            reject(new Error(error));\n            return;\n          }\n          // Do handshake\n          const { type = \"\" } = data as { type?: string };\n          if (type === POPUP_LOADED) {\n            // Hack with generic to use the same type for both send and receive\n            await this.bc.postMessage({\n              data: payload,\n            } as unknown as PopupData<ReceiveData>);\n          } else if (type === POPUP_RESULT) {\n            if (successExtraFn) await successExtraFn.call(this, data);\n            resolve(data);\n            // Must only close the bc after result is done\n            this.bc.close();\n            this.close();\n          }\n        } catch (error) {\n          reject(error);\n          this.bc.close();\n          this.close();\n        }\n      });\n      this.open()\n        .then(() => {\n          log.info(`opened window ${this.bc.name}`);\n          // Opened window. yay.  let the bc events do their job\n          return undefined;\n        })\n        .catch((err) => {\n          log.error(err, \"something went wrong while opening window\");\n          reject(err);\n        });\n    });\n  }\n}\nexport default PopupWithBcHandler;\n","import { BroadcastChannel } from \"@toruslabs/broadcast-channel\";\nimport log from \"loglevel\";\n\nimport { BROADCAST_CHANNELS, POPUP_LOADED, SETUP_COMPLETE } from \"../enums\";\nimport { PopupData } from \"../Popup\";\nimport { broadcastChannelOptions, handleRedirectParameters } from \"../utils/utils\";\n\nexport default class RedirectHandler {\n  private error: string;\n\n  private finalQueryParams: Record<string, string> = {};\n\n  private instanceParameters: Record<string, string>;\n\n  private hashParameters: Record<string, string>;\n\n  constructor() {\n    const { hash } = window.location;\n    const queryParameters = new URLSearchParams(window.location.search);\n    queryParameters.forEach((value, key) => {\n      this.finalQueryParams[key] = value;\n    });\n    const { error, instanceParameters, hashParameters } = handleRedirectParameters(hash, this.finalQueryParams);\n    this.error = error;\n    this.instanceParameters = instanceParameters;\n    this.hashParameters = hashParameters;\n  }\n\n  public async handle(): Promise<void> {\n    return new Promise((resolve, reject) => {\n      const { finalQueryParams, instanceParameters, hashParameters, error } = this;\n      let bc: BroadcastChannel<PopupData<unknown>>;\n      try {\n        if (!finalQueryParams.windowId) {\n          bc = new BroadcastChannel(`${BROADCAST_CHANNELS.REDIRECT_CHANNEL}_${instanceParameters.instanceId}`, broadcastChannelOptions);\n          bc.addEventListener(\"message\", async (ev) => {\n            if (ev.error) {\n              reject(ev.error);\n              window.close();\n            } else {\n              resolve();\n              bc.close();\n              log.info(\"posted\", { finalQueryParams, hashParameters, instanceParameters });\n            }\n          });\n          bc.postMessage({\n            data: {\n              instanceParams: instanceParameters,\n              hashParams: hashParameters,\n              queryParams: finalQueryParams,\n            },\n            error,\n          });\n\n          setTimeout(() => {\n            resolve();\n            window.location.href = window.location.origin + window.location.search + window.location.hash;\n          }, 5000);\n        } else {\n          bc = new BroadcastChannel(`${finalQueryParams.windowId}`, broadcastChannelOptions);\n          bc.addEventListener(\"message\", async (ev) => {\n            const { url, message } = ev.data as { url: string; message: string };\n            if (url) {\n              resolve();\n              window.location.href = url;\n            } else if (message === SETUP_COMPLETE) {\n              await bc.postMessage({\n                data: {\n                  windowId: finalQueryParams.windowId,\n                  message: POPUP_LOADED,\n                },\n              });\n            }\n            if (ev.error && ev.error !== \"\") {\n              log.error(ev.error);\n              resolve();\n              bc.close();\n            }\n          });\n        }\n      } catch (err: unknown) {\n        log.info(err as Error, \"something went wrong\");\n        reject(err);\n        if (bc) bc.close();\n        window.close();\n      }\n    });\n  }\n}\n","import { BaseConfig, BaseState, IController, UserInfo } from \"../interfaces\";\n\nexport const ACTIVITY_ACTION = {\n  ACTIVITY_ACTION_ALL: \"walletActivity.allTransactions\",\n  ACTIVITY_ACTION_SEND: \"walletActivity.send\",\n  ACTIVITY_ACTION_RECEIVE: \"walletActivity.receive\",\n  ACTIVITY_ACTION_TOPUP: \"walletActivity.topup\",\n};\n\nexport type ACTIVITY_ACTION_TYPE = typeof ACTIVITY_ACTION[keyof typeof ACTIVITY_ACTION];\n\nexport const ACCOUNT_CATEGORY = {\n  NORMAL: \"normal\",\n  THRESHOLD: \"threshold\",\n  IMPORTED: \"imported\",\n};\n\nexport type ACCOUNT_TYPE = typeof ACCOUNT_CATEGORY[keyof typeof ACCOUNT_CATEGORY];\n\nexport type THEME = \"light\" | \"dark\";\n\nexport type CustomNft = {\n  id: number;\n  created_at: string;\n  nft_address: string;\n  public_address: string;\n  network: string;\n  nft_contract_standard: string;\n  nft_id: string;\n};\n\nexport type CustomToken = {\n  id: number;\n  created_at: string;\n  token_address: string;\n  public_address: string;\n  network: string;\n  token_symbol: string;\n  token_name: string;\n  decimals: string;\n};\n\nexport type UserVerifierInfo = {\n  verifier: string;\n  verifierId: string;\n};\n\nexport type PaymentTransaction = {\n  id: string;\n  date: string;\n  from: string;\n  slicedFrom: string;\n  action: string;\n  to: string;\n  slicedTo: string;\n  totalAmount: number;\n  totalAmountString: string;\n  currencyAmount: number;\n  currencyAmountString: string;\n  amount: number;\n  ethRate: number;\n  status: string;\n  blockExplorerLink: string;\n  currencyUsed: string;\n};\n\nexport interface RecordLoginPayload {\n  browser: string;\n  os: string;\n  os_version: string;\n  browser_version: string;\n  platform: string;\n  hostname: string;\n  verifier: string;\n  verifier_id: string;\n  metadata?: string;\n  idToken?: string;\n}\n\nexport interface UserPayload {\n  verifier: string;\n  verifier_id: string;\n  theme: string;\n  locale: string;\n  default_currency: string;\n  idToken?: string; // verified by openlogin\n}\nexport interface ContactPayload {\n  contact_verifier: string; // This is the verifier of the contact\n  contact_verifier_id: string; // This is the verifier id of the contact\n  display_name: string;\n}\n\nexport type Contact = {\n  id: number;\n  created_at: string;\n  updated_at: string;\n  contact_verifier: string;\n  contact_verifier_id: string;\n  display_name: string;\n  public_address: string;\n};\n\nexport interface AddressPreferences {\n  selectedCurrency: string;\n  theme: THEME;\n  locale: string;\n  accountType: ACCOUNT_TYPE;\n  contacts: Contact[];\n  crashReport: boolean;\n  userInfo: UserInfo;\n  jwtToken?: string;\n  paymentTx?: PaymentTransaction[];\n  defaultPublicAddress?: string;\n  customTokens?: CustomToken[];\n  customNfts?: CustomNft[];\n}\n\nexport interface User {\n  id: number;\n  public_address: string;\n  default_currency: string;\n  created_at: string;\n  theme: THEME;\n  locale: string;\n  verifier: string;\n  verifier_id: string;\n  account_type: string;\n  default_public_address: string;\n  contacts?: Contact[];\n  customTokens?: CustomToken[];\n  customNfts?: CustomNft[];\n}\n\nexport interface BillboardEvent {\n  eventName: string;\n  imageUrl: string;\n  imageDarkUrl: string;\n  description: string;\n  callToActionLinkTwo: string;\n  callToActionLink: string;\n  callToActionText: string;\n  locale: string;\n}\n\n/**\n * Preferences controller state\n */\nexport interface PreferencesState<P> extends BaseState {\n  /**\n   * Map of addresses to ContactEntry objects\n   */\n  identities: { [address: string]: P };\n  /**\n   * Current coinbase account\n   */\n  selectedAddress: string;\n\n  lastErrorMessage?: string;\n\n  lastSuccessMessage?: string;\n}\n\nexport interface PreferencesConfig extends BaseConfig {\n  pollInterval?: number;\n  api: string;\n  commonApiHost: string;\n  signInPrefix: string;\n}\n\ninterface DappUrl {\n  url: string;\n}\n\nexport interface DiscoverDapp {\n  logo: DappUrl[];\n  title: string;\n  category: string;\n  desc: string;\n  network: string;\n  url: string;\n}\n\nexport interface IPreferencesController<P, C, S> extends IController<C, S> {\n  /**\n   * Init will sync the preferences of specified address with backend and also add the identity in state\n   * the store.\n   * @param address - address of the user\n   * @param jwtToken - if jwt token already exists, it will be used instead of fetching from backend\n   * @param calledFromEmbed - if called from embed\n   * @param userInfo - optional user info\n   * @param rehydrate - Rehydrate the preferences from the local storage\n   *\n   */\n  initPreferences(params: {\n    address: string;\n    jwtToken?: string;\n    calledFromEmbed?: boolean;\n    userInfo?: { verifier: string; verifierId: string };\n    rehydrate?: boolean;\n    locale?: string;\n  }): Promise<void>;\n\n  /**\n   * Gets the preferences state of specified address\n   * @defaultValue - By default it will return selected address preferences\n   */\n  getAddressState(address?: string): P;\n\n  /**\n   * Sets the selected address in state\n   * @param selectedAddress - Sets the provided address as currently selected address\n   */\n  setSelectedAddress(selectedAddress: string): void;\n}\n","import { get, patch, post, remove } from \"@toruslabs/http-helpers\";\nimport bowser from \"bowser\";\nimport { cloneDeep } from \"lodash\";\nimport log from \"loglevel\";\n\nimport BaseController from \"../BaseController\";\nimport { BaseConfig, EmailObject, LOGIN_PROVIDER, UserInfo } from \"../interfaces\";\nimport { BaseKeyringController } from \"../Keyring/BaseKeyringController\";\nimport { KeyringControllerState } from \"../Keyring/IKeyringController\";\nimport { TransactionStatus } from \"../Transaction/ITransactionController\";\nimport { getCustomDeviceInfo, getHeaders } from \"../utils\";\nimport {\n  ACCOUNT_CATEGORY,\n  AddressPreferences,\n  BillboardEvent,\n  Contact,\n  ContactPayload,\n  DiscoverDapp,\n  PreferencesConfig,\n  PreferencesState,\n  RecordLoginPayload,\n  THEME,\n  UserPayload,\n} from \"./IPreferencesController\";\n\n// By default, poll every 3 minutes\nconst DEFAULT_INTERVAL = 180 * 1000;\n\nexport const DEFAULT_PREFERENCES = {\n  selectedCurrency: \"USD\",\n  theme: \"dark\",\n  locale: \"en-US\",\n  accountType: ACCOUNT_CATEGORY.NORMAL,\n  contacts: [],\n  jwtToken: \"\",\n  fetchedPastTx: [],\n  pastTransactions: [],\n  paymentTx: [],\n  defaultPublicAddress: \"\",\n  customTokens: [],\n  customNfts: [],\n  crashReport: true,\n  userInfo: {\n    aggregateVerifier: \"\",\n    email: \"\",\n    name: \"\",\n    profileImage: \"\",\n    typeOfLogin: LOGIN_PROVIDER.GOOGLE,\n    verifier: \"\",\n    verifierId: \"\",\n  },\n} as AddressPreferences;\n\n/**\n * Controller that stores shared settings and exposes convenience methods\n */\nexport abstract class BasePreferencesController<\n  P extends AddressPreferences,\n  C extends PreferencesConfig,\n  S extends PreferencesState<P>\n> extends BaseController<C, S> {\n  /**\n   * Name of this controller used during composition\n   */\n  name = \"PreferencesController\";\n\n  public iframeOrigin: string;\n\n  private signAuthMessage: BaseKeyringController<BaseConfig, KeyringControllerState>[\"signAuthMessage\"];\n\n  private defaultPreferences: Partial<P>;\n\n  /**\n   * Creates a PreferencesController instance\n   *\n   * @param config - Initial options used to configure this controller\n   * @param state - Initial state to set on this controller\n   */\n  constructor({\n    config,\n    state,\n    defaultPreferences,\n    signAuthMessage,\n  }: {\n    config?: Partial<C> & Pick<C, \"api\" | \"commonApiHost\" | \"signInPrefix\">;\n    state?: Partial<S>;\n    defaultPreferences?: Partial<P>;\n    signAuthMessage: BaseKeyringController<BaseConfig, KeyringControllerState>[\"signAuthMessage\"];\n  }) {\n    super({ config, state });\n    if (!config.api) {\n      throw new Error(\"PreferencesController - no api specified in config.\");\n    }\n    this.defaultState = {\n      identities: {},\n      selectedAddress: \"\",\n      lastErrorMessage: \"\",\n      lastSuccessMessage: \"\",\n    } as S;\n    this.defaultConfig = {\n      api: config.api,\n      pollInterval: DEFAULT_INTERVAL,\n    } as C;\n    this.initialize();\n    this.defaultPreferences = {\n      ...DEFAULT_PREFERENCES,\n      ...defaultPreferences,\n    };\n    this.signAuthMessage = signAuthMessage;\n  }\n\n  public setIframeOrigin(origin: string): void {\n    this.iframeOrigin = origin;\n  }\n\n  getAddressState(address?: string): P | undefined {\n    const selectedAddress = address || this.state.selectedAddress;\n    return this.state.identities[selectedAddress];\n  }\n\n  /**\n   * Sets selected address\n   *\n   * @param selectedAddress - casper account hash\n   */\n  setSelectedAddress(selectedAddress: string): void {\n    this.update({ selectedAddress } as Partial<S>);\n  }\n\n  async getUser<U>(address: string): Promise<U> {\n    const user = await get<{ success: boolean; error?: string; data?: U }>(`${this.config.api}/user?fetchTx=false`, this.headers(address), {\n      useAPIKey: true,\n    });\n    return user.data;\n  }\n\n  async createUser(params: {\n    selectedCurrency: string;\n    theme: THEME;\n    verifier: string;\n    verifierId: string;\n    locale: string;\n    address: string;\n    idToken?: string;\n  }): Promise<void> {\n    const { selectedCurrency, theme, verifier, verifierId, locale, address, idToken } = params;\n    const userPayload: UserPayload = {\n      default_currency: selectedCurrency,\n      theme,\n      verifier,\n      verifier_id: verifierId,\n      locale,\n      idToken,\n    };\n    await post(`${this.config.api}/user`, userPayload, this.headers(address), { useAPIKey: true });\n    this.updateState(\n      {\n        theme,\n        defaultPublicAddress: address,\n        selectedCurrency,\n        locale,\n      } as Partial<P>,\n      address\n    );\n  }\n\n  public async storeUserLogin(params: {\n    verifier: string;\n    verifierId: string;\n    address: string;\n    options: { calledFromEmbed: boolean; rehydrate: boolean };\n    idToken?: string;\n  }): Promise<void> {\n    const { verifierId, verifier, options, address, idToken } = params;\n    if (!options.rehydrate) {\n      const browser = bowser.getParser(window.navigator.userAgent);\n      const specialBrowser = getCustomDeviceInfo();\n      const recordLoginPayload: RecordLoginPayload = {\n        os: browser.getOSName(),\n        os_version: browser.getOSVersion() || \"unidentified\",\n        browser: specialBrowser?.browser || browser.getBrowserName() || \"unidentified\",\n        browser_version: browser.getBrowserVersion() || \"unidentified\",\n        platform: browser.getPlatform().type || \"desktop\",\n        hostname: this.iframeOrigin,\n        verifier,\n        verifier_id: verifierId,\n        idToken,\n      };\n      await post<{ success: boolean }>(`${this.config.api}/user/recordLogin`, recordLoginPayload, this.headers(address), { useAPIKey: true });\n    }\n  }\n\n  async setCrashReport(isEnabled: boolean): Promise<boolean> {\n    if (isEnabled === this.getAddressState()?.crashReport) return true;\n    try {\n      await patch(`${this.config.api}/user`, { enable_crash_reporter: isEnabled }, this.headers(), { useAPIKey: true });\n      this.updateState({ crashReport: isEnabled } as Partial<P>);\n      return true;\n    } catch (error) {\n      log.error(error);\n      return false;\n    }\n  }\n\n  async setUserTheme(theme: THEME): Promise<boolean> {\n    if (theme === this.getAddressState()?.theme) return true;\n    try {\n      await patch(`${this.config.api}/user`, { theme }, this.headers(), { useAPIKey: true });\n      this.updateState({ theme } as Partial<P>);\n      return true;\n    } catch (error) {\n      log.error(error);\n      return false;\n    }\n  }\n\n  async setUserLocale(locale: string): Promise<boolean> {\n    if (locale === this.getAddressState()?.locale) return;\n    try {\n      await patch(`${this.config.api}/user`, { locale }, this.headers(), { useAPIKey: true });\n      this.updateState({ locale } as Partial<P>);\n      return true;\n    } catch (error) {\n      log.error(\"unable to set locale\", error);\n      return false;\n    }\n  }\n\n  async setSelectedCurrency(payload: { selectedCurrency: string }): Promise<boolean> {\n    if (payload.selectedCurrency === this.getAddressState()?.selectedCurrency) return true;\n    try {\n      await patch(`${this.config.api}/user`, { default_currency: payload.selectedCurrency }, this.headers(), { useAPIKey: true });\n      this.updateState({ selectedCurrency: payload.selectedCurrency } as Partial<P>);\n      return true;\n    } catch (error) {\n      log.error(error);\n      return false;\n    }\n  }\n\n  async addContact(contact: ContactPayload): Promise<boolean> {\n    try {\n      const response = await post<{ success: boolean; data: Contact }>(`${this.config.api}/contact`, contact, this.headers(), { useAPIKey: true });\n      this.updateState({ contacts: [...(this.getAddressState()?.contacts || []), response.data] } as Partial<P>);\n      return true;\n    } catch (error) {\n      log.error(\"unable to add contact\", error);\n      return false;\n    }\n  }\n\n  async deleteContact(contactId: number): Promise<boolean> {\n    try {\n      const response = await remove<{ success: boolean; data: { id: number } }>(`${this.config.api}/contact/${contactId}`, {}, this.headers(), {\n        useAPIKey: true,\n      });\n      const finalContacts = this.getAddressState()?.contacts.filter((contact) => contact.id !== response.data.id);\n      if (finalContacts) this.updateState({ contacts: [...finalContacts] } as Partial<P>);\n      return true;\n    } catch (error) {\n      log.error(\"unable to delete contact\", error);\n      return false;\n    }\n  }\n\n  async revokeDiscord(idToken: string): Promise<void> {\n    try {\n      const resp = await post(`${this.config.api}/revoke/discord`, { token: idToken }, this.headers(), { useAPIKey: true });\n      log.info(resp);\n    } catch (error) {\n      log.error(error);\n    }\n  }\n\n  async patchPastTx(body: { id: string; status: TransactionStatus; updated_at: string }, address: string): Promise<void> {\n    try {\n      const response = await patch(`${this.config.api}/transaction`, body, this.headers(address), { useAPIKey: true });\n      log.info(\"successfully patched\", response);\n    } catch (error) {\n      log.error(\"unable to patch tx\", error);\n    }\n  }\n\n  async postPastTx<T>(tx: T, address: string): Promise<{ success: boolean; response: number[] }> {\n    try {\n      const response = await post(`${this.config.api}/transaction`, tx, this.headers(address), {\n        useAPIKey: true,\n      });\n      log.info(\"successfully posted tx\", response);\n      return response as { success: boolean; response: number[] };\n    } catch (error) {\n      log.error(error, \"unable to insert transaction\");\n    }\n  }\n\n  async getWalletOrders<T>(address: string): Promise<T[]> {\n    try {\n      const response = await get<{ success: boolean; data: T[] | null }>(`${this.config.api}/transaction`, this.headers(address), {\n        useAPIKey: true,\n      });\n      return response.success ? (response.data ? response.data : []) : [];\n    } catch (error) {\n      log.error(\"unable to get wallet orders tx\", error);\n      return [];\n    }\n  }\n\n  async getTopUpOrders<T>(address: string): Promise<T[]> {\n    try {\n      const response = await get<{ success: boolean; data: T[] }>(`${this.config.commonApiHost}/transaction`, this.headers(address), {\n        useAPIKey: true,\n      });\n      return response.data || [];\n    } catch (error) {\n      log.error(\"unable to fetch past Top up orders\", error);\n    }\n  }\n\n  async getBillBoardData(): Promise<BillboardEvent[]> {\n    try {\n      const response = await get<{ success: boolean; data: BillboardEvent[] | null }>(`${this.config.api}/billboard`, this.headers(), {\n        useAPIKey: true,\n      });\n      return response.success ? response.data : [];\n    } catch (error) {\n      log.error(\"unable to get billboard data\", error);\n      return [];\n    }\n  }\n\n  async getMessageForSigning(publicAddress: string): Promise<string> {\n    const response = await post<{ success: boolean; message: string }>(\n      `${this.config.api}/auth/message`,\n      {\n        public_address: publicAddress,\n      },\n      {},\n      { useAPIKey: true }\n    );\n    return response.message;\n  }\n\n  async getTwitterId(payload: { nick: string; typeOfLogin: string }): Promise<string> {\n    const res = await get<{ success: boolean; data: string }>(`${this.config.api}/twitter?screen_name=${payload.nick}`, this.headers(), {\n      useAPIKey: true,\n    });\n    return `${payload.typeOfLogin.toLowerCase()}|${res.data.toString()}`;\n  }\n\n  async sendEmail(payload: { emailObject: EmailObject }): Promise<void> {\n    return post(`${this.config.api}/transaction/sendemail`, payload.emailObject, this.headers(), { useAPIKey: true });\n  }\n\n  async refreshJwt(): Promise<void> {\n    const address = this.state.selectedAddress;\n    const messageToSign = await this.getMessageForSigning(address);\n    if (!messageToSign.startsWith(this.config.signInPrefix)) throw new Error(\"Cannot sign on invalid message\");\n    const signedMessage = this.signAuthMessage(address, messageToSign);\n    const response: { token: string } = await post(\n      `${this.config.api}/auth/verify`,\n      {\n        public_address: address,\n        signed_message: signedMessage,\n      },\n      {},\n      { useAPIKey: true }\n    );\n    this.updateState({ jwtToken: response.token } as Partial<P>, address);\n  }\n\n  async getDappList(): Promise<DiscoverDapp[]> {\n    try {\n      const response = await get<{ success: boolean; error?: string; data?: DiscoverDapp[] }>(`${this.config.api}/dapps`, this.headers(), {\n        useAPIKey: true,\n      });\n      return response.success ? response.data : [];\n    } catch (error) {\n      log.error(\"unable to get billboard data\", error);\n      return [];\n    }\n  }\n\n  protected async init(address: string, userInfo: UserInfo, jwtToken?: string): Promise<void> {\n    let response = { token: jwtToken };\n    if (this.getAddressState(address)) return;\n    if (!jwtToken) {\n      const messageToSign = await this.getMessageForSigning(address);\n      if (!messageToSign.startsWith(this.config.signInPrefix)) throw new Error(\"Cannot sign on invalid message\");\n      const signedMessage = this.signAuthMessage(address, messageToSign);\n      response = await post(\n        `${this.config.api}/auth/verify`,\n        {\n          public_address: address,\n          signed_message: signedMessage,\n        },\n        {},\n        { useAPIKey: true }\n      );\n    }\n    this.updateState({ jwtToken: response.token, userInfo } as Partial<P>, address);\n  }\n\n  protected updateState(preferences?: Partial<P>, address?: string): P {\n    const selectedAddress = address || this.state.selectedAddress;\n    const currentState = this.getAddressState(selectedAddress) || cloneDeep(this.defaultPreferences);\n    const mergedState = { ...currentState, ...preferences } as P;\n    this.update({\n      identities: {\n        ...this.state.identities,\n        [selectedAddress]: mergedState,\n      },\n    } as S);\n    return mergedState;\n  }\n\n  private headers(address?: string): { headers: { Authorization: string; \"Content-Type\": string } } {\n    const selectedAddress = address || this.state.selectedAddress;\n    return getHeaders(this.getAddressState(selectedAddress)?.jwtToken || \"\");\n  }\n\n  abstract sync(address: string): Promise<boolean>;\n}\n","import { JRPCRequest } from \"@toruslabs/openlogin-jrpc\";\n\nimport { BaseConfig, BaseState } from \"../interfaces\";\n\n/**\n * The status of the transaction. Each status represents the state of the transaction internally\n * in the wallet. Some of these correspond with the state of the transaction on the network, but\n * some are wallet-specific.\n */\n\nexport enum TransactionStatus {\n  approved = \"approved\",\n  cancelled = \"cancelled\",\n  confirmed = \"confirmed\",\n  failed = \"failed\",\n  finalized = \"finalized\",\n  processed = \"processed\",\n  rejected = \"rejected\",\n  signed = \"signed\",\n  submitted = \"submitted\",\n  unapproved = \"unapproved\",\n  dropped = \"dropped\",\n  expired = \"expired\",\n}\n\nexport const TRANSACTION_TYPES = {\n  CONTRACT_INTERACTION: \"contractInteraction\",\n  DEPLOY_CONTRACT: \"contractDeployment\",\n  WASM_BASED_DEPLOY: \"wasmBasedDeploy\",\n  STANDARD_TRANSACTION: \"transaction\",\n  STANDARD_PAYMENT_TRANSACTION: \"payment_transaction\", // specific to chains like solana and casper\n};\n\nexport type TRANSACTION_TYPE = typeof TRANSACTION_TYPES[keyof typeof TRANSACTION_TYPES];\n\nexport const TX_EVENTS = {\n  TX_WARNING: \"tx:warning\",\n  TX_ERROR: \"tx:error\",\n  TX_FAILED: \"tx:failed\",\n  TX_CONFIRMED: \"tx:confirmed\",\n  TX_DROPPED: \"tx:dropped\",\n  TX_EXPIRED: \"tx:expired\",\n  TX_STATUS_UPDATE: \"tx:status_update\",\n  TX_UNAPPROVED: \"tx:unapproved\",\n};\n\nexport interface TransactionMeta<T> {\n  id: string;\n  transaction: T;\n  transactionType: TRANSACTION_TYPE;\n  dappSuggestedTransaction: Partial<T>;\n  chainId: string;\n  origin: string;\n  time: number;\n  status: TransactionStatus;\n  updated_at?: string; // iso date string\n  transactionHash?: string;\n  rawTransaction?: string;\n  txReceipt?: unknown;\n  error?: Error;\n  warning?: {\n    error?: string;\n    message?: string;\n  };\n}\n\nexport type BASE_TX_EVENT_TYPE = {\n  txId: string;\n};\n\nexport type TX_ERROR_EVENT_TYPE = BASE_TX_EVENT_TYPE & {\n  error: Error;\n};\n\nexport type TX_FAILED_EVENT_TYPE = BASE_TX_EVENT_TYPE & {\n  error: Error;\n};\n\nexport type TX_EXPIRED_EVENT_TYPE = BASE_TX_EVENT_TYPE;\n\nexport type TX_WARNING_EVENT_TYPE<T> = BASE_TX_EVENT_TYPE & {\n  txMeta: TransactionMeta<T>;\n};\n\nexport type TX_CONFIRMED_EVENT_TYPE = BASE_TX_EVENT_TYPE & {\n  txReceipt: unknown;\n};\n\nexport type TX_DROPPED_EVENT_TYPE = BASE_TX_EVENT_TYPE;\n\nexport type TX_STATUS_UPDATE_EVENT_TYPE = BASE_TX_EVENT_TYPE & {\n  status: TransactionStatus;\n};\n\nexport type TX_FINISHED_EVENT_TYPE<T> = BASE_TX_EVENT_TYPE & {\n  txMeta: TransactionMeta<T>;\n};\n\n/**\n * Transaction controller configuration\n */\nexport interface TransactionConfig extends BaseConfig {\n  txHistoryLimit: number;\n}\n\n/**\n * Transaction controller state\n */\nexport interface TransactionState<T> extends BaseState {\n  /**\n   * Transactions by key (id) value (TxMeta)\n   */\n  transactions: Record<string, TransactionMeta<T>>; // all transactions (unapprroved and all others)\n  unapprovedTxs?: Record<string, TransactionMeta<T>>; // only unapproved\n  currentNetworkTxsList?: TransactionMeta<T>[];\n}\n\n/**\n * Result\n *\n * result - Promise resolving to a new transaction hash\n * transactionMeta - Meta information about this new transaction\n */\nexport interface Result<T> {\n  result: Promise<string>;\n  transactionMeta: TransactionMeta<T>;\n}\n\nexport interface ITransactionController<T> {\n  /**\n   * Add a new unapproved transaction to state.\n   * @param transaction - Transaction object to add\n   * @returns - Object containing a promise resolving to the transaction hash if approved\n   */\n  addTransaction(transaction: T, req: JRPCRequest<T & { windowId?: string }> & { origin: string }): Promise<Result<T>>;\n\n  /**\n   * Approves a transaction and updates it's status in state.\n   *\n   * @param transactionID - ID of the transaction to approve\n   * @returns - Promise resolving when this operation completes\n   */\n  approveTransaction(transactionID: string): Promise<void>;\n\n  /**\n   * Cancels a transaction based on its ID by setting its status to \"rejected\"\n   *\n   * @param transactionID - ID of the transaction to cancel\n   */\n  cancelTransaction?(transactionID: string): Promise<void>;\n}\n\nexport interface ITransactionStateManager<T> {\n  addTransactionToState(txMeta: TransactionMeta<T>): TransactionMeta<T>;\n\n  wipeTransactions(address: string): void;\n\n  getTransactions(args: {\n    searchCriteria?: Record<string, (val: unknown) => boolean> | Record<string, unknown>;\n    initialList?: TransactionMeta<T>[];\n    filterToCurrentNetwork?: boolean;\n  }): TransactionMeta<T>[];\n  getApprovedTransactions(address?: string): TransactionMeta<T>[];\n  getPendingTransactions(address?: string): TransactionMeta<T>[];\n  getConfirmedTransactions(address?: string): TransactionMeta<T>[];\n}\n","import { omitBy, pickBy } from \"lodash\";\n\nimport BaseController from \"../BaseController\";\nimport { transactionMatchesNetwork } from \"../utils\";\nimport {\n  TransactionConfig,\n  TransactionMeta,\n  TransactionState,\n  TransactionStatus,\n  TX_EVENTS,\n  TX_STATUS_UPDATE_EVENT_TYPE,\n} from \"./ITransactionController\";\n\nexport class BaseTransactionStateManager<T> extends BaseController<TransactionConfig, TransactionState<T>> {\n  protected getCurrentChainId: () => string;\n\n  constructor({\n    config,\n    state,\n    getCurrentChainId,\n  }: {\n    config?: Partial<TransactionConfig>;\n    state?: Partial<TransactionState<T>>;\n    getCurrentChainId: () => string;\n  }) {\n    super({ config, state });\n    this.defaultConfig = {\n      txHistoryLimit: 40,\n    };\n    this.defaultState = {\n      transactions: {},\n      unapprovedTxs: {},\n      currentNetworkTxsList: [],\n    };\n    this.initialize();\n    this.getCurrentChainId = getCurrentChainId;\n  }\n\n  getUnapprovedTxList(): Record<string, TransactionMeta<T>> {\n    const chainId = this.getCurrentChainId();\n    return pickBy(\n      this.state.transactions,\n      (transaction) => transaction.status === TransactionStatus.unapproved && transactionMatchesNetwork<T>(transaction, chainId)\n    );\n  }\n\n  getTransaction(txId: string): TransactionMeta<T> {\n    const { transactions } = this.state;\n    return transactions[txId];\n  }\n\n  updateTransaction(txMeta: TransactionMeta<T>): void {\n    // commit txMeta to state\n    const txId = txMeta.id;\n    txMeta.updated_at = new Date().toISOString();\n    this.update({\n      transactions: {\n        ...this.state.transactions,\n        [txId]: txMeta,\n      },\n    });\n  }\n\n  setTxStatusRejected(txId: string): void {\n    this._setTransactionStatus(txId, TransactionStatus.rejected);\n    this._deleteTransaction(txId);\n  }\n\n  /**\n   * The implementing controller can override this functionality and add custom logic + call super.()\n   */\n  setTxStatusUnapproved(txId: string): void {\n    this._setTransactionStatus(txId, TransactionStatus.unapproved);\n  }\n\n  setTxStatusApproved(txId: string): void {\n    this._setTransactionStatus(txId, TransactionStatus.approved);\n  }\n\n  setTxStatusSigned(txId: string): void {\n    this._setTransactionStatus(txId, TransactionStatus.signed);\n  }\n\n  setTxStatusSubmitted(txId: string): void {\n    this._setTransactionStatus(txId, TransactionStatus.submitted);\n  }\n\n  setTxStatusDropped(txId: string): void {\n    this._setTransactionStatus(txId, TransactionStatus.dropped);\n  }\n\n  setTxStatusExpired(txId: string): void {\n    this._setTransactionStatus(txId, TransactionStatus.expired);\n  }\n\n  setTxStatusConfirmed(txId: string): void {\n    this._setTransactionStatus(txId, TransactionStatus.confirmed);\n  }\n\n  setTxStatusFailed(txId: string, error_: Error): void {\n    const error = !error_ ? new Error(\"Internal torus failure\") : error_;\n\n    const txMeta = this.getTransaction(txId);\n    txMeta.error = error;\n    this.updateTransaction(txMeta);\n    this._setTransactionStatus(txId, TransactionStatus.failed);\n  }\n\n  /**\n   * Method to determine if the transaction is in a final state\n   * @param status - Transaction status\n   * @returns boolean if the transaction is in a final state\n   */\n  isFinalState(status: TransactionStatus): boolean {\n    return (\n      status === TransactionStatus.rejected ||\n      status === TransactionStatus.submitted ||\n      status === TransactionStatus.confirmed ||\n      status === TransactionStatus.failed ||\n      status === TransactionStatus.cancelled ||\n      status === TransactionStatus.expired\n    );\n  }\n\n  /**\n   * Filters out the unapproved transactions from state\n   */\n  clearUnapprovedTxs(): void {\n    this.update({\n      transactions: omitBy(this.state.transactions, (transaction: TransactionMeta<T>) => transaction.status === TransactionStatus.unapproved),\n    });\n  }\n\n  /**\n   * will append new transactions to old txns.\n   */\n  _addTransactionsToState(transactions: TransactionMeta<T>[]): void {\n    this.update({\n      transactions: transactions.reduce((result: Record<string, TransactionMeta<T>>, newTx: TransactionMeta<T>) => {\n        result[newTx.id] = newTx;\n        return result;\n      }, this.state.transactions),\n    });\n  }\n\n  /**\n   * will set new txns, override existing if any in state.\n   */\n  _setTransactionsToState(transactions: TransactionMeta<T>[]): void {\n    this.update({\n      transactions: transactions.reduce((result: Record<string, TransactionMeta<T>>, newTx: TransactionMeta<T>) => {\n        result[newTx.id] = newTx;\n        return result;\n      }, {}),\n    });\n  }\n\n  _deleteTransaction(targetTransactionId: string): void {\n    const { transactions } = this.state;\n    delete transactions[targetTransactionId];\n    this.update({\n      transactions,\n    });\n  }\n\n  _deleteTransactions(targetTransactionIds: string[]): void {\n    const { transactions } = this.state;\n    targetTransactionIds.forEach((transactionId) => {\n      delete transactions[transactionId];\n    });\n    this.update({\n      transactions,\n    });\n  }\n\n  protected _setTransactionStatus(txId: string, status: TransactionStatus): void {\n    const txMeta = this.getTransaction(txId);\n    if (!txMeta) {\n      return;\n    }\n    txMeta.status = status;\n    // only updating status so no validation required on txn.\n    this.updateTransaction(txMeta);\n    this.emit(TX_EVENTS.TX_STATUS_UPDATE, { txId, status } as TX_STATUS_UPDATE_EVENT_TYPE);\n    if (this.isFinalState(status)) {\n      this.emit(`${txMeta.id}:finished`, txMeta);\n    } else {\n      this.emit(`${txMeta.id}:${status}`, txId);\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}