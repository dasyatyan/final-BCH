{"ast":null,"code":"import { ChaCha20Poly1305 as te } from \"@stablelib/chacha20poly1305\";\nimport { HKDF as We } from \"@stablelib/hkdf\";\nimport { randomBytes as re } from \"@stablelib/random\";\nimport { SHA256 as Qe, hash as oe } from \"@stablelib/sha256\";\nimport * as se from \"@stablelib/x25519\";\nimport { toString as f, fromString as p, concat as ie } from \"uint8arrays\";\nimport { detect as Ze } from \"detect-browser\";\nimport { fromMiliseconds as ce, toMiliseconds as V, FIVE_MINUTES as Xe } from \"@walletconnect/time\";\nimport { getDocument as en, getNavigator as ae, getLocation as ue } from \"@walletconnect/window-getters\";\nimport { getWindowMetadata as nn } from \"@walletconnect/window-metadata\";\nimport * as U from \"query-string\";\nimport { RELAY_JSONRPC as tn } from \"@walletconnect/relay-api\";\nconst A = \":\";\nfunction de(e) {\n  const [n, t] = e.split(A);\n  return {\n    namespace: n,\n    reference: t\n  };\n}\nfunction le(e) {\n  const {\n    namespace: n,\n    reference: t\n  } = e;\n  return [n, t].join(A);\n}\nfunction M(e) {\n  const [n, t, r] = e.split(A);\n  return {\n    namespace: n,\n    reference: t,\n    address: r\n  };\n}\nfunction fe(e) {\n  const {\n    namespace: n,\n    reference: t,\n    address: r\n  } = e;\n  return [n, t, r].join(A);\n}\nfunction K(e, n) {\n  const t = [];\n  return e.forEach(r => {\n    const o = n(r);\n    t.includes(o) || t.push(o);\n  }), t;\n}\nfunction pe(e) {\n  const {\n    address: n\n  } = M(e);\n  return n;\n}\nfunction me(e) {\n  const {\n    namespace: n,\n    reference: t\n  } = M(e);\n  return le({\n    namespace: n,\n    reference: t\n  });\n}\nfunction rn(e, n) {\n  const {\n    namespace: t,\n    reference: r\n  } = de(n);\n  return fe({\n    namespace: t,\n    reference: r,\n    address: e\n  });\n}\nfunction on(e) {\n  return K(e, pe);\n}\nfunction ye(e) {\n  return K(e, me);\n}\nfunction sn(e, n = []) {\n  const t = [];\n  return Object.keys(e).forEach(r => {\n    if (n.length && !n.includes(r)) return;\n    const o = e[r];\n    t.push(...o.accounts);\n  }), t;\n}\nfunction cn(e, n = []) {\n  const t = [];\n  return Object.keys(e).forEach(r => {\n    if (n.length && !n.includes(r)) return;\n    const o = e[r];\n    t.push(...ye(o.accounts));\n  }), t;\n}\nfunction an(e, n = []) {\n  const t = [];\n  return Object.keys(e).forEach(r => {\n    if (n.length && !n.includes(r)) return;\n    const o = e[r];\n    t.push(...o.chains);\n  }), t;\n}\nconst k = \"base10\",\n  a = \"base16\",\n  R = \"base64pad\",\n  C = \"utf8\",\n  L = 0,\n  O = 1,\n  un = 0,\n  Ee = 1,\n  F = 12,\n  H = 32;\nfunction dn() {\n  const e = se.generateKeyPair();\n  return {\n    privateKey: f(e.secretKey, a),\n    publicKey: f(e.publicKey, a)\n  };\n}\nfunction ln() {\n  const e = re(H);\n  return f(e, a);\n}\nfunction fn(e, n) {\n  const t = se.sharedKey(p(e, a), p(n, a)),\n    r = new We(Qe, t).expand(H);\n  return f(r, a);\n}\nfunction pn(e) {\n  const n = oe(p(e, a));\n  return f(n, a);\n}\nfunction mn(e) {\n  const n = oe(p(e, C));\n  return f(n, a);\n}\nfunction he(e) {\n  return p(`${e}`, k);\n}\nfunction T(e) {\n  return Number(f(e, k));\n}\nfunction yn(e) {\n  const n = he(typeof e.type < \"u\" ? e.type : L);\n  if (T(n) === O && typeof e.senderPublicKey > \"u\") throw new Error(\"Missing sender public key for type 1 envelope\");\n  const t = typeof e.senderPublicKey < \"u\" ? p(e.senderPublicKey, a) : void 0,\n    r = typeof e.iv < \"u\" ? p(e.iv, a) : re(F),\n    o = new te(p(e.symKey, a)).seal(r, p(e.message, C));\n  return Ne({\n    type: n,\n    sealed: o,\n    iv: r,\n    senderPublicKey: t\n  });\n}\nfunction En(e) {\n  const n = new te(p(e.symKey, a)),\n    {\n      sealed: t,\n      iv: r\n    } = q(e.encoded),\n    o = n.open(r, t);\n  if (o === null) throw new Error(\"Failed to decrypt\");\n  return f(o, C);\n}\nfunction Ne(e) {\n  if (T(e.type) === O) {\n    if (typeof e.senderPublicKey > \"u\") throw new Error(\"Missing sender public key for type 1 envelope\");\n    return f(ie([e.type, e.senderPublicKey, e.iv, e.sealed]), R);\n  }\n  return f(ie([e.type, e.iv, e.sealed]), R);\n}\nfunction q(e) {\n  const n = p(e, R),\n    t = n.slice(un, Ee),\n    r = Ee;\n  if (T(t) === O) {\n    const c = r + H,\n      l = c + F,\n      h = n.slice(r, c),\n      g = n.slice(c, l),\n      P = n.slice(l);\n    return {\n      type: t,\n      sealed: P,\n      iv: g,\n      senderPublicKey: h\n    };\n  }\n  const o = r + F,\n    i = n.slice(r, o),\n    s = n.slice(o);\n  return {\n    type: t,\n    sealed: s,\n    iv: i\n  };\n}\nfunction hn(e, n) {\n  const t = q(e);\n  return ge({\n    type: T(t.type),\n    senderPublicKey: typeof t.senderPublicKey < \"u\" ? f(t.senderPublicKey, a) : void 0,\n    receiverPublicKey: n?.receiverPublicKey\n  });\n}\nfunction ge(e) {\n  const n = e?.type || L;\n  if (n === O) {\n    if (typeof e?.senderPublicKey > \"u\") throw new Error(\"missing sender public key\");\n    if (typeof e?.receiverPublicKey > \"u\") throw new Error(\"missing receiver public key\");\n  }\n  return {\n    type: n,\n    senderPublicKey: e?.senderPublicKey,\n    receiverPublicKey: e?.receiverPublicKey\n  };\n}\nfunction Nn(e) {\n  return e.type === O && typeof e.senderPublicKey == \"string\" && typeof e.receiverPublicKey == \"string\";\n}\nvar gn = Object.defineProperty,\n  ve = Object.getOwnPropertySymbols,\n  vn = Object.prototype.hasOwnProperty,\n  bn = Object.prototype.propertyIsEnumerable,\n  be = (e, n, t) => n in e ? gn(e, n, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: t\n  }) : e[n] = t,\n  Oe = (e, n) => {\n    for (var t in n || (n = {})) vn.call(n, t) && be(e, t, n[t]);\n    if (ve) for (var t of ve(n)) bn.call(n, t) && be(e, t, n[t]);\n    return e;\n  };\nconst Se = \"ReactNative\",\n  S = {\n    reactNative: \"react-native\",\n    node: \"node\",\n    browser: \"browser\",\n    unknown: \"unknown\"\n  },\n  w = \" \",\n  On = \":\",\n  Ie = \"/\",\n  G = 2,\n  Sn = 1e3,\n  Pe = \"js\";\nfunction B() {\n  return typeof process < \"u\" && typeof process.versions < \"u\" && typeof process.versions.node < \"u\";\n}\nfunction Te() {\n  return !en() && !!ae() && navigator.product === Se;\n}\nfunction _e() {\n  return !B() && !!ae();\n}\nfunction z() {\n  return Te() ? S.reactNative : B() ? S.node : _e() ? S.browser : S.unknown;\n}\nfunction Ue(e, n) {\n  let t = U.parse(e);\n  return t = Oe(Oe({}, t), n), e = U.stringify(t), e;\n}\nfunction In() {\n  return nn() || {\n    name: \"\",\n    description: \"\",\n    url: \"\",\n    icons: [\"\"]\n  };\n}\nfunction Pn(e, n) {\n  var t;\n  const r = z(),\n    o = {\n      protocol: e,\n      version: n,\n      env: r\n    };\n  return r === \"browser\" && (o.host = ((t = ue()) == null ? void 0 : t.host) || \"unknown\"), o;\n}\nfunction Ae() {\n  const e = Ze();\n  if (e === null) return \"unknown\";\n  const n = e.os ? e.os.replace(\" \", \"\").toLowerCase() : \"unknown\";\n  return e.type === \"browser\" ? [n, e.name, e.version].join(\"-\") : [n, e.version].join(\"-\");\n}\nfunction Re() {\n  var e;\n  const n = z();\n  return n === S.browser ? [n, ((e = ue()) == null ? void 0 : e.host) || \"unknown\"].join(\":\") : n;\n}\nfunction Ce(e, n, t) {\n  const r = Ae(),\n    o = Re();\n  return [[e, n].join(\"-\"), [Pe, t].join(\"-\"), r, o].join(\"/\");\n}\nfunction Tn({\n  protocol: e,\n  version: n,\n  relayUrl: t,\n  sdkVersion: r,\n  auth: o,\n  projectId: i\n}) {\n  const s = t.split(\"?\"),\n    c = Ce(e, n, r),\n    l = {\n      auth: o,\n      ua: c,\n      projectId: i\n    },\n    h = Ue(s[1] || \"\", l);\n  return s[0] + \"?\" + h;\n}\nfunction _n(e) {\n  let n = (e.match(/^[^:]+(?=:\\/\\/)/gi) || [])[0];\n  const t = typeof n < \"u\" ? e.split(\"://\")[1] : e;\n  return n = n === \"wss\" ? \"https\" : \"http\", [n, t].join(\"://\");\n}\nfunction Un(e, n, t) {\n  if (!e[n] || typeof e[n] !== t) throw new Error(`Missing or invalid \"${n}\" param`);\n}\nfunction we(e, n = G) {\n  return De(e.split(Ie), n);\n}\nfunction An(e) {\n  return we(e).join(w);\n}\nfunction u(e, n) {\n  return e.filter(t => n.includes(t)).length === e.length;\n}\nfunction De(e, n = G) {\n  return e.slice(Math.max(e.length - n, 0));\n}\nfunction Rn(e) {\n  return Object.fromEntries(e.entries());\n}\nfunction Cn(e) {\n  return new Map(Object.entries(e));\n}\nfunction wn(e, n) {\n  const t = {};\n  return Object.keys(e).forEach(r => {\n    t[r] = n(e[r]);\n  }), t;\n}\nconst Dn = e => e;\nfunction $e(e) {\n  return e.trim().replace(/^\\w/, n => n.toUpperCase());\n}\nfunction $n(e) {\n  return e.split(w).map(n => $e(n)).join(w);\n}\nfunction jn(e, n) {\n  return ce((n || Date.now()) + V(e));\n}\nfunction xn(e) {\n  return ce(Date.now()) >= V(e);\n}\nfunction Vn() {\n  const e = V(Xe);\n  let n, t, r;\n  return {\n    resolve: o => {\n      r && n && (clearTimeout(r), n(o));\n    },\n    reject: o => {\n      r && t && (clearTimeout(r), t(o));\n    },\n    done: () => new Promise((o, i) => {\n      r = setTimeout(i, e), n = o, t = i;\n    })\n  };\n}\nfunction Y(e, n) {\n  if (typeof n == \"string\" && n.startsWith(`${e}:`)) return n;\n  if (e.toLowerCase() === \"topic\") {\n    if (typeof n != \"string\") throw new Error('Value must be \"string\" for expirer target type: topic');\n    return `topic:${n}`;\n  } else if (e.toLowerCase() === \"id\") {\n    if (typeof n != \"number\") throw new Error('Value must be \"number\" for expirer target type: id');\n    return `id:${n}`;\n  }\n  throw new Error(`Unknown expirer target type: ${e}`);\n}\nfunction Mn(e) {\n  return Y(\"topic\", e);\n}\nfunction Kn(e) {\n  return Y(\"id\", e);\n}\nfunction kn(e) {\n  const [n, t] = e.split(\":\"),\n    r = {\n      id: void 0,\n      topic: void 0\n    };\n  if (n === \"topic\" && typeof t == \"string\") r.topic = t;else if (n === \"id\" && Number.isInteger(Number(t))) r.id = Number(t);else throw new Error(`Invalid target, expected id:number or topic:string, got ${n}:${t}`);\n  return r;\n}\nfunction Ln(e, n) {\n  return `${e}${n ? `:${n}` : \"\"}`;\n}\nconst je = \"irn\";\nfunction Fn(e) {\n  return e?.relay || {\n    protocol: je\n  };\n}\nfunction Hn(e) {\n  const n = tn[e];\n  if (typeof n > \"u\") throw new Error(`Relay Protocol not supported: ${e}`);\n  return n;\n}\nvar qn = Object.defineProperty,\n  xe = Object.getOwnPropertySymbols,\n  Gn = Object.prototype.hasOwnProperty,\n  Bn = Object.prototype.propertyIsEnumerable,\n  Ve = (e, n, t) => n in e ? qn(e, n, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: t\n  }) : e[n] = t,\n  zn = (e, n) => {\n    for (var t in n || (n = {})) Gn.call(n, t) && Ve(e, t, n[t]);\n    if (xe) for (var t of xe(n)) Bn.call(n, t) && Ve(e, t, n[t]);\n    return e;\n  };\nfunction Me(e, n = \"-\") {\n  const t = {},\n    r = \"relay\" + n;\n  return Object.keys(e).forEach(o => {\n    if (o.startsWith(r)) {\n      const i = o.replace(r, \"\"),\n        s = e[o];\n      t[i] = s;\n    }\n  }), t;\n}\nfunction Yn(e) {\n  const n = e.indexOf(\":\"),\n    t = e.indexOf(\"?\") !== -1 ? e.indexOf(\"?\") : void 0,\n    r = e.substring(0, n),\n    o = e.substring(n + 1, t).split(\"@\"),\n    i = typeof t < \"u\" ? e.substring(t) : \"\",\n    s = U.parse(i);\n  return {\n    protocol: r,\n    topic: o[0],\n    version: parseInt(o[1], 10),\n    symKey: s.symKey,\n    relay: Me(s)\n  };\n}\nfunction Ke(e, n = \"-\") {\n  const t = \"relay\",\n    r = {};\n  return Object.keys(e).forEach(o => {\n    const i = t + n + o;\n    e[o] && (r[i] = e[o]);\n  }), r;\n}\nfunction Jn(e) {\n  return `${e.protocol}:${e.topic}@${e.version}?` + U.stringify(zn({\n    symKey: e.symKey\n  }, Ke(e.relay)));\n}\nfunction m(e) {\n  const n = [];\n  return e.forEach(t => {\n    const [r, o] = t.split(\":\");\n    n.push(`${r}:${o}`);\n  }), n;\n}\nfunction ke(e) {\n  const n = [];\n  return Object.values(e).forEach(t => {\n    n.push(...m(t.accounts)), t.extension && t.extension.forEach(r => {\n      n.push(...m(r.accounts));\n    });\n  }), n;\n}\nfunction Le(e, n) {\n  const t = [];\n  return Object.values(e).forEach(r => {\n    m(r.accounts).includes(n) && t.push(...r.methods), r.extension && r.extension.forEach(o => {\n      m(o.accounts).includes(n) && t.push(...o.methods);\n    });\n  }), t;\n}\nfunction Fe(e, n) {\n  const t = [];\n  return Object.values(e).forEach(r => {\n    m(r.accounts).includes(n) && t.push(...r.events), r.extension && r.extension.forEach(o => {\n      m(o.accounts).includes(n) && t.push(...o.events);\n    });\n  }), t;\n}\nconst Wn = {\n    INVALID_METHOD: {\n      message: \"Invalid method.\",\n      code: 1001\n    },\n    INVALID_EVENT: {\n      message: \"Invalid event.\",\n      code: 1002\n    },\n    INVALID_UPDATE_REQUEST: {\n      message: \"Invalid update request.\",\n      code: 1003\n    },\n    INVALID_EXTEND_REQUEST: {\n      message: \"Invalid extend request.\",\n      code: 1004\n    },\n    INVALID_SESSION_SETTLE_REQUEST: {\n      message: \"Invalid session settle request.\",\n      code: 1005\n    },\n    UNAUTHORIZED_METHOD: {\n      message: \"Unauthorized method.\",\n      code: 3001\n    },\n    UNAUTHORIZED_EVENT: {\n      message: \"Unauthorized event.\",\n      code: 3002\n    },\n    UNAUTHORIZED_UPDATE_REQUEST: {\n      message: \"Unauthorized update request.\",\n      code: 3003\n    },\n    UNAUTHORIZED_EXTEND_REQUEST: {\n      message: \"Unauthorized extend request.\",\n      code: 3004\n    },\n    USER_REJECTED: {\n      message: \"User rejected.\",\n      code: 5e3\n    },\n    USER_REJECTED_CHAINS: {\n      message: \"User rejected chains.\",\n      code: 5001\n    },\n    USER_REJECTED_METHODS: {\n      message: \"User rejected methods.\",\n      code: 5002\n    },\n    USER_REJECTED_EVENTS: {\n      message: \"User rejected events.\",\n      code: 5003\n    },\n    UNSUPPORTED_CHAINS: {\n      message: \"Unsupported chains.\",\n      code: 5100\n    },\n    UNSUPPORTED_METHODS: {\n      message: \"Unsupported methods.\",\n      code: 5101\n    },\n    UNSUPPORTED_EVENTS: {\n      message: \"Unsupported events.\",\n      code: 5102\n    },\n    UNSUPPORTED_ACCOUNTS: {\n      message: \"Unsupported accounts.\",\n      code: 5103\n    },\n    UNSUPPORTED_NAMESPACE_KEY: {\n      message: \"Unsupported namespace key.\",\n      code: 5104\n    },\n    USER_DISCONNECTED: {\n      message: \"User disconnected.\",\n      code: 6e3\n    },\n    SESSION_SETTLEMENT_FAILED: {\n      message: \"Session settlement failed.\",\n      code: 7e3\n    }\n  },\n  Qn = {\n    NOT_INITIALIZED: {\n      message: \"Not initialized.\",\n      code: 1\n    },\n    NO_MATCHING_KEY: {\n      message: \"No matching key.\",\n      code: 2\n    },\n    RESTORE_WILL_OVERRIDE: {\n      message: \"Restore will override.\",\n      code: 3\n    },\n    RESUBSCRIBED: {\n      message: \"Resubscribed.\",\n      code: 4\n    },\n    MISSING_OR_INVALID: {\n      message: \"Missing or invalid.\",\n      code: 5\n    },\n    EXPIRED: {\n      message: \"Expired.\",\n      code: 6\n    },\n    UNKNOWN_TYPE: {\n      message: \"Unknown type.\",\n      code: 7\n    },\n    MISMATCHED_TOPIC: {\n      message: \"Mismatched topic.\",\n      code: 8\n    },\n    NON_CONFORMING_NAMESPACES: {\n      message: \"Non conforming namespaces.\",\n      code: 9\n    }\n  };\nfunction y(e, n) {\n  const {\n    message: t,\n    code: r\n  } = Qn[e];\n  return {\n    message: n ? `${t} ${n}` : t,\n    code: r\n  };\n}\nfunction N(e, n) {\n  const {\n    message: t,\n    code: r\n  } = Wn[e];\n  return {\n    message: n ? `${t} ${n}` : t,\n    code: r\n  };\n}\nfunction I(e, n) {\n  return Array.isArray(e) ? typeof n < \"u\" && e.length ? e.every(n) : !0 : !1;\n}\nfunction J(e) {\n  return Object.getPrototypeOf(e) === Object.prototype && Object.keys(e).length;\n}\nfunction E(e) {\n  return typeof e > \"u\";\n}\nfunction d(e, n) {\n  return n && E(e) ? !0 : typeof e == \"string\" && Boolean(e.trim().length);\n}\nfunction W(e, n) {\n  return n && E(e) ? !0 : typeof e == \"number\" && !isNaN(e);\n}\nfunction Zn(e, n) {\n  const {\n      requiredNamespaces: t\n    } = n,\n    r = Object.keys(e.namespaces),\n    o = Object.keys(t);\n  let i = !0;\n  return u(o, r) ? (r.forEach(s => {\n    const {\n        accounts: c,\n        methods: l,\n        events: h,\n        extension: g\n      } = e.namespaces[s],\n      P = m(c),\n      v = t[s];\n    (!u(v.chains, P) || !u(v.methods, l) || !u(v.events, h)) && (i = !1), i && g && g.forEach(_ => {\n      var b;\n      const {\n          accounts: j,\n          methods: ze,\n          events: Ye\n        } = _,\n        Je = m(j);\n      (b = v.extension) != null && b.find(x => u(x.chains, Je) && u(x.methods, ze) && u(x.events, Ye)) || (i = !1);\n    });\n  }), i) : !1;\n}\nfunction D(e) {\n  return d(e, !1) && e.includes(\":\") ? e.split(\":\").length === 2 : !1;\n}\nfunction He(e) {\n  if (d(e, !1) && e.includes(\":\")) {\n    const n = e.split(\":\");\n    if (n.length === 3) {\n      const t = n[0] + \":\" + n[1];\n      return !!n[2] && D(t);\n    }\n  }\n  return !1;\n}\nfunction Xn(e) {\n  if (d(e, !1)) try {\n    return typeof new URL(e) < \"u\";\n  } catch {\n    return !1;\n  }\n  return !1;\n}\nfunction et(e) {\n  var n;\n  return (n = e?.proposer) == null ? void 0 : n.publicKey;\n}\nfunction nt(e) {\n  return e?.topic;\n}\nfunction tt(e, n) {\n  let t = null;\n  return d(e?.publicKey, !1) || (t = y(\"MISSING_OR_INVALID\", `${n} controller public key should be a string`)), t;\n}\nfunction $(e, n) {\n  let t = null;\n  return E(e?.extension) || (!I(e.extension) || !e.extension.length) && (t = y(\"MISSING_OR_INVALID\", `${n} extension should be an array of namespaces, or omitted`)), t;\n}\nfunction Q(e) {\n  let n = !0;\n  return I(e) ? e.length && (n = e.every(t => d(t, !1))) : n = !1, n;\n}\nfunction Z(e, n, t) {\n  let r = null;\n  return I(n) ? n.forEach(o => {\n    r || (!D(o) || !o.includes(e)) && (r = N(\"UNSUPPORTED_CHAINS\", `${t}, chain ${o} should be a string and conform to \"namespace:chainId\" format`));\n  }) : r = N(\"UNSUPPORTED_CHAINS\", `${t}, chains ${n} should be an array of strings conforming to \"namespace:chainId\" format`), r;\n}\nfunction qe(e, n) {\n  let t = null;\n  return Object.entries(e).forEach(([r, o]) => {\n    if (t) return;\n    const i = Z(r, o?.chains, `${n} requiredNamespace`),\n      s = $(o, n);\n    i ? t = i : s ? t = s : o.extension && o.extension.forEach(c => {\n      if (t) return;\n      const l = Z(r, c.chains, `${n} extension`);\n      l && (t = l);\n    });\n  }), t;\n}\nfunction X(e, n) {\n  let t = null;\n  return I(e) ? e.forEach(r => {\n    t || He(r) || (t = N(\"UNSUPPORTED_ACCOUNTS\", `${n}, account ${r} should be a string and conform to \"namespace:chainId:address\" format`));\n  }) : t = N(\"UNSUPPORTED_ACCOUNTS\", `${n}, accounts should be an array of strings conforming to \"namespace:chainId:address\" format`), t;\n}\nfunction Ge(e, n) {\n  let t = null;\n  return Object.values(e).forEach(r => {\n    if (t) return;\n    const o = X(r?.accounts, `${n} namespace`),\n      i = $(r, n);\n    o ? t = o : i ? t = i : r.extension && r.extension.forEach(s => {\n      if (t) return;\n      const c = X(s.accounts, `${n} extension`);\n      c && (t = c);\n    });\n  }), t;\n}\nfunction ee(e, n) {\n  let t = null;\n  return Q(e?.methods) ? Q(e?.events) || (t = N(\"UNSUPPORTED_EVENTS\", `${n}, events should be an array of strings or empty array for no events`)) : t = N(\"UNSUPPORTED_METHODS\", `${n}, methods should be an array of strings or empty array for no methods`), t;\n}\nfunction ne(e, n) {\n  let t = null;\n  return Object.values(e).forEach(r => {\n    if (t) return;\n    const o = ee(r, `${n}, namespace`),\n      i = $(r, n);\n    o ? t = o : i ? t = i : r.extension && r.extension.forEach(s => {\n      if (t) return;\n      const c = ee(s, `${n}, extension`);\n      c && (t = c);\n    });\n  }), t;\n}\nfunction rt(e, n) {\n  let t = null;\n  if (e && J(e)) {\n    const r = ne(e, n);\n    r && (t = r);\n    const o = qe(e, n);\n    o && (t = o);\n  } else t = y(\"MISSING_OR_INVALID\", `${n}, requiredNamespaces should be an object with data`);\n  return t;\n}\nfunction ot(e, n) {\n  let t = null;\n  if (e && J(e)) {\n    const r = ne(e, n);\n    r && (t = r);\n    const o = Ge(e, n);\n    o && (t = o);\n  } else t = y(\"MISSING_OR_INVALID\", `${n}, namespaces should be an object with data`);\n  return t;\n}\nfunction Be(e) {\n  return d(e.protocol, !0);\n}\nfunction st(e, n) {\n  let t = !1;\n  return n && !e ? t = !0 : e && I(e) && e.length && e.forEach(r => {\n    t = Be(r);\n  }), t;\n}\nfunction it(e) {\n  return typeof e == \"number\";\n}\nfunction ct(e) {\n  return typeof e < \"u\" && typeof e !== null;\n}\nfunction at(e) {\n  return !(!e || typeof e != \"object\" || !e.code || !W(e.code, !1) || !e.message || !d(e.message, !1));\n}\nfunction ut(e) {\n  return !(E(e) || !d(e.method, !1));\n}\nfunction dt(e) {\n  return !(E(e) || E(e.result) && E(e.error) || !W(e.id, !1) || !d(e.jsonrpc, !1));\n}\nfunction lt(e) {\n  return !(E(e) || !d(e.name, !1));\n}\nfunction ft(e, n) {\n  return !(!D(n) || !ke(e).includes(n));\n}\nfunction pt(e, n, t) {\n  return d(t, !1) ? Le(e, n).includes(t) : !1;\n}\nfunction mt(e, n, t) {\n  return d(t, !1) ? Fe(e, n).includes(t) : !1;\n}\nfunction yt(e, n, t) {\n  let r = null;\n  const o = Object.keys(e),\n    i = Object.keys(n);\n  return u(o, i) ? o.forEach(s => {\n    var c;\n    if (r) return;\n    const l = e[s].chains,\n      h = m(n[s].accounts);\n    u(l, h) ? u(e[s].methods, n[s].methods) ? u(e[s].events, n[s].events) ? e[s].extension && !n[s].extension ? r = y(\"NON_CONFORMING_NAMESPACES\", `${t} namespaces extension doesn't satisfy requiredNamespaces extension for ${s}`) : e[s].extension && n[s].extension && ((c = e[s].extension) == null || c.forEach(({\n      methods: g,\n      events: P,\n      chains: v\n    }) => {\n      var _;\n      r || (_ = n[s].extension) != null && _.find(b => {\n        const j = m(b.accounts);\n        return u(v, j) && u(P, b.events) && u(g, b.methods);\n      }) || (r = y(\"NON_CONFORMING_NAMESPACES\", `${t} namespaces extension doesn't satisfy requiredNamespaces extension for ${s}`));\n    })) : r = y(\"NON_CONFORMING_NAMESPACES\", `${t} namespaces events don't satisfy requiredNamespaces events for ${s}`) : r = y(\"NON_CONFORMING_NAMESPACES\", `${t} namespaces methods don't satisfy requiredNamespaces methods for ${s}`) : r = y(\"NON_CONFORMING_NAMESPACES\", `${t} namespaces accounts don't satisfy requiredNamespaces chains for ${s}`);\n  }) : r = y(\"NON_CONFORMING_NAMESPACES\", `${t} namespaces keys don't satisfy requiredNamespaces`), r;\n}\nexport { k as BASE10, a as BASE16, R as BASE64, On as COLON, G as DEFAULT_DEPTH, w as EMPTY_SPACE, S as ENV_MAP, Sn as ONE_THOUSAND, Se as REACT_NATIVE_PRODUCT, je as RELAYER_DEFAULT_PROTOCOL, Pe as SDK_TYPE, Ie as SLASH, L as TYPE_0, O as TYPE_1, C as UTF8, Ue as appendToQueryString, Un as assertType, jn as calcExpiry, $n as capitalize, $e as capitalizeWord, Vn as createDelayedPromise, T as decodeTypeByte, En as decrypt, fn as deriveSymKey, q as deserialize, he as encodeTypeByte, yn as encrypt, Ln as engineEvent, Dn as enumify, fe as formatAccountId, rn as formatAccountWithChain, le as formatChainId, Y as formatExpirerTarget, Kn as formatIdTarget, An as formatMessageContext, Ke as formatRelayParams, Tn as formatRelayRpcUrl, Mn as formatTopicTarget, Ce as formatUA, Jn as formatUri, dn as generateKeyPair, ln as generateRandomBytes32, m as getAccountsChains, sn as getAccountsFromNamespaces, pe as getAddressFromAccount, on as getAddressesFromAccounts, In as getAppMetadata, me as getChainFromAccount, ye as getChainsFromAccounts, cn as getChainsFromNamespaces, an as getChainsFromRequiredNamespaces, z as getEnvironment, _n as getHttpUrl, y as getInternalError, Re as getJavascriptID, Ae as getJavascriptOS, De as getLastItems, ke as getNamespacesChains, Fe as getNamespacesEventsForChainId, Le as getNamespacesMethodsForChainId, Pn as getRelayClientMetadata, Hn as getRelayProtocolApi, Fn as getRelayProtocolName, N as getSdkError, K as getUniqueValues, u as hasOverlap, pn as hashKey, mn as hashMessage, _e as isBrowser, yt as isConformingNamespaces, xn as isExpired, B as isNode, et as isProposalStruct, Te as isReactNative, Zn as isSessionCompatible, nt as isSessionStruct, Nn as isTypeOneEnvelope, E as isUndefined, He as isValidAccountId, X as isValidAccounts, ee as isValidActions, I as isValidArray, D as isValidChainId, Z as isValidChains, tt as isValidController, at as isValidErrorReason, lt as isValidEvent, $ as isValidExtension, it as isValidId, Ge as isValidNamespaceAccounts, ne as isValidNamespaceActions, qe as isValidNamespaceChains, Q as isValidNamespaceMethodsOrEvents, ot as isValidNamespaces, ft as isValidNamespacesChainId, mt as isValidNamespacesEvent, pt as isValidNamespacesRequest, W as isValidNumber, J as isValidObject, ct as isValidParams, Be as isValidRelay, st as isValidRelays, ut as isValidRequest, rt as isValidRequiredNamespaces, dt as isValidResponse, d as isValidString, Xn as isValidUrl, wn as mapEntries, Rn as mapToObj, Cn as objToMap, M as parseAccountId, de as parseChainId, we as parseContextNames, kn as parseExpirerTarget, Me as parseRelayParams, Yn as parseUri, Ne as serialize, hn as validateDecoding, ge as validateEncoding };","map":{"version":3,"names":[],"sources":["C:\\Users\\user\\Desktop\\BCEndterm\\node_modules\\@walletconnect\\utils\\src\\caip.ts","C:\\Users\\user\\Desktop\\BCEndterm\\node_modules\\@walletconnect\\utils\\src\\crypto.ts","C:\\Users\\user\\Desktop\\BCEndterm\\node_modules\\@walletconnect\\utils\\src\\misc.ts","C:\\Users\\user\\Desktop\\BCEndterm\\node_modules\\@walletconnect\\utils\\src\\relay.ts","C:\\Users\\user\\Desktop\\BCEndterm\\node_modules\\@walletconnect\\utils\\src\\uri.ts","C:\\Users\\user\\Desktop\\BCEndterm\\node_modules\\@walletconnect\\utils\\src\\namespaces.ts","C:\\Users\\user\\Desktop\\BCEndterm\\node_modules\\@walletconnect\\utils\\src\\errors.ts","C:\\Users\\user\\Desktop\\BCEndterm\\node_modules\\@walletconnect\\utils\\src\\validators.ts"],"sourcesContent":["import { SessionTypes, ProposalTypes } from \"@walletconnect/types\";\n\ninterface ChainIdParams {\n  namespace: string;\n  reference: string;\n}\n\ninterface AccountIdParams extends ChainIdParams {\n  address: string;\n}\n\nconst CAIP_DELIMITER = \":\";\n\nexport function parseChainId(chain: string): ChainIdParams {\n  const [namespace, reference] = chain.split(CAIP_DELIMITER);\n  return { namespace, reference };\n}\n\nexport function formatChainId(params: ChainIdParams): string {\n  const { namespace, reference } = params;\n  return [namespace, reference].join(CAIP_DELIMITER);\n}\n\nexport function parseAccountId(account: string): AccountIdParams {\n  const [namespace, reference, address] = account.split(CAIP_DELIMITER);\n  return { namespace, reference, address };\n}\n\nexport function formatAccountId(params: AccountIdParams): string {\n  const { namespace, reference, address } = params;\n  return [namespace, reference, address].join(CAIP_DELIMITER);\n}\n\nexport function getUniqueValues(array: string[], parser: (str: string) => string): string[] {\n  const unique: string[] = [];\n  array.forEach((str) => {\n    const value = parser(str);\n    if (!unique.includes(value)) unique.push(value);\n  });\n  return unique;\n}\n\nexport function getAddressFromAccount(account: string) {\n  const { address } = parseAccountId(account);\n  return address;\n}\n\nexport function getChainFromAccount(account: string) {\n  const { namespace, reference } = parseAccountId(account);\n  const chain = formatChainId({ namespace, reference });\n  return chain;\n}\n\nexport function formatAccountWithChain(address: string, chain: string) {\n  const { namespace, reference } = parseChainId(chain);\n  const account = formatAccountId({ namespace, reference, address });\n  return account;\n}\n\nexport function getAddressesFromAccounts(accounts: string[]) {\n  return getUniqueValues(accounts, getAddressFromAccount);\n}\n\nexport function getChainsFromAccounts(accounts: string[]) {\n  return getUniqueValues(accounts, getChainFromAccount);\n}\n\nexport function getAccountsFromNamespaces(\n  namespaces: SessionTypes.Namespaces,\n  keys: string[] = [],\n): string[] {\n  const accounts: string[] = [];\n  Object.keys(namespaces).forEach((key) => {\n    if (keys.length && !keys.includes(key)) return;\n    const ns = namespaces[key];\n    accounts.push(...ns.accounts);\n  });\n  return accounts;\n}\n\nexport function getChainsFromNamespaces(\n  namespaces: SessionTypes.Namespaces,\n  keys: string[] = [],\n): string[] {\n  const chains: string[] = [];\n  Object.keys(namespaces).forEach((key) => {\n    if (keys.length && !keys.includes(key)) return;\n    const ns = namespaces[key];\n    chains.push(...getChainsFromAccounts(ns.accounts));\n  });\n  return chains;\n}\n\nexport function getChainsFromRequiredNamespaces(\n  requiredNamespaces: ProposalTypes.RequiredNamespaces,\n  keys: string[] = [],\n): string[] {\n  const chains: string[] = [];\n  Object.keys(requiredNamespaces).forEach((key) => {\n    if (keys.length && !keys.includes(key)) return;\n    const ns = requiredNamespaces[key];\n    chains.push(...ns.chains);\n  });\n  return chains;\n}\n","import { ChaCha20Poly1305 } from \"@stablelib/chacha20poly1305\";\nimport { HKDF } from \"@stablelib/hkdf\";\nimport { randomBytes } from \"@stablelib/random\";\nimport { hash, SHA256 } from \"@stablelib/sha256\";\nimport * as x25519 from \"@stablelib/x25519\";\nimport { CryptoTypes } from \"@walletconnect/types\";\nimport { concat, fromString, toString } from \"uint8arrays\";\n\nexport const BASE10 = \"base10\";\nexport const BASE16 = \"base16\";\nexport const BASE64 = \"base64pad\";\nexport const UTF8 = \"utf8\";\n\nexport const TYPE_0 = 0;\nexport const TYPE_1 = 1;\n\nconst ZERO_INDEX = 0;\nconst TYPE_LENGTH = 1;\nconst IV_LENGTH = 12;\nconst KEY_LENGTH = 32;\n\nexport function generateKeyPair(): CryptoTypes.KeyPair {\n  const keyPair = x25519.generateKeyPair();\n  return {\n    privateKey: toString(keyPair.secretKey, BASE16),\n    publicKey: toString(keyPair.publicKey, BASE16),\n  };\n}\n\nexport function generateRandomBytes32(): string {\n  const random = randomBytes(KEY_LENGTH);\n  return toString(random, BASE16);\n}\n\nexport function deriveSymKey(privateKeyA: string, publicKeyB: string): string {\n  const sharedKey = x25519.sharedKey(\n    fromString(privateKeyA, BASE16),\n    fromString(publicKeyB, BASE16),\n  );\n  const hkdf = new HKDF(SHA256, sharedKey);\n  const symKey = hkdf.expand(KEY_LENGTH);\n  return toString(symKey, BASE16);\n}\n\nexport function hashKey(key: string): string {\n  const result = hash(fromString(key, BASE16));\n  return toString(result, BASE16);\n}\n\nexport function hashMessage(message: string): string {\n  const result = hash(fromString(message, UTF8));\n  return toString(result, BASE16);\n}\n\nexport function encodeTypeByte(type: number): Uint8Array {\n  return fromString(`${type}`, BASE10);\n}\n\nexport function decodeTypeByte(byte: Uint8Array): number {\n  return Number(toString(byte, BASE10));\n}\n\nexport function encrypt(params: CryptoTypes.EncryptParams): string {\n  const type = encodeTypeByte(typeof params.type !== \"undefined\" ? params.type : TYPE_0);\n  if (decodeTypeByte(type) === TYPE_1 && typeof params.senderPublicKey === \"undefined\") {\n    throw new Error(\"Missing sender public key for type 1 envelope\");\n  }\n  const senderPublicKey =\n    typeof params.senderPublicKey !== \"undefined\"\n      ? fromString(params.senderPublicKey, BASE16)\n      : undefined;\n\n  const iv =\n    typeof params.iv !== \"undefined\" ? fromString(params.iv, BASE16) : randomBytes(IV_LENGTH);\n  const box = new ChaCha20Poly1305(fromString(params.symKey, BASE16));\n  const sealed = box.seal(iv, fromString(params.message, UTF8));\n  return serialize({ type, sealed, iv, senderPublicKey });\n}\n\nexport function decrypt(params: CryptoTypes.DecryptParams): string {\n  const box = new ChaCha20Poly1305(fromString(params.symKey, BASE16));\n  const { sealed, iv } = deserialize(params.encoded);\n  const message = box.open(iv, sealed);\n  if (message === null) throw new Error(\"Failed to decrypt\");\n  return toString(message, UTF8);\n}\n\nexport function serialize(params: CryptoTypes.EncodingParams): string {\n  if (decodeTypeByte(params.type) === TYPE_1) {\n    if (typeof params.senderPublicKey === \"undefined\") {\n      throw new Error(\"Missing sender public key for type 1 envelope\");\n    }\n    return toString(\n      concat([params.type, params.senderPublicKey, params.iv, params.sealed]),\n      BASE64,\n    );\n  }\n  // default to type 0 envelope\n  return toString(concat([params.type, params.iv, params.sealed]), BASE64);\n}\n\nexport function deserialize(encoded: string): CryptoTypes.EncodingParams {\n  const bytes = fromString(encoded, BASE64);\n  const type = bytes.slice(ZERO_INDEX, TYPE_LENGTH);\n  const slice1 = TYPE_LENGTH;\n  if (decodeTypeByte(type) === TYPE_1) {\n    const slice2 = slice1 + KEY_LENGTH;\n    const slice3 = slice2 + IV_LENGTH;\n    const senderPublicKey = bytes.slice(slice1, slice2);\n    const iv = bytes.slice(slice2, slice3);\n    const sealed = bytes.slice(slice3);\n    return { type, sealed, iv, senderPublicKey };\n  }\n  // default to type 0 envelope\n  const slice2 = slice1 + IV_LENGTH;\n  const iv = bytes.slice(slice1, slice2);\n  const sealed = bytes.slice(slice2);\n  return { type, sealed, iv };\n}\n\nexport function validateDecoding(\n  encoded: string,\n  opts?: CryptoTypes.DecodeOptions,\n): CryptoTypes.EncodingValidation {\n  const deserialized = deserialize(encoded);\n  return validateEncoding({\n    type: decodeTypeByte(deserialized.type),\n    senderPublicKey:\n      typeof deserialized.senderPublicKey !== \"undefined\"\n        ? toString(deserialized.senderPublicKey, BASE16)\n        : undefined,\n    receiverPublicKey: opts?.receiverPublicKey,\n  });\n}\n\nexport function validateEncoding(opts?: CryptoTypes.EncodeOptions): CryptoTypes.EncodingValidation {\n  const type = opts?.type || TYPE_0;\n  if (type === TYPE_1) {\n    if (typeof opts?.senderPublicKey === \"undefined\") {\n      throw new Error(\"missing sender public key\");\n    }\n    if (typeof opts?.receiverPublicKey === \"undefined\") {\n      throw new Error(\"missing receiver public key\");\n    }\n  }\n  return {\n    type,\n    senderPublicKey: opts?.senderPublicKey,\n    receiverPublicKey: opts?.receiverPublicKey,\n  };\n}\n\nexport function isTypeOneEnvelope(\n  result: CryptoTypes.EncodingValidation,\n): result is CryptoTypes.TypeOneParams {\n  return (\n    result.type === TYPE_1 &&\n    typeof result.senderPublicKey === \"string\" &&\n    typeof result.receiverPublicKey === \"string\"\n  );\n}\n","import { detect } from \"detect-browser\";\nimport { FIVE_MINUTES, fromMiliseconds, toMiliseconds } from \"@walletconnect/time\";\nimport {\n  SignClientTypes,\n  RelayerClientMetadata,\n  EngineTypes,\n  RelayerTypes,\n} from \"@walletconnect/types\";\nimport { getDocument, getLocation, getNavigator } from \"@walletconnect/window-getters\";\nimport { getWindowMetadata } from \"@walletconnect/window-metadata\";\nimport { ErrorResponse } from \"@walletconnect/jsonrpc-utils\";\nimport * as qs from \"query-string\";\n\n// -- constants -----------------------------------------//\n\nexport const REACT_NATIVE_PRODUCT = \"ReactNative\";\n\nexport const ENV_MAP = {\n  reactNative: \"react-native\",\n  node: \"node\",\n  browser: \"browser\",\n  unknown: \"unknown\",\n};\n\nexport const EMPTY_SPACE = \" \";\n\nexport const COLON = \":\";\n\nexport const SLASH = \"/\";\n\nexport const DEFAULT_DEPTH = 2;\n\nexport const ONE_THOUSAND = 1000;\n\nexport const SDK_TYPE = \"js\";\n\n// -- env -----------------------------------------------//\n\nexport function isNode(): boolean {\n  return (\n    typeof process !== \"undefined\" &&\n    typeof process.versions !== \"undefined\" &&\n    typeof process.versions.node !== \"undefined\"\n  );\n}\n\nexport function isReactNative(): boolean {\n  return !getDocument() && !!getNavigator() && navigator.product === REACT_NATIVE_PRODUCT;\n}\n\nexport function isBrowser(): boolean {\n  return !isNode() && !!getNavigator();\n}\n\nexport function getEnvironment(): string {\n  if (isReactNative()) return ENV_MAP.reactNative;\n  if (isNode()) return ENV_MAP.node;\n  if (isBrowser()) return ENV_MAP.browser;\n  return ENV_MAP.unknown;\n}\n\n// -- query -----------------------------------------------//\n\nexport function appendToQueryString(queryString: string, newQueryParams: any): string {\n  let queryParams = qs.parse(queryString);\n\n  queryParams = { ...queryParams, ...newQueryParams };\n\n  queryString = qs.stringify(queryParams);\n\n  return queryString;\n}\n\n// -- metadata ----------------------------------------------//\n\nexport function getAppMetadata(): SignClientTypes.Metadata {\n  return (\n    getWindowMetadata() || {\n      name: \"\",\n      description: \"\",\n      url: \"\",\n      icons: [\"\"],\n    }\n  );\n}\n\nexport function getRelayClientMetadata(protocol: string, version: number): RelayerClientMetadata {\n  const env = getEnvironment();\n\n  const metadata: RelayerClientMetadata = { protocol, version, env };\n  if (env === \"browser\") {\n    metadata.host = getLocation()?.host || \"unknown\";\n  }\n  return metadata;\n}\n\n// -- rpcUrl ----------------------------------------------//\n\nexport function getJavascriptOS() {\n  const info = detect();\n  if (info === null) return \"unknown\";\n  const os = info.os ? info.os.replace(\" \", \"\").toLowerCase() : \"unknown\";\n  if (info.type === \"browser\") {\n    return [os, info.name, info.version].join(\"-\");\n  }\n  return [os, info.version].join(\"-\");\n}\n\nexport function getJavascriptID() {\n  const env = getEnvironment();\n  return env === ENV_MAP.browser ? [env, getLocation()?.host || \"unknown\"].join(\":\") : env;\n}\n\nexport function formatUA(protocol: string, version: number, sdkVersion: string) {\n  const os = getJavascriptOS();\n  const id = getJavascriptID();\n  return [[protocol, version].join(\"-\"), [SDK_TYPE, sdkVersion].join(\"-\"), os, id].join(\"/\");\n}\nconsole;\n\nexport function formatRelayRpcUrl({\n  protocol,\n  version,\n  relayUrl,\n  sdkVersion,\n  auth,\n  projectId,\n}: RelayerTypes.RpcUrlParams) {\n  const splitUrl = relayUrl.split(\"?\");\n  const ua = formatUA(protocol, version, sdkVersion);\n  const params = { auth, ua, projectId };\n  const queryString = appendToQueryString(splitUrl[1] || \"\", params);\n  return splitUrl[0] + \"?\" + queryString;\n}\n\nexport function getHttpUrl(url: string) {\n  // regex from https://stackoverflow.com/questions/3883871/regexp-to-grab-protocol-from-url\n  const matches = url.match(/^[^:]+(?=:\\/\\/)/gi) || [];\n  let protocol = matches[0];\n  const domain = typeof protocol !== \"undefined\" ? url.split(\"://\")[1] : url;\n  protocol = protocol === \"wss\" ? \"https\" : \"http\";\n  return [protocol, domain].join(\"://\");\n}\n\n// -- assert ------------------------------------------------- //\n\nexport function assertType(obj: any, key: string, type: string) {\n  if (!obj[key] || typeof obj[key] !== type) {\n    throw new Error(`Missing or invalid \"${key}\" param`);\n  }\n}\n\n// -- context ------------------------------------------------- //\n\nexport function parseContextNames(context: string, depth = DEFAULT_DEPTH) {\n  return getLastItems(context.split(SLASH), depth);\n}\n\nexport function formatMessageContext(context: string): string {\n  return parseContextNames(context).join(EMPTY_SPACE);\n}\n\n// -- array ------------------------------------------------- //\n\nexport function hasOverlap(a: any[], b: any[]): boolean {\n  const matches = a.filter((x) => b.includes(x));\n  return matches.length === a.length;\n}\n\nexport function getLastItems(arr: any[], depth = DEFAULT_DEPTH): any[] {\n  return arr.slice(Math.max(arr.length - depth, 0));\n}\n\n// -- map ------------------------------------------------- //\n\nexport function mapToObj<T = any>(map: Map<string, T>): Record<string, T> {\n  return Object.fromEntries(map.entries());\n}\n\nexport function objToMap<T = any>(obj: Record<string, T>): Map<string, T> {\n  return new Map<string, T>(Object.entries<T>(obj));\n}\n\nexport function mapEntries<A = any, B = any>(\n  obj: Record<string, A>,\n  cb: (x: A) => B,\n): Record<string, B> {\n  const res = {};\n  Object.keys(obj).forEach((key) => {\n    res[key] = cb(obj[key]);\n  });\n  return res;\n}\n\n// -- enum ------------------------------------------------- //\n\n// source: https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275\nexport const enumify = <T extends { [index: string]: U }, U extends string>(x: T): T => x;\n\n// -- string ------------------------------------------------- //\n\nexport function capitalizeWord(word: string) {\n  return word.trim().replace(/^\\w/, (c) => c.toUpperCase());\n}\n\nexport function capitalize(str: string) {\n  return str\n    .split(EMPTY_SPACE)\n    .map((w) => capitalizeWord(w))\n    .join(EMPTY_SPACE);\n}\n\n// -- time ------------------------------------------------- //\n\nexport function calcExpiry(ttl: number, now?: number): number {\n  return fromMiliseconds((now || Date.now()) + toMiliseconds(ttl));\n}\n\nexport function isExpired(expiry: number) {\n  return fromMiliseconds(Date.now()) >= toMiliseconds(expiry);\n}\n\n// -- promises --------------------------------------------- //\nexport function createDelayedPromise<T>() {\n  const timeout = toMiliseconds(FIVE_MINUTES);\n  let cacheResolve: undefined | ((value: T | PromiseLike<T>) => void);\n  let cacheReject: undefined | ((value?: ErrorResponse) => void);\n  let cacheTimeout: undefined | NodeJS.Timeout;\n\n  const done = () =>\n    new Promise<T>((promiseResolve, promiseReject) => {\n      cacheTimeout = setTimeout(promiseReject, timeout);\n      cacheResolve = promiseResolve;\n      cacheReject = promiseReject;\n    });\n  const resolve = (value?: T) => {\n    if (cacheTimeout && cacheResolve) {\n      clearTimeout(cacheTimeout);\n      cacheResolve(value as T);\n    }\n  };\n  const reject = (value?: ErrorResponse) => {\n    if (cacheTimeout && cacheReject) {\n      clearTimeout(cacheTimeout);\n      cacheReject(value);\n    }\n  };\n\n  return {\n    resolve,\n    reject,\n    done,\n  };\n}\n\n// -- expirer --------------------------------------------- //\n\nexport function formatExpirerTarget(type: \"topic\" | \"id\", value: string | number): string {\n  if (typeof value === \"string\" && value.startsWith(`${type}:`)) return value;\n  if (type.toLowerCase() === \"topic\") {\n    if (typeof value !== \"string\")\n      throw new Error(`Value must be \"string\" for expirer target type: topic`);\n    return `topic:${value}`;\n  } else if (type.toLowerCase() === \"id\") {\n    if (typeof value !== \"number\")\n      throw new Error(`Value must be \"number\" for expirer target type: id`);\n    return `id:${value}`;\n  }\n  throw new Error(`Unknown expirer target type: ${type}`);\n}\n\nexport function formatTopicTarget(topic: string): string {\n  return formatExpirerTarget(\"topic\", topic);\n}\n\nexport function formatIdTarget(id: number): string {\n  return formatExpirerTarget(\"id\", id);\n}\n\nexport function parseExpirerTarget(target: string) {\n  const [type, value] = target.split(\":\");\n  const parsed: { id?: number; topic?: string } = { id: undefined, topic: undefined };\n  if (type === \"topic\" && typeof value === \"string\") {\n    parsed.topic = value;\n  } else if (type === \"id\" && Number.isInteger(Number(value))) {\n    parsed.id = Number(value);\n  } else {\n    throw new Error(`Invalid target, expected id:number or topic:string, got ${type}:${value}`);\n  }\n\n  return parsed;\n}\n\n// -- events ---------------------------------------------- //\n\nexport function engineEvent(event: EngineTypes.Event, id?: number | string | undefined) {\n  return `${event}${id ? `:${id}` : \"\"}`;\n}\n","import { RELAY_JSONRPC } from \"@walletconnect/relay-api\";\nimport { RelayerTypes } from \"@walletconnect/types\";\n\nexport const RELAYER_DEFAULT_PROTOCOL = \"irn\";\n\nexport function getRelayProtocolName(\n  opts?: RelayerTypes.RequestOptions,\n): RelayerTypes.ProtocolOptions {\n  return opts?.relay || { protocol: RELAYER_DEFAULT_PROTOCOL };\n}\n\nexport function getRelayProtocolApi(protocol: string) {\n  const jsonrpc = RELAY_JSONRPC[protocol];\n  if (typeof jsonrpc === \"undefined\") {\n    throw new Error(`Relay Protocol not supported: ${protocol}`);\n  }\n  return jsonrpc;\n}\n","import * as qs from \"query-string\";\nimport { EngineTypes, RelayerTypes } from \"@walletconnect/types\";\n\n// -- uri -------------------------------------------------- //\n\nexport function parseRelayParams(params: any, delimiter = \"-\"): RelayerTypes.ProtocolOptions {\n  const relay: any = {};\n  const prefix = \"relay\" + delimiter;\n  Object.keys(params).forEach((key) => {\n    if (key.startsWith(prefix)) {\n      const name = key.replace(prefix, \"\");\n      const value = params[key];\n      relay[name] = value;\n    }\n  });\n  return relay;\n}\n\nexport function parseUri(str: string): EngineTypes.UriParameters {\n  const pathStart: number = str.indexOf(\":\");\n  const pathEnd: number | undefined = str.indexOf(\"?\") !== -1 ? str.indexOf(\"?\") : undefined;\n  const protocol: string = str.substring(0, pathStart);\n  const path: string = str.substring(pathStart + 1, pathEnd);\n  const requiredValues = path.split(\"@\");\n  const queryString: string = typeof pathEnd !== \"undefined\" ? str.substring(pathEnd) : \"\";\n  const queryParams = qs.parse(queryString);\n  const result = {\n    protocol,\n    topic: requiredValues[0],\n    version: parseInt(requiredValues[1], 10),\n    symKey: queryParams.symKey as string,\n    relay: parseRelayParams(queryParams),\n  };\n  return result;\n}\n\nexport function formatRelayParams(relay: RelayerTypes.ProtocolOptions, delimiter = \"-\") {\n  const prefix = \"relay\";\n  const params: any = {};\n  Object.keys(relay).forEach((key) => {\n    const k = prefix + delimiter + key;\n    if (relay[key]) {\n      params[k] = relay[key];\n    }\n  });\n  return params;\n}\n\nexport function formatUri(params: EngineTypes.UriParameters): string {\n  return (\n    `${params.protocol}:${params.topic}@${params.version}?` +\n    qs.stringify({\n      symKey: params.symKey,\n      ...formatRelayParams(params.relay),\n    })\n  );\n}\n","import { SessionTypes } from \"@walletconnect/types\";\n\nexport function getAccountsChains(accounts: SessionTypes.Namespace[\"accounts\"]) {\n  const chains: string[] = [];\n  accounts.forEach((account) => {\n    const [chain, chainId] = account.split(\":\");\n    chains.push(`${chain}:${chainId}`);\n  });\n\n  return chains;\n}\n\nexport function getNamespacesChains(namespaces: SessionTypes.Namespaces) {\n  const chains: string[] = [];\n  Object.values(namespaces).forEach((namespace) => {\n    chains.push(...getAccountsChains(namespace.accounts));\n    if (namespace.extension) {\n      namespace.extension.forEach((extension) => {\n        chains.push(...getAccountsChains(extension.accounts));\n      });\n    }\n  });\n\n  return chains;\n}\n\nexport function getNamespacesMethodsForChainId(\n  namespaces: SessionTypes.Namespaces,\n  chainId: string,\n) {\n  const methods: SessionTypes.Namespace[\"methods\"] = [];\n  Object.values(namespaces).forEach((namespace) => {\n    const chains = getAccountsChains(namespace.accounts);\n    if (chains.includes(chainId)) methods.push(...namespace.methods);\n    if (namespace.extension) {\n      namespace.extension.forEach((extension) => {\n        const extensionChains = getAccountsChains(extension.accounts);\n        if (extensionChains.includes(chainId)) methods.push(...extension.methods);\n      });\n    }\n  });\n\n  return methods;\n}\n\nexport function getNamespacesEventsForChainId(\n  namespaces: SessionTypes.Namespaces,\n  chainId: string,\n) {\n  const events: SessionTypes.Namespace[\"events\"] = [];\n  Object.values(namespaces).forEach((namespace) => {\n    const chains = getAccountsChains(namespace.accounts);\n    if (chains.includes(chainId)) events.push(...namespace.events);\n    if (namespace.extension) {\n      namespace.extension.forEach((extension) => {\n        const extensionChains = getAccountsChains(extension.accounts);\n        if (extensionChains.includes(chainId)) events.push(...extension.events);\n      });\n    }\n  });\n\n  return events;\n}\n","/**\n * Types\n */\ntype SdkErrorKey = keyof typeof SDK_ERRORS;\ntype InternalErrorKey = keyof typeof INTERNAL_ERRORS;\n\n/**\n * Constants\n */\nconst SDK_ERRORS = {\n  /* ----- INVALID (1xxx) ----- */\n  INVALID_METHOD: {\n    message: \"Invalid method.\",\n    code: 1001,\n  },\n  INVALID_EVENT: {\n    message: \"Invalid event.\",\n    code: 1002,\n  },\n  INVALID_UPDATE_REQUEST: {\n    message: \"Invalid update request.\",\n    code: 1003,\n  },\n  INVALID_EXTEND_REQUEST: {\n    message: \"Invalid extend request.\",\n    code: 1004,\n  },\n  INVALID_SESSION_SETTLE_REQUEST: {\n    message: \"Invalid session settle request.\",\n    code: 1005,\n  },\n  /* ----- UNAUTHORIZED (3xxx) ----- */\n  UNAUTHORIZED_METHOD: {\n    message: \"Unauthorized method.\",\n    code: 3001,\n  },\n  UNAUTHORIZED_EVENT: {\n    message: \"Unauthorized event.\",\n    code: 3002,\n  },\n  UNAUTHORIZED_UPDATE_REQUEST: {\n    message: \"Unauthorized update request.\",\n    code: 3003,\n  },\n  UNAUTHORIZED_EXTEND_REQUEST: {\n    message: \"Unauthorized extend request.\",\n    code: 3004,\n  },\n  /* ----- REJECTED (5xxx) ----- */\n  USER_REJECTED: {\n    message: \"User rejected.\",\n    code: 5000,\n  },\n  USER_REJECTED_CHAINS: {\n    message: \"User rejected chains.\",\n    code: 5001,\n  },\n  USER_REJECTED_METHODS: {\n    message: \"User rejected methods.\",\n    code: 5002,\n  },\n  USER_REJECTED_EVENTS: {\n    message: \"User rejected events.\",\n    code: 5003,\n  },\n  UNSUPPORTED_CHAINS: {\n    message: \"Unsupported chains.\",\n    code: 5100,\n  },\n  UNSUPPORTED_METHODS: {\n    message: \"Unsupported methods.\",\n    code: 5101,\n  },\n  UNSUPPORTED_EVENTS: {\n    message: \"Unsupported events.\",\n    code: 5102,\n  },\n  UNSUPPORTED_ACCOUNTS: {\n    message: \"Unsupported accounts.\",\n    code: 5103,\n  },\n  UNSUPPORTED_NAMESPACE_KEY: {\n    message: \"Unsupported namespace key.\",\n    code: 5104,\n  },\n  /* ----- REASON (6xxx) ----- */\n  USER_DISCONNECTED: {\n    message: \"User disconnected.\",\n    code: 6000,\n  },\n  /* ----- FAILURE (7xxx) ----- */\n  SESSION_SETTLEMENT_FAILED: {\n    message: \"Session settlement failed.\",\n    code: 7000,\n  },\n};\n\nconst INTERNAL_ERRORS = {\n  NOT_INITIALIZED: {\n    message: \"Not initialized.\",\n    code: 1,\n  },\n  NO_MATCHING_KEY: {\n    message: \"No matching key.\",\n    code: 2,\n  },\n  RESTORE_WILL_OVERRIDE: {\n    message: \"Restore will override.\",\n    code: 3,\n  },\n  RESUBSCRIBED: {\n    message: \"Resubscribed.\",\n    code: 4,\n  },\n  MISSING_OR_INVALID: {\n    message: \"Missing or invalid.\",\n    code: 5,\n  },\n  EXPIRED: {\n    message: \"Expired.\",\n    code: 6,\n  },\n  UNKNOWN_TYPE: {\n    message: \"Unknown type.\",\n    code: 7,\n  },\n  MISMATCHED_TOPIC: {\n    message: \"Mismatched topic.\",\n    code: 8,\n  },\n  NON_CONFORMING_NAMESPACES: {\n    message: \"Non conforming namespaces.\",\n    code: 9,\n  },\n};\n\n/**\n * Utilities\n */\nexport function getInternalError(key: InternalErrorKey, context?: string | number) {\n  const { message, code } = INTERNAL_ERRORS[key];\n  return {\n    message: context ? `${message} ${context}` : message,\n    code,\n  };\n}\n\nexport function getSdkError(key: SdkErrorKey, context?: string | number) {\n  const { message, code } = SDK_ERRORS[key];\n  return {\n    message: context ? `${message} ${context}` : message,\n    code,\n  };\n}\n","import { SessionTypes, ProposalTypes, RelayerTypes, EngineTypes } from \"@walletconnect/types\";\nimport { ErrorResponse } from \"@walletconnect/jsonrpc-types\";\nimport {\n  getNamespacesChains,\n  getNamespacesMethodsForChainId,\n  getNamespacesEventsForChainId,\n  getAccountsChains,\n} from \"./namespaces\";\nimport { getSdkError, getInternalError } from \"./errors\";\nimport { hasOverlap } from \"./misc\";\n\nexport type ErrorObject = { message: string; code: number } | null;\n\n// -- types validation ----------------------------------------------------- //\n\nexport function isValidArray(arr: any, itemCondition?: (item: any) => boolean) {\n  if (Array.isArray(arr)) {\n    if (typeof itemCondition !== \"undefined\" && arr.length) {\n      return arr.every(itemCondition);\n    } else {\n      return true;\n    }\n  }\n  return false;\n}\n\nexport function isValidObject(obj: any) {\n  return Object.getPrototypeOf(obj) === Object.prototype && Object.keys(obj).length;\n}\n\nexport function isUndefined(input: any): input is undefined {\n  return typeof input === \"undefined\";\n}\n\nexport function isValidString(input: any, optional: boolean): input is string {\n  if (optional && isUndefined(input)) return true;\n\n  return typeof input === \"string\" && Boolean(input.trim().length);\n}\n\nexport function isValidNumber(input: any, optional: boolean) {\n  if (optional && isUndefined(input)) return true;\n\n  return typeof input === \"number\" && !isNaN(input);\n}\n\n// -- protocol validation -------------------------------------------------- //\n\nexport function isSessionCompatible(session: SessionTypes.Struct, params: EngineTypes.FindParams) {\n  const { requiredNamespaces } = params;\n  const sessionKeys = Object.keys(session.namespaces);\n  const paramsKeys = Object.keys(requiredNamespaces);\n  let compatible = true;\n\n  if (!hasOverlap(paramsKeys, sessionKeys)) return false;\n\n  sessionKeys.forEach((key) => {\n    const { accounts, methods, events, extension } = session.namespaces[key];\n    const chains = getAccountsChains(accounts);\n    const requiredNamespace = requiredNamespaces[key];\n\n    if (\n      !hasOverlap(requiredNamespace.chains, chains) ||\n      !hasOverlap(requiredNamespace.methods, methods) ||\n      !hasOverlap(requiredNamespace.events, events)\n    ) {\n      compatible = false;\n    }\n\n    if (compatible && extension) {\n      extension.forEach((extensionNamespace) => {\n        const { accounts, methods, events } = extensionNamespace;\n        const chains = getAccountsChains(accounts);\n        const overlap = requiredNamespace.extension?.find(\n          (ext) =>\n            hasOverlap(ext.chains, chains) &&\n            hasOverlap(ext.methods, methods) &&\n            hasOverlap(ext.events, events),\n        );\n        if (!overlap) compatible = false;\n      });\n    }\n  });\n\n  return compatible;\n}\n\nexport function isValidChainId(value: any) {\n  if (isValidString(value, false) && value.includes(\":\")) {\n    const split = value.split(\":\");\n    return split.length === 2;\n  }\n  return false;\n}\n\nexport function isValidAccountId(value: any) {\n  if (isValidString(value, false) && value.includes(\":\")) {\n    const split = value.split(\":\");\n    if (split.length === 3) {\n      const chainId = split[0] + \":\" + split[1];\n      return !!split[2] && isValidChainId(chainId);\n    }\n  }\n  return false;\n}\n\nexport function isValidUrl(value: any) {\n  if (isValidString(value, false)) {\n    try {\n      const url = new URL(value);\n      return typeof url !== \"undefined\";\n    } catch (e) {\n      return false;\n    }\n  }\n  return false;\n}\n\nexport function isProposalStruct(input: any): input is ProposalTypes.Struct {\n  return input?.proposer?.publicKey;\n}\n\nexport function isSessionStruct(input: any): input is SessionTypes.Struct {\n  return input?.topic;\n}\n\nexport function isValidController(input: any, method: string) {\n  let error: ErrorObject = null;\n  if (!isValidString(input?.publicKey, false)) {\n    error = getInternalError(\n      \"MISSING_OR_INVALID\",\n      `${method} controller public key should be a string`,\n    );\n  }\n\n  return error;\n}\n\nexport function isValidExtension(namespace: any, method: string) {\n  let error: ErrorObject = null;\n  if (!isUndefined(namespace?.extension)) {\n    if (!isValidArray(namespace.extension) || !namespace.extension.length) {\n      error = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `${method} extension should be an array of namespaces, or omitted`,\n      );\n    }\n  }\n\n  return error;\n}\n\nexport function isValidNamespaceMethodsOrEvents(input: any): input is string {\n  let valid = true;\n  if (isValidArray(input)) {\n    if (input.length) {\n      valid = input.every((item: any) => isValidString(item, false));\n    }\n  } else {\n    valid = false;\n  }\n\n  return valid;\n}\n\nexport function isValidChains(key: string, chains: any, context: string) {\n  let error: ErrorObject = null;\n  if (isValidArray(chains)) {\n    chains.forEach((chain: any) => {\n      if (error) return;\n      if (!isValidChainId(chain) || !chain.includes(key)) {\n        error = getSdkError(\n          \"UNSUPPORTED_CHAINS\",\n          `${context}, chain ${chain} should be a string and conform to \"namespace:chainId\" format`,\n        );\n      }\n    });\n  } else {\n    error = getSdkError(\n      \"UNSUPPORTED_CHAINS\",\n      `${context}, chains ${chains} should be an array of strings conforming to \"namespace:chainId\" format`,\n    );\n  }\n\n  return error;\n}\n\nexport function isValidNamespaceChains(namespaces: any, method: string) {\n  let error: ErrorObject = null;\n  Object.entries(namespaces).forEach(([key, namespace]: [string, any]) => {\n    if (error) return;\n    const validChainsError = isValidChains(key, namespace?.chains, `${method} requiredNamespace`);\n    const validExtensionError = isValidExtension(namespace, method);\n    if (validChainsError) {\n      error = validChainsError;\n    } else if (validExtensionError) {\n      error = validExtensionError;\n    } else if (namespace.extension) {\n      namespace.extension.forEach((extension: any) => {\n        if (error) return;\n        const validChainsError = isValidChains(key, extension.chains, `${method} extension`);\n        if (validChainsError) {\n          error = validChainsError;\n        }\n      });\n    }\n  });\n\n  return error;\n}\n\nexport function isValidAccounts(accounts: any, context: string) {\n  let error: ErrorObject = null;\n  if (isValidArray(accounts)) {\n    accounts.forEach((account: any) => {\n      if (error) return;\n      if (!isValidAccountId(account)) {\n        error = getSdkError(\n          \"UNSUPPORTED_ACCOUNTS\",\n          `${context}, account ${account} should be a string and conform to \"namespace:chainId:address\" format`,\n        );\n      }\n    });\n  } else {\n    error = getSdkError(\n      \"UNSUPPORTED_ACCOUNTS\",\n      `${context}, accounts should be an array of strings conforming to \"namespace:chainId:address\" format`,\n    );\n  }\n\n  return error;\n}\n\nexport function isValidNamespaceAccounts(input: any, method: string) {\n  let error: ErrorObject = null;\n  Object.values(input).forEach((namespace: any) => {\n    if (error) return;\n    const validAccountsError = isValidAccounts(namespace?.accounts, `${method} namespace`);\n    const validExtensionError = isValidExtension(namespace, method);\n    if (validAccountsError) {\n      error = validAccountsError;\n    } else if (validExtensionError) {\n      error = validExtensionError;\n    } else if (namespace.extension) {\n      namespace.extension.forEach((extension: any) => {\n        if (error) return;\n        const validAccountsError = isValidAccounts(extension.accounts, `${method} extension`);\n        if (validAccountsError) {\n          error = validAccountsError;\n        }\n      });\n    }\n  });\n\n  return error;\n}\n\nexport function isValidActions(namespace: any, context: string) {\n  let error: ErrorObject = null;\n  if (!isValidNamespaceMethodsOrEvents(namespace?.methods)) {\n    error = getSdkError(\n      \"UNSUPPORTED_METHODS\",\n      `${context}, methods should be an array of strings or empty array for no methods`,\n    );\n  } else if (!isValidNamespaceMethodsOrEvents(namespace?.events)) {\n    error = getSdkError(\n      \"UNSUPPORTED_EVENTS\",\n      `${context}, events should be an array of strings or empty array for no events`,\n    );\n  }\n\n  return error;\n}\n\nexport function isValidNamespaceActions(input: any, method: string) {\n  let error: ErrorObject = null;\n  Object.values(input).forEach((namespace: any) => {\n    if (error) return;\n    const validActionsError = isValidActions(namespace, `${method}, namespace`);\n    const validExtensionError = isValidExtension(namespace, method);\n    if (validActionsError) {\n      error = validActionsError;\n    } else if (validExtensionError) {\n      error = validExtensionError;\n    } else if (namespace.extension) {\n      namespace.extension.forEach((extension: any) => {\n        if (error) return;\n        const validActionsError = isValidActions(extension, `${method}, extension`);\n        if (validActionsError) {\n          error = validActionsError;\n        }\n      });\n    }\n  });\n\n  return error;\n}\n\nexport function isValidRequiredNamespaces(input: any, method: string) {\n  let error: ErrorObject = null;\n  if (input && isValidObject(input)) {\n    const validActionsError = isValidNamespaceActions(input, method);\n    if (validActionsError) {\n      error = validActionsError;\n    }\n    const validChainsError = isValidNamespaceChains(input, method);\n    if (validChainsError) {\n      error = validChainsError;\n    }\n  } else {\n    error = getInternalError(\n      \"MISSING_OR_INVALID\",\n      `${method}, requiredNamespaces should be an object with data`,\n    );\n  }\n\n  return error;\n}\n\nexport function isValidNamespaces(input: any, method: string) {\n  let error: ErrorObject = null;\n  if (input && isValidObject(input)) {\n    const validActionsError = isValidNamespaceActions(input, method);\n    if (validActionsError) {\n      error = validActionsError;\n    }\n    const validAccountsError = isValidNamespaceAccounts(input, method);\n    if (validAccountsError) {\n      error = validAccountsError;\n    }\n  } else {\n    error = getInternalError(\n      \"MISSING_OR_INVALID\",\n      `${method}, namespaces should be an object with data`,\n    );\n  }\n\n  return error;\n}\n\nexport function isValidRelay(input: any): input is RelayerTypes.ProtocolOptions {\n  return isValidString(input.protocol, true);\n}\n\nexport function isValidRelays(\n  input: any,\n  optional: boolean,\n): input is RelayerTypes.ProtocolOptions[] {\n  let valid = false;\n\n  if (optional && !input) valid = true;\n  else if (input && isValidArray(input) && input.length) {\n    input.forEach((relay: RelayerTypes.ProtocolOptions) => {\n      valid = isValidRelay(relay);\n    });\n  }\n\n  return valid;\n}\n\nexport function isValidId(input: any) {\n  return typeof input === \"number\";\n}\n\nexport function isValidParams(input: any) {\n  return typeof input !== \"undefined\" && typeof input !== null;\n}\n\nexport function isValidErrorReason(input: any): input is ErrorResponse {\n  if (!input) return false;\n  if (typeof input !== \"object\") return false;\n  if (!input.code || !isValidNumber(input.code, false)) return false;\n  if (!input.message || !isValidString(input.message, false)) return false;\n\n  return true;\n}\n\nexport function isValidRequest(request: any) {\n  if (isUndefined(request)) return false;\n  if (!isValidString(request.method, false)) return false;\n  return true;\n}\n\nexport function isValidResponse(response: any) {\n  if (isUndefined(response)) return false;\n  if (isUndefined(response.result) && isUndefined(response.error)) return false;\n  if (!isValidNumber(response.id, false)) return false;\n  if (!isValidString(response.jsonrpc, false)) return false;\n  return true;\n}\n\nexport function isValidEvent(event: any) {\n  if (isUndefined(event)) return false;\n  if (!isValidString(event.name, false)) return false;\n  return true;\n}\n\nexport function isValidNamespacesChainId(namespaces: SessionTypes.Namespaces, chainId: string) {\n  if (!isValidChainId(chainId)) return false;\n  const chains = getNamespacesChains(namespaces);\n  if (!chains.includes(chainId)) return false;\n\n  return true;\n}\n\nexport function isValidNamespacesRequest(\n  namespaces: SessionTypes.Namespaces,\n  chainId: string,\n  method: string,\n) {\n  if (!isValidString(method, false)) return false;\n  const methods = getNamespacesMethodsForChainId(namespaces, chainId);\n  return methods.includes(method);\n}\n\nexport function isValidNamespacesEvent(\n  namespaces: SessionTypes.Namespaces,\n  chainId: string,\n  eventName: string,\n) {\n  if (!isValidString(eventName, false)) return false;\n  const events = getNamespacesEventsForChainId(namespaces, chainId);\n  return events.includes(eventName);\n}\n\nexport function isConformingNamespaces(\n  requiredNamespaces: ProposalTypes.RequiredNamespaces,\n  namespaces: SessionTypes.Namespaces,\n  context: string,\n) {\n  let error: ErrorObject = null;\n  const requiredNamespaceKeys = Object.keys(requiredNamespaces);\n  const namespaceKeys = Object.keys(namespaces);\n\n  if (!hasOverlap(requiredNamespaceKeys, namespaceKeys)) {\n    error = getInternalError(\n      \"NON_CONFORMING_NAMESPACES\",\n      `${context} namespaces keys don't satisfy requiredNamespaces`,\n    );\n  } else {\n    requiredNamespaceKeys.forEach((key) => {\n      if (error) return;\n\n      const requiredNamespaceChains = requiredNamespaces[key].chains;\n      const namespaceChains = getAccountsChains(namespaces[key].accounts);\n\n      if (!hasOverlap(requiredNamespaceChains, namespaceChains)) {\n        error = getInternalError(\n          \"NON_CONFORMING_NAMESPACES\",\n          `${context} namespaces accounts don't satisfy requiredNamespaces chains for ${key}`,\n        );\n      } else if (!hasOverlap(requiredNamespaces[key].methods, namespaces[key].methods)) {\n        error = getInternalError(\n          \"NON_CONFORMING_NAMESPACES\",\n          `${context} namespaces methods don't satisfy requiredNamespaces methods for ${key}`,\n        );\n      } else if (!hasOverlap(requiredNamespaces[key].events, namespaces[key].events)) {\n        error = getInternalError(\n          \"NON_CONFORMING_NAMESPACES\",\n          `${context} namespaces events don't satisfy requiredNamespaces events for ${key}`,\n        );\n      } else if (requiredNamespaces[key].extension && !namespaces[key].extension) {\n        error = getInternalError(\n          \"NON_CONFORMING_NAMESPACES\",\n          `${context} namespaces extension doesn't satisfy requiredNamespaces extension for ${key}`,\n        );\n      } else if (requiredNamespaces[key].extension && namespaces[key].extension) {\n        requiredNamespaces[key].extension?.forEach(({ methods, events, chains }) => {\n          if (error) return;\n          const isOverlap = namespaces[key].extension?.find((namespace) => {\n            const accChains = getAccountsChains(namespace.accounts);\n            return (\n              hasOverlap(chains, accChains) &&\n              hasOverlap(events, namespace.events) &&\n              hasOverlap(methods, namespace.methods)\n            );\n          });\n\n          if (!isOverlap) {\n            error = getInternalError(\n              \"NON_CONFORMING_NAMESPACES\",\n              `${context} namespaces extension doesn't satisfy requiredNamespaces extension for ${key}`,\n            );\n          }\n        });\n      }\n    });\n  }\n\n  return error;\n}\n"],"mappings":"","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}