{"ast":null,"code":"import { RELAYER_DEFAULT_PROTOCOL as F, RELAYER_EVENTS as ge, Store as U, Core as ue } from \"@walletconnect/core\";\nimport { generateChildLogger as k, getLoggerContext as j, getDefaultLoggerOptions as me } from \"@walletconnect/logger\";\nimport { IEngine as we, IExpirer as ye, IJsonRpcHistory as _e, ISignClient as Ee } from \"@walletconnect/types\";\nimport { createDelayedPromise as x, engineEvent as p, getInternalError as c, calcExpiry as E, parseUri as fe, getSdkError as f, isSessionCompatible as ve, isExpired as P, isValidParams as u, isUndefined as Ie, isValidRequiredNamespaces as Re, isValidRelays as Se, isValidUrl as Ne, isValidNamespaces as J, isConformingNamespaces as W, isValidString as b, isValidErrorReason as xe, isValidRelay as Pe, isValidController as Te, isValidNamespacesChainId as Z, isValidRequest as Oe, isValidNamespacesRequest as Ve, isValidResponse as qe, isValidEvent as Le, isValidNamespacesEvent as De, generateRandomBytes32 as be, formatUri as Ae, parseExpirerTarget as Ce, isValidId as $e, formatTopicTarget as Ge, formatIdTarget as ze, getAppMetadata as Me } from \"@walletconnect/utils\";\nimport Ke from \"pino\";\nimport { ONE_DAY as Ue, THIRTY_DAYS as B, SEVEN_DAYS as ke, FIVE_MINUTES as A, toMiliseconds as je } from \"@walletconnect/time\";\nimport { isJsonRpcResult as S, isJsonRpcError as v, formatJsonRpcRequest as Q, formatJsonRpcResult as Je, formatJsonRpcError as Ye, isJsonRpcRequest as Xe, isJsonRpcResponse as He } from \"@walletconnect/jsonrpc-utils\";\nimport { HEARTBEAT_EVENTS as Fe } from \"@walletconnect/heartbeat\";\nfunction d() {\n  this._events = this._events || {}, this._maxListeners = this._maxListeners || void 0;\n}\nvar C = d;\nd.EventEmitter = d, d.prototype._events = void 0, d.prototype._maxListeners = void 0, d.defaultMaxListeners = 10, d.prototype.setMaxListeners = function (o) {\n  if (!We(o) || o < 0 || isNaN(o)) throw TypeError(\"n must be a positive number\");\n  return this._maxListeners = o, this;\n}, d.prototype.emit = function (o) {\n  var i, e, t, s, r, n;\n  if (this._events || (this._events = {}), o === \"error\" && (!this._events.error || q(this._events.error) && !this._events.error.length)) {\n    if (i = arguments[1], i instanceof Error) throw i;\n    var a = new Error('Uncaught, unspecified \"error\" event. (' + i + \")\");\n    throw a.context = i, a;\n  }\n  if (e = this._events[o], ee(e)) return !1;\n  if (I(e)) switch (arguments.length) {\n    case 1:\n      e.call(this);\n      break;\n    case 2:\n      e.call(this, arguments[1]);\n      break;\n    case 3:\n      e.call(this, arguments[1], arguments[2]);\n      break;\n    default:\n      s = Array.prototype.slice.call(arguments, 1), e.apply(this, s);\n  } else if (q(e)) for (s = Array.prototype.slice.call(arguments, 1), n = e.slice(), t = n.length, r = 0; r < t; r++) n[r].apply(this, s);\n  return !0;\n}, d.prototype.addListener = function (o, i) {\n  var e;\n  if (!I(i)) throw TypeError(\"listener must be a function\");\n  return this._events || (this._events = {}), this._events.newListener && this.emit(\"newListener\", o, I(i.listener) ? i.listener : i), this._events[o] ? q(this._events[o]) ? this._events[o].push(i) : this._events[o] = [this._events[o], i] : this._events[o] = i, q(this._events[o]) && !this._events[o].warned && (ee(this._maxListeners) ? e = d.defaultMaxListeners : e = this._maxListeners, e && e > 0 && this._events[o].length > e && (this._events[o].warned = !0, console.error(\"(node) warning: possible EventEmitter memory leak detected. %d listeners added. Use emitter.setMaxListeners() to increase limit.\", this._events[o].length), typeof console.trace == \"function\" && console.trace())), this;\n}, d.prototype.on = d.prototype.addListener, d.prototype.once = function (o, i) {\n  if (!I(i)) throw TypeError(\"listener must be a function\");\n  var e = !1;\n  function t() {\n    this.removeListener(o, t), e || (e = !0, i.apply(this, arguments));\n  }\n  return t.listener = i, this.on(o, t), this;\n}, d.prototype.removeListener = function (o, i) {\n  var e, t, s, r;\n  if (!I(i)) throw TypeError(\"listener must be a function\");\n  if (!this._events || !this._events[o]) return this;\n  if (e = this._events[o], s = e.length, t = -1, e === i || I(e.listener) && e.listener === i) delete this._events[o], this._events.removeListener && this.emit(\"removeListener\", o, i);else if (q(e)) {\n    for (r = s; r-- > 0;) if (e[r] === i || e[r].listener && e[r].listener === i) {\n      t = r;\n      break;\n    }\n    if (t < 0) return this;\n    e.length === 1 ? (e.length = 0, delete this._events[o]) : e.splice(t, 1), this._events.removeListener && this.emit(\"removeListener\", o, i);\n  }\n  return this;\n}, d.prototype.removeAllListeners = function (o) {\n  var i, e;\n  if (!this._events) return this;\n  if (!this._events.removeListener) return arguments.length === 0 ? this._events = {} : this._events[o] && delete this._events[o], this;\n  if (arguments.length === 0) {\n    for (i in this._events) i !== \"removeListener\" && this.removeAllListeners(i);\n    return this.removeAllListeners(\"removeListener\"), this._events = {}, this;\n  }\n  if (e = this._events[o], I(e)) this.removeListener(o, e);else if (e) for (; e.length;) this.removeListener(o, e[e.length - 1]);\n  return delete this._events[o], this;\n}, d.prototype.listeners = function (o) {\n  var i;\n  return !this._events || !this._events[o] ? i = [] : I(this._events[o]) ? i = [this._events[o]] : i = this._events[o].slice(), i;\n}, d.prototype.listenerCount = function (o) {\n  if (this._events) {\n    var i = this._events[o];\n    if (I(i)) return 1;\n    if (i) return i.length;\n  }\n  return 0;\n}, d.listenerCount = function (o, i) {\n  return o.listenerCount(i);\n};\nfunction I(o) {\n  return typeof o == \"function\";\n}\nfunction We(o) {\n  return typeof o == \"number\";\n}\nfunction q(o) {\n  return typeof o == \"object\" && o !== null;\n}\nfunction ee(o) {\n  return o === void 0;\n}\nconst Y = \"wc\",\n  X = 2,\n  H = \"client\",\n  T = `${Y}@${X}:${H}:`,\n  $ = {\n    name: H,\n    logger: \"error\",\n    controller: !1,\n    relayUrl: \"wss://relay.walletconnect.com\"\n  },\n  Ze = {\n    session_proposal: \"session_proposal\",\n    session_update: \"session_update\",\n    session_extend: \"session_extend\",\n    session_ping: \"session_ping\",\n    pairing_ping: \"pairing_ping\",\n    session_delete: \"session_delete\",\n    session_expire: \"session_expire\",\n    pairing_delete: \"pairing_delete\",\n    pairing_expire: \"pairing_expire\",\n    session_request: \"session_request\",\n    session_event: \"session_event\",\n    proposal_expire: \"proposal_expire\"\n  },\n  Be = {\n    database: \":memory:\"\n  },\n  te = \"expirer\",\n  m = {\n    created: \"expirer_created\",\n    deleted: \"expirer_deleted\",\n    expired: \"expirer_expired\",\n    sync: \"expirer_sync\"\n  },\n  se = \"0.3\",\n  Qe = Ue,\n  _ = {\n    created: \"history_created\",\n    updated: \"history_updated\",\n    deleted: \"history_deleted\",\n    sync: \"history_sync\"\n  },\n  ie = \"history\",\n  re = \"0.3\",\n  ne = \"pairing\",\n  et = B,\n  oe = \"proposal\",\n  ae = B,\n  ce = \"session\",\n  L = ke,\n  he = \"engine\",\n  G = {\n    wc_pairingDelete: {\n      req: {\n        prompt: !1,\n        tag: 1e3\n      },\n      res: {\n        prompt: !1,\n        tag: 1001\n      }\n    },\n    wc_pairingPing: {\n      req: {\n        prompt: !1,\n        tag: 1002\n      },\n      res: {\n        prompt: !1,\n        tag: 1003\n      }\n    },\n    wc_sessionPropose: {\n      req: {\n        prompt: !0,\n        tag: 1100\n      },\n      res: {\n        prompt: !1,\n        tag: 1101\n      }\n    },\n    wc_sessionSettle: {\n      req: {\n        prompt: !1,\n        tag: 1102\n      },\n      res: {\n        prompt: !1,\n        tag: 1103\n      }\n    },\n    wc_sessionUpdate: {\n      req: {\n        prompt: !1,\n        tag: 1104\n      },\n      res: {\n        prompt: !1,\n        tag: 1105\n      }\n    },\n    wc_sessionExtend: {\n      req: {\n        prompt: !1,\n        tag: 1106\n      },\n      res: {\n        prompt: !1,\n        tag: 1107\n      }\n    },\n    wc_sessionRequest: {\n      req: {\n        prompt: !0,\n        tag: 1108\n      },\n      res: {\n        prompt: !1,\n        tag: 1109\n      }\n    },\n    wc_sessionEvent: {\n      req: {\n        prompt: !0,\n        tag: 1110\n      },\n      res: {\n        prompt: !1,\n        tag: 1111\n      }\n    },\n    wc_sessionDelete: {\n      req: {\n        prompt: !1,\n        tag: 1112\n      },\n      res: {\n        prompt: !1,\n        tag: 1113\n      }\n    },\n    wc_sessionPing: {\n      req: {\n        prompt: !1,\n        tag: 1114\n      },\n      res: {\n        prompt: !1,\n        tag: 1115\n      }\n    }\n  };\nvar tt = Object.defineProperty,\n  st = Object.defineProperties,\n  it = Object.getOwnPropertyDescriptors,\n  le = Object.getOwnPropertySymbols,\n  rt = Object.prototype.hasOwnProperty,\n  nt = Object.prototype.propertyIsEnumerable,\n  pe = (o, i, e) => i in o ? tt(o, i, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: e\n  }) : o[i] = e,\n  N = (o, i) => {\n    for (var e in i || (i = {})) rt.call(i, e) && pe(o, e, i[e]);\n    if (le) for (var e of le(i)) nt.call(i, e) && pe(o, e, i[e]);\n    return o;\n  },\n  de = (o, i) => st(o, it(i));\nclass ot extends we {\n  constructor(i) {\n    super(i), this.events = new C(), this.initialized = !1, this.name = he, this.init = async () => {\n      this.initialized || (await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.initialized = !0);\n    }, this.connect = async e => {\n      this.isInitialized(), await this.isValidConnect(e);\n      const {\n        pairingTopic: t,\n        requiredNamespaces: s,\n        relays: r\n      } = e;\n      let n = t,\n        a,\n        h = !1;\n      if (n && (h = this.client.pairing.get(n).active), !n || !h) {\n        const {\n          topic: R,\n          uri: g\n        } = await this.createPairing();\n        n = R, a = g;\n      }\n      const l = await this.client.core.crypto.generateKeyPair(),\n        w = {\n          requiredNamespaces: s,\n          relays: r ?? [{\n            protocol: F\n          }],\n          proposer: {\n            publicKey: l,\n            metadata: this.client.metadata\n          }\n        },\n        {\n          reject: y,\n          resolve: O,\n          done: M\n        } = x();\n      if (this.events.once(p(\"session_connect\"), async ({\n        error: R,\n        session: g\n      }) => {\n        if (R) y(R);else if (g) {\n          g.self.publicKey = l;\n          const V = de(N({}, g), {\n            requiredNamespaces: s\n          });\n          await this.client.session.set(g.topic, V), await this.setExpiry(g.topic, g.expiry), n && (await this.client.pairing.update(n, {\n            peerMetadata: g.peer.metadata\n          })), O(V);\n        }\n      }), !n) {\n        const {\n          message: R\n        } = c(\"NO_MATCHING_KEY\", `connect() pairing topic: ${n}`);\n        throw new Error(R);\n      }\n      const D = await this.sendRequest(n, \"wc_sessionPropose\", w),\n        K = E(A);\n      return await this.setProposal(D, N({\n        id: D,\n        expiry: K\n      }, w)), {\n        uri: a,\n        approval: M\n      };\n    }, this.pair = async e => {\n      this.isInitialized(), this.isValidPair(e);\n      const {\n          topic: t,\n          symKey: s,\n          relay: r\n        } = fe(e.uri),\n        n = E(A),\n        a = {\n          topic: t,\n          relay: r,\n          expiry: n,\n          active: !1\n        };\n      return await this.client.pairing.set(t, a), await this.client.core.crypto.setSymKey(s, t), await this.client.core.relayer.subscribe(t, {\n        relay: r\n      }), await this.setExpiry(t, n), a;\n    }, this.approve = async e => {\n      this.isInitialized(), await this.isValidApprove(e);\n      const {\n          id: t,\n          relayProtocol: s,\n          namespaces: r\n        } = e,\n        {\n          pairingTopic: n,\n          proposer: a,\n          requiredNamespaces: h\n        } = this.client.proposal.get(t),\n        l = await this.client.core.crypto.generateKeyPair(),\n        w = a.publicKey,\n        y = await this.client.core.crypto.generateSharedKey(l, w),\n        O = {\n          relay: {\n            protocol: s ?? \"irn\"\n          },\n          namespaces: r,\n          requiredNamespaces: h,\n          controller: {\n            publicKey: l,\n            metadata: this.client.metadata\n          },\n          expiry: E(L)\n        };\n      await this.client.core.relayer.subscribe(y);\n      const M = await this.sendRequest(y, \"wc_sessionSettle\", O),\n        {\n          done: D,\n          resolve: K,\n          reject: R\n        } = x();\n      this.events.once(p(\"session_approve\", M), ({\n        error: V\n      }) => {\n        V ? R(V) : K(this.client.session.get(y));\n      });\n      const g = de(N({}, O), {\n        topic: y,\n        acknowledged: !1,\n        self: O.controller,\n        peer: {\n          publicKey: a.publicKey,\n          metadata: a.metadata\n        },\n        controller: l\n      });\n      return await this.client.session.set(y, g), await this.setExpiry(y, E(L)), n && (await this.client.pairing.update(n, {\n        peerMetadata: g.peer.metadata\n      })), n && t && (await this.sendResult(t, n, {\n        relay: {\n          protocol: s ?? \"irn\"\n        },\n        responderPublicKey: l\n      }), await this.client.proposal.delete(t, f(\"USER_DISCONNECTED\")), await this.activatePairing(n)), {\n        topic: y,\n        acknowledged: D\n      };\n    }, this.reject = async e => {\n      this.isInitialized(), await this.isValidReject(e);\n      const {\n          id: t,\n          reason: s\n        } = e,\n        {\n          pairingTopic: r\n        } = this.client.proposal.get(t);\n      r && (await this.sendError(t, r, s), await this.client.proposal.delete(t, f(\"USER_DISCONNECTED\")));\n    }, this.update = async e => {\n      this.isInitialized(), await this.isValidUpdate(e);\n      const {\n          topic: t,\n          namespaces: s\n        } = e,\n        r = await this.sendRequest(t, \"wc_sessionUpdate\", {\n          namespaces: s\n        }),\n        {\n          done: n,\n          resolve: a,\n          reject: h\n        } = x();\n      return this.events.once(p(\"session_update\", r), ({\n        error: l\n      }) => {\n        l ? h(l) : a();\n      }), await this.client.session.update(t, {\n        namespaces: s\n      }), {\n        acknowledged: n\n      };\n    }, this.extend = async e => {\n      this.isInitialized(), await this.isValidExtend(e);\n      const {\n          topic: t\n        } = e,\n        s = await this.sendRequest(t, \"wc_sessionExtend\", {}),\n        {\n          done: r,\n          resolve: n,\n          reject: a\n        } = x();\n      return this.events.once(p(\"session_extend\", s), ({\n        error: h\n      }) => {\n        h ? a(h) : n();\n      }), await this.setExpiry(t, E(L)), {\n        acknowledged: r\n      };\n    }, this.request = async e => {\n      this.isInitialized(), await this.isValidRequest(e);\n      const {\n          chainId: t,\n          request: s,\n          topic: r\n        } = e,\n        n = await this.sendRequest(r, \"wc_sessionRequest\", {\n          request: s,\n          chainId: t\n        }),\n        {\n          done: a,\n          resolve: h,\n          reject: l\n        } = x();\n      return this.events.once(p(\"session_request\", n), ({\n        error: w,\n        result: y\n      }) => {\n        w ? l(w) : h(y);\n      }), await a();\n    }, this.respond = async e => {\n      this.isInitialized(), await this.isValidRespond(e);\n      const {\n          topic: t,\n          response: s\n        } = e,\n        {\n          id: r\n        } = s;\n      S(s) ? await this.sendResult(r, t, s.result) : v(s) && (await this.sendError(r, t, s.error));\n    }, this.ping = async e => {\n      this.isInitialized(), await this.isValidPing(e);\n      const {\n        topic: t\n      } = e;\n      if (this.client.session.keys.includes(t)) {\n        const s = await this.sendRequest(t, \"wc_sessionPing\", {}),\n          {\n            done: r,\n            resolve: n,\n            reject: a\n          } = x();\n        this.events.once(p(\"session_ping\", s), ({\n          error: h\n        }) => {\n          h ? a(h) : n();\n        }), await r();\n      } else if (this.client.pairing.keys.includes(t)) {\n        const s = await this.sendRequest(t, \"wc_pairingPing\", {}),\n          {\n            done: r,\n            resolve: n,\n            reject: a\n          } = x();\n        this.events.once(p(\"pairing_ping\", s), ({\n          error: h\n        }) => {\n          h ? a(h) : n();\n        }), await r();\n      }\n    }, this.emit = async e => {\n      this.isInitialized(), await this.isValidEmit(e);\n      const {\n        topic: t,\n        event: s,\n        chainId: r\n      } = e;\n      await this.sendRequest(t, \"wc_sessionEvent\", {\n        event: s,\n        chainId: r\n      });\n    }, this.disconnect = async e => {\n      this.isInitialized(), await this.isValidDisconnect(e);\n      const {\n        topic: t\n      } = e;\n      this.client.session.keys.includes(t) ? (await this.sendRequest(t, \"wc_sessionDelete\", f(\"USER_DISCONNECTED\")), await this.deleteSession(t)) : this.client.pairing.keys.includes(t) && (await this.sendRequest(t, \"wc_pairingDelete\", f(\"USER_DISCONNECTED\")), await this.deletePairing(t));\n    }, this.find = e => (this.isInitialized(), this.client.session.getAll().filter(t => ve(t, e))), this.activatePairing = async e => {\n      const t = E(ae);\n      await this.client.pairing.update(e, {\n        active: !0,\n        expiry: t\n      }), await this.setExpiry(e, t);\n    }, this.deleteSession = async e => {\n      const {\n        self: t\n      } = this.client.session.get(e);\n      await this.client.core.relayer.unsubscribe(e), await Promise.all([this.client.session.delete(e, f(\"USER_DISCONNECTED\")), this.client.core.crypto.deleteKeyPair(t.publicKey), this.client.core.crypto.deleteSymKey(e), this.client.expirer.del(e)]);\n    }, this.deletePairing = async e => {\n      await this.client.core.relayer.unsubscribe(e), await Promise.all([this.client.pairing.delete(e, f(\"USER_DISCONNECTED\")), this.client.core.crypto.deleteSymKey(e), this.client.expirer.del(e)]);\n    }, this.deleteProposal = async e => {\n      await Promise.all([this.client.proposal.delete(e, f(\"USER_DISCONNECTED\")), this.client.expirer.del(e)]);\n    }, this.setExpiry = async (e, t) => {\n      this.client.pairing.keys.includes(e) ? await this.client.pairing.update(e, {\n        expiry: t\n      }) : this.client.session.keys.includes(e) && (await this.client.session.update(e, {\n        expiry: t\n      })), this.client.expirer.set(e, t);\n    }, this.setProposal = async (e, t) => {\n      await this.client.proposal.set(e, t), this.client.expirer.set(e, t.expiry);\n    }, this.sendRequest = async (e, t, s) => {\n      const r = Q(t, s),\n        n = await this.client.core.crypto.encode(e, r),\n        a = G[t].req;\n      return this.client.history.set(e, r), await this.client.core.relayer.publish(e, n, a), r.id;\n    }, this.sendResult = async (e, t, s) => {\n      const r = Je(e, s),\n        n = await this.client.core.crypto.encode(t, r),\n        a = await this.client.history.get(t, e),\n        h = G[a.request.method].res;\n      await this.client.core.relayer.publish(t, n, h), await this.client.history.resolve(r);\n    }, this.sendError = async (e, t, s) => {\n      const r = Ye(e, s),\n        n = await this.client.core.crypto.encode(t, r),\n        a = await this.client.history.get(t, e),\n        h = G[a.request.method].res;\n      await this.client.core.relayer.publish(t, n, h), await this.client.history.resolve(r);\n    }, this.cleanup = async () => {\n      const e = [],\n        t = [],\n        s = [];\n      this.client.session.getAll().forEach(r => {\n        P(r.expiry) && e.push(r.topic);\n      }), this.client.pairing.getAll().forEach(r => {\n        P(r.expiry) && t.push(r.topic);\n      }), this.client.proposal.getAll().forEach(r => {\n        P(r.expiry) && s.push(r.id);\n      }), await Promise.all([...e.map(this.deleteSession), ...t.map(this.deletePairing), ...s.map(this.deleteProposal)]);\n    }, this.onRelayEventRequest = e => {\n      const {\n          topic: t,\n          payload: s\n        } = e,\n        r = s.method;\n      switch (r) {\n        case \"wc_sessionPropose\":\n          return this.onSessionProposeRequest(t, s);\n        case \"wc_sessionSettle\":\n          return this.onSessionSettleRequest(t, s);\n        case \"wc_sessionUpdate\":\n          return this.onSessionUpdateRequest(t, s);\n        case \"wc_sessionExtend\":\n          return this.onSessionExtendRequest(t, s);\n        case \"wc_sessionPing\":\n          return this.onSessionPingRequest(t, s);\n        case \"wc_pairingPing\":\n          return this.onPairingPingRequest(t, s);\n        case \"wc_sessionDelete\":\n          return this.onSessionDeleteRequest(t, s);\n        case \"wc_pairingDelete\":\n          return this.onPairingDeleteRequest(t, s);\n        case \"wc_sessionRequest\":\n          return this.onSessionRequest(t, s);\n        case \"wc_sessionEvent\":\n          return this.onSessionEventRequest(t, s);\n        default:\n          return this.client.logger.info(`Unsupported request method ${r}`);\n      }\n    }, this.onRelayEventResponse = async e => {\n      const {\n          topic: t,\n          payload: s\n        } = e,\n        r = (await this.client.history.get(t, s.id)).request.method;\n      switch (r) {\n        case \"wc_sessionPropose\":\n          return this.onSessionProposeResponse(t, s);\n        case \"wc_sessionSettle\":\n          return this.onSessionSettleResponse(t, s);\n        case \"wc_sessionUpdate\":\n          return this.onSessionUpdateResponse(t, s);\n        case \"wc_sessionExtend\":\n          return this.onSessionExtendResponse(t, s);\n        case \"wc_sessionPing\":\n          return this.onSessionPingResponse(t, s);\n        case \"wc_pairingPing\":\n          return this.onPairingPingResponse(t, s);\n        case \"wc_sessionRequest\":\n          return this.onSessionRequestResponse(t, s);\n        default:\n          return this.client.logger.info(`Unsupported response method ${r}`);\n      }\n    }, this.onSessionProposeRequest = async (e, t) => {\n      const {\n        params: s,\n        id: r\n      } = t;\n      try {\n        this.isValidConnect(N({}, t.params));\n        const n = E(A),\n          a = N({\n            id: r,\n            pairingTopic: e,\n            expiry: n\n          }, s);\n        await this.setProposal(r, a), this.client.events.emit(\"session_proposal\", {\n          id: r,\n          params: a\n        });\n      } catch (n) {\n        await this.sendError(r, e, n), this.client.logger.error(n);\n      }\n    }, this.onSessionProposeResponse = async (e, t) => {\n      const {\n        id: s\n      } = t;\n      if (S(t)) {\n        const {\n          result: r\n        } = t;\n        this.client.logger.trace({\n          type: \"method\",\n          method: \"onSessionProposeResponse\",\n          result: r\n        });\n        const n = this.client.proposal.get(s);\n        this.client.logger.trace({\n          type: \"method\",\n          method: \"onSessionProposeResponse\",\n          proposal: n\n        });\n        const a = n.proposer.publicKey;\n        this.client.logger.trace({\n          type: \"method\",\n          method: \"onSessionProposeResponse\",\n          selfPublicKey: a\n        });\n        const h = r.responderPublicKey;\n        this.client.logger.trace({\n          type: \"method\",\n          method: \"onSessionProposeResponse\",\n          peerPublicKey: h\n        });\n        const l = await this.client.core.crypto.generateSharedKey(a, h);\n        this.client.logger.trace({\n          type: \"method\",\n          method: \"onSessionProposeResponse\",\n          sessionTopic: l\n        });\n        const w = await this.client.core.relayer.subscribe(l);\n        this.client.logger.trace({\n          type: \"method\",\n          method: \"onSessionProposeResponse\",\n          subscriptionId: w\n        }), await this.activatePairing(e);\n      } else v(t) && (await this.client.proposal.delete(s, f(\"USER_DISCONNECTED\")), this.events.emit(p(\"session_connect\"), {\n        error: t.error\n      }));\n    }, this.onSessionSettleRequest = async (e, t) => {\n      const {\n        id: s,\n        params: r\n      } = t;\n      try {\n        this.isValidSessionSettleRequest(r);\n        const {\n            relay: n,\n            controller: a,\n            expiry: h,\n            namespaces: l\n          } = t.params,\n          w = {\n            topic: e,\n            relay: n,\n            expiry: h,\n            namespaces: l,\n            acknowledged: !0,\n            controller: a.publicKey,\n            self: {\n              publicKey: \"\",\n              metadata: this.client.metadata\n            },\n            peer: {\n              publicKey: a.publicKey,\n              metadata: a.metadata\n            }\n          };\n        await this.sendResult(t.id, e, !0), this.events.emit(p(\"session_connect\"), {\n          session: w\n        });\n      } catch (n) {\n        await this.sendError(s, e, n), this.client.logger.error(n);\n      }\n    }, this.onSessionSettleResponse = async (e, t) => {\n      const {\n        id: s\n      } = t;\n      S(t) ? (await this.client.session.update(e, {\n        acknowledged: !0\n      }), this.events.emit(p(\"session_approve\", s), {})) : v(t) && (await this.client.session.delete(e, f(\"USER_DISCONNECTED\")), this.events.emit(p(\"session_approve\", s), {\n        error: t.error\n      }));\n    }, this.onSessionUpdateRequest = async (e, t) => {\n      const {\n        params: s,\n        id: r\n      } = t;\n      try {\n        this.isValidUpdate(N({\n          topic: e\n        }, s)), await this.client.session.update(e, {\n          namespaces: s.namespaces\n        }), await this.sendResult(r, e, !0), this.client.events.emit(\"session_update\", {\n          id: r,\n          topic: e,\n          params: s\n        });\n      } catch (n) {\n        await this.sendError(r, e, n), this.client.logger.error(n);\n      }\n    }, this.onSessionUpdateResponse = (e, t) => {\n      const {\n        id: s\n      } = t;\n      S(t) ? this.events.emit(p(\"session_update\", s), {}) : v(t) && this.events.emit(p(\"session_update\", s), {\n        error: t.error\n      });\n    }, this.onSessionExtendRequest = async (e, t) => {\n      const {\n        id: s\n      } = t;\n      try {\n        this.isValidExtend({\n          topic: e\n        }), await this.setExpiry(e, E(L)), await this.sendResult(s, e, !0), this.client.events.emit(\"session_extend\", {\n          id: s,\n          topic: e\n        });\n      } catch (r) {\n        await this.sendError(s, e, r), this.client.logger.error(r);\n      }\n    }, this.onSessionExtendResponse = (e, t) => {\n      const {\n        id: s\n      } = t;\n      S(t) ? this.events.emit(p(\"session_extend\", s), {}) : v(t) && this.events.emit(p(\"session_extend\", s), {\n        error: t.error\n      });\n    }, this.onSessionPingRequest = async (e, t) => {\n      const {\n        id: s\n      } = t;\n      try {\n        this.isValidPing({\n          topic: e\n        }), await this.sendResult(s, e, !0), this.client.events.emit(\"session_ping\", {\n          id: s,\n          topic: e\n        });\n      } catch (r) {\n        await this.sendError(s, e, r), this.client.logger.error(r);\n      }\n    }, this.onSessionPingResponse = (e, t) => {\n      const {\n        id: s\n      } = t;\n      S(t) ? this.events.emit(p(\"session_ping\", s), {}) : v(t) && this.events.emit(p(\"session_ping\", s), {\n        error: t.error\n      });\n    }, this.onPairingPingRequest = async (e, t) => {\n      const {\n        id: s\n      } = t;\n      try {\n        this.isValidPing({\n          topic: e\n        }), await this.sendResult(s, e, !0), this.client.events.emit(\"pairing_ping\", {\n          id: s,\n          topic: e\n        });\n      } catch (r) {\n        await this.sendError(s, e, r), this.client.logger.error(r);\n      }\n    }, this.onPairingPingResponse = (e, t) => {\n      const {\n        id: s\n      } = t;\n      S(t) ? this.events.emit(p(\"pairing_ping\", s), {}) : v(t) && this.events.emit(p(\"pairing_ping\", s), {\n        error: t.error\n      });\n    }, this.onSessionDeleteRequest = async (e, t) => {\n      const {\n        id: s\n      } = t;\n      try {\n        this.isValidDisconnect({\n          topic: e,\n          reason: t.params\n        }), await this.sendResult(s, e, !0), await this.deleteSession(e), this.client.events.emit(\"session_delete\", {\n          id: s,\n          topic: e\n        });\n      } catch (r) {\n        await this.sendError(s, e, r), this.client.logger.error(r);\n      }\n    }, this.onPairingDeleteRequest = async (e, t) => {\n      const {\n        id: s\n      } = t;\n      try {\n        this.isValidDisconnect({\n          topic: e,\n          reason: t.params\n        }), await this.sendResult(s, e, !0), await this.deletePairing(e), this.client.events.emit(\"pairing_delete\", {\n          id: s,\n          topic: e\n        });\n      } catch (r) {\n        await this.sendError(s, e, r), this.client.logger.error(r);\n      }\n    }, this.onSessionRequest = async (e, t) => {\n      const {\n        id: s,\n        params: r\n      } = t;\n      try {\n        this.isValidRequest(N({\n          topic: e\n        }, r)), this.client.events.emit(\"session_request\", {\n          id: s,\n          topic: e,\n          params: r\n        });\n      } catch (n) {\n        await this.sendError(s, e, n), this.client.logger.error(n);\n      }\n    }, this.onSessionRequestResponse = (e, t) => {\n      const {\n        id: s\n      } = t;\n      S(t) ? this.events.emit(p(\"session_request\", s), {\n        result: t.result\n      }) : v(t) && this.events.emit(p(\"session_request\", s), {\n        error: t.error\n      });\n    }, this.onSessionEventRequest = async (e, t) => {\n      const {\n        id: s,\n        params: r\n      } = t;\n      try {\n        this.isValidEmit(N({\n          topic: e\n        }, r)), this.client.events.emit(\"session_event\", {\n          id: s,\n          topic: e,\n          params: r\n        });\n      } catch (n) {\n        await this.sendError(s, e, n), this.client.logger.error(n);\n      }\n    }, this.isValidConnect = async e => {\n      if (!u(e)) {\n        const {\n          message: a\n        } = c(\"MISSING_OR_INVALID\", `connect() params: ${JSON.stringify(e)}`);\n        throw new Error(a);\n      }\n      const {\n        pairingTopic: t,\n        requiredNamespaces: s,\n        relays: r\n      } = e;\n      Ie(t) || (await this.isValidPairingTopic(t));\n      const n = Re(s, \"connect()\");\n      if (n) throw new Error(n.message);\n      if (!Se(r, !0)) {\n        const {\n          message: a\n        } = c(\"MISSING_OR_INVALID\", `connect() relays: ${r}`);\n        throw new Error(a);\n      }\n    }, this.isValidPair = e => {\n      if (!u(e)) {\n        const {\n          message: t\n        } = c(\"MISSING_OR_INVALID\", `pair() params: ${e}`);\n        throw new Error(t);\n      }\n      if (!Ne(e.uri)) {\n        const {\n          message: t\n        } = c(\"MISSING_OR_INVALID\", `pair() uri: ${e.uri}`);\n        throw new Error(t);\n      }\n    }, this.isValidApprove = async e => {\n      if (!u(e)) throw new Error(c(\"MISSING_OR_INVALID\", `approve() params: ${e}`).message);\n      const {\n        id: t,\n        namespaces: s,\n        relayProtocol: r\n      } = e;\n      await this.isValidProposalId(t);\n      const n = this.client.proposal.get(t),\n        a = J(s, \"approve()\");\n      if (a) throw new Error(a.message);\n      const h = W(n.requiredNamespaces, s, \"update()\");\n      if (h) throw new Error(h.message);\n      if (!b(r, !0)) {\n        const {\n          message: l\n        } = c(\"MISSING_OR_INVALID\", `approve() relayProtocol: ${r}`);\n        throw new Error(l);\n      }\n    }, this.isValidReject = async e => {\n      if (!u(e)) {\n        const {\n          message: r\n        } = c(\"MISSING_OR_INVALID\", `reject() params: ${e}`);\n        throw new Error(r);\n      }\n      const {\n        id: t,\n        reason: s\n      } = e;\n      if (await this.isValidProposalId(t), !xe(s)) {\n        const {\n          message: r\n        } = c(\"MISSING_OR_INVALID\", `reject() reason: ${JSON.stringify(s)}`);\n        throw new Error(r);\n      }\n    }, this.isValidSessionSettleRequest = e => {\n      if (!u(e)) {\n        const {\n          message: l\n        } = c(\"MISSING_OR_INVALID\", `onSessionSettleRequest() params: ${e}`);\n        throw new Error(l);\n      }\n      const {\n        relay: t,\n        controller: s,\n        namespaces: r,\n        expiry: n\n      } = e;\n      if (!Pe(t)) {\n        const {\n          message: l\n        } = c(\"MISSING_OR_INVALID\", \"onSessionSettleRequest() relay protocol should be a string\");\n        throw new Error(l);\n      }\n      const a = Te(s, \"onSessionSettleRequest()\");\n      if (a) throw new Error(a.message);\n      const h = J(r, \"onSessionSettleRequest()\");\n      if (h) throw new Error(h.message);\n      if (P(n)) {\n        const {\n          message: l\n        } = c(\"EXPIRED\", \"onSessionSettleRequest()\");\n        throw new Error(l);\n      }\n    }, this.isValidUpdate = async e => {\n      if (!u(e)) {\n        const {\n          message: h\n        } = c(\"MISSING_OR_INVALID\", `update() params: ${e}`);\n        throw new Error(h);\n      }\n      const {\n        topic: t,\n        namespaces: s\n      } = e;\n      await this.isValidSessionTopic(t);\n      const r = this.client.session.get(t),\n        n = J(s, \"update()\");\n      if (n) throw new Error(n.message);\n      const a = W(r.requiredNamespaces, s, \"update()\");\n      if (a) throw new Error(a.message);\n    }, this.isValidExtend = async e => {\n      if (!u(e)) {\n        const {\n          message: s\n        } = c(\"MISSING_OR_INVALID\", `extend() params: ${e}`);\n        throw new Error(s);\n      }\n      const {\n        topic: t\n      } = e;\n      await this.isValidSessionTopic(t);\n    }, this.isValidRequest = async e => {\n      if (!u(e)) {\n        const {\n          message: a\n        } = c(\"MISSING_OR_INVALID\", `request() params: ${e}`);\n        throw new Error(a);\n      }\n      const {\n        topic: t,\n        request: s,\n        chainId: r\n      } = e;\n      await this.isValidSessionTopic(t);\n      const {\n        namespaces: n\n      } = this.client.session.get(t);\n      if (!Z(n, r)) {\n        const {\n          message: a\n        } = c(\"MISSING_OR_INVALID\", `request() chainId: ${r}`);\n        throw new Error(a);\n      }\n      if (!Oe(s)) {\n        const {\n          message: a\n        } = c(\"MISSING_OR_INVALID\", `request() ${JSON.stringify(s)}`);\n        throw new Error(a);\n      }\n      if (!Ve(n, r, s.method)) {\n        const {\n          message: a\n        } = c(\"MISSING_OR_INVALID\", `request() method: ${s.method}`);\n        throw new Error(a);\n      }\n    }, this.isValidRespond = async e => {\n      if (!u(e)) {\n        const {\n          message: r\n        } = c(\"MISSING_OR_INVALID\", `respond() params: ${e}`);\n        throw new Error(r);\n      }\n      const {\n        topic: t,\n        response: s\n      } = e;\n      if (await this.isValidSessionTopic(t), !qe(s)) {\n        const {\n          message: r\n        } = c(\"MISSING_OR_INVALID\", `respond() response: ${JSON.stringify(s)}`);\n        throw new Error(r);\n      }\n    }, this.isValidPing = async e => {\n      if (!u(e)) {\n        const {\n          message: s\n        } = c(\"MISSING_OR_INVALID\", `ping() params: ${e}`);\n        throw new Error(s);\n      }\n      const {\n        topic: t\n      } = e;\n      await this.isValidSessionOrPairingTopic(t);\n    }, this.isValidEmit = async e => {\n      if (!u(e)) {\n        const {\n          message: a\n        } = c(\"MISSING_OR_INVALID\", `emit() params: ${e}`);\n        throw new Error(a);\n      }\n      const {\n        topic: t,\n        event: s,\n        chainId: r\n      } = e;\n      await this.isValidSessionTopic(t);\n      const {\n        namespaces: n\n      } = this.client.session.get(t);\n      if (!Z(n, r)) {\n        const {\n          message: a\n        } = c(\"MISSING_OR_INVALID\", `emit() chainId: ${r}`);\n        throw new Error(a);\n      }\n      if (!Le(s)) {\n        const {\n          message: a\n        } = c(\"MISSING_OR_INVALID\", `emit() event: ${JSON.stringify(s)}`);\n        throw new Error(a);\n      }\n      if (!De(n, r, s.name)) {\n        const {\n          message: a\n        } = c(\"MISSING_OR_INVALID\", `emit() event: ${JSON.stringify(s)}`);\n        throw new Error(a);\n      }\n    }, this.isValidDisconnect = async e => {\n      if (!u(e)) {\n        const {\n          message: s\n        } = c(\"MISSING_OR_INVALID\", `disconnect() params: ${e}`);\n        throw new Error(s);\n      }\n      const {\n        topic: t\n      } = e;\n      await this.isValidSessionOrPairingTopic(t);\n    };\n  }\n  async createPairing() {\n    const i = be(),\n      e = await this.client.core.crypto.setSymKey(i),\n      t = E(A),\n      s = {\n        protocol: F\n      },\n      r = {\n        topic: e,\n        expiry: t,\n        relay: s,\n        active: !1\n      },\n      n = Ae({\n        protocol: this.client.protocol,\n        version: this.client.version,\n        topic: e,\n        symKey: i,\n        relay: s\n      });\n    return await this.client.pairing.set(e, r), await this.client.core.relayer.subscribe(e), await this.setExpiry(e, t), {\n      topic: e,\n      uri: n\n    };\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const {\n        message: i\n      } = c(\"NOT_INITIALIZED\", this.name);\n      throw new Error(i);\n    }\n  }\n  registerRelayerEvents() {\n    this.client.core.relayer.on(ge.message, async i => {\n      const {\n          topic: e,\n          message: t\n        } = i,\n        s = await this.client.core.crypto.decode(e, t);\n      Xe(s) ? (this.client.history.set(e, s), this.onRelayEventRequest({\n        topic: e,\n        payload: s\n      })) : He(s) && (await this.client.history.resolve(s), this.onRelayEventResponse({\n        topic: e,\n        payload: s\n      }));\n    });\n  }\n  registerExpirerEvents() {\n    this.client.expirer.on(m.expired, async i => {\n      const {\n        topic: e,\n        id: t\n      } = Ce(i.target);\n      e ? this.client.session.keys.includes(e) ? (await this.deleteSession(e), this.client.events.emit(\"session_expire\", {\n        topic: e\n      })) : this.client.pairing.keys.includes(e) && (await this.deletePairing(e), this.client.events.emit(\"pairing_expire\", {\n        topic: e\n      })) : t && (await this.deleteProposal(t));\n    });\n  }\n  async isValidPairingTopic(i) {\n    if (!b(i, !1)) {\n      const {\n        message: e\n      } = c(\"MISSING_OR_INVALID\", `pairing topic should be a string: ${i}`);\n      throw new Error(e);\n    }\n    if (!this.client.pairing.keys.includes(i)) {\n      const {\n        message: e\n      } = c(\"NO_MATCHING_KEY\", `pairing topic doesn't exist: ${i}`);\n      throw new Error(e);\n    }\n    if (P(this.client.pairing.get(i).expiry)) {\n      await this.deletePairing(i);\n      const {\n        message: e\n      } = c(\"EXPIRED\", `pairing topic: ${i}`);\n      throw new Error(e);\n    }\n  }\n  async isValidSessionTopic(i) {\n    if (!b(i, !1)) {\n      const {\n        message: e\n      } = c(\"MISSING_OR_INVALID\", `session topic should be a string: ${i}`);\n      throw new Error(e);\n    }\n    if (!this.client.session.keys.includes(i)) {\n      const {\n        message: e\n      } = c(\"NO_MATCHING_KEY\", `session topic doesn't exist: ${i}`);\n      throw new Error(e);\n    }\n    if (P(this.client.session.get(i).expiry)) {\n      await this.deleteSession(i);\n      const {\n        message: e\n      } = c(\"EXPIRED\", `session topic: ${i}`);\n      throw new Error(e);\n    }\n  }\n  async isValidSessionOrPairingTopic(i) {\n    if (this.client.session.keys.includes(i)) await this.isValidSessionTopic(i);else if (this.client.pairing.keys.includes(i)) await this.isValidPairingTopic(i);else if (b(i, !1)) {\n      const {\n        message: e\n      } = c(\"NO_MATCHING_KEY\", `session or pairing topic doesn't exist: ${i}`);\n      throw new Error(e);\n    } else {\n      const {\n        message: e\n      } = c(\"MISSING_OR_INVALID\", `session or pairing topic should be a string: ${i}`);\n      throw new Error(e);\n    }\n  }\n  async isValidProposalId(i) {\n    if (!$e(i)) {\n      const {\n        message: e\n      } = c(\"MISSING_OR_INVALID\", `proposal id should be a number: ${i}`);\n      throw new Error(e);\n    }\n    if (!this.client.proposal.keys.includes(i)) {\n      const {\n        message: e\n      } = c(\"NO_MATCHING_KEY\", `proposal id doesn't exist: ${i}`);\n      throw new Error(e);\n    }\n    if (P(this.client.proposal.get(i).expiry)) {\n      await this.deleteProposal(i);\n      const {\n        message: e\n      } = c(\"EXPIRED\", `proposal id: ${i}`);\n      throw new Error(e);\n    }\n  }\n}\nclass at extends ye {\n  constructor(i, e) {\n    super(i, e), this.core = i, this.logger = e, this.expirations = new Map(), this.events = new C.EventEmitter(), this.name = te, this.version = se, this.cached = [], this.initialized = !1, this.storagePrefix = T, this.init = async () => {\n      this.initialized || (this.logger.trace(\"Initialized\"), await this.restore(), this.cached.forEach(t => this.expirations.set(t.target, t)), this.cached = [], this.registerEventListeners(), this.initialized = !0);\n    }, this.has = t => {\n      try {\n        const s = this.formatTarget(t);\n        return typeof this.getExpiration(s) < \"u\";\n      } catch {\n        return !1;\n      }\n    }, this.set = (t, s) => {\n      this.isInitialized();\n      const r = this.formatTarget(t),\n        n = {\n          target: r,\n          expiry: s\n        };\n      this.expirations.set(r, n), this.checkExpiry(r, n), this.events.emit(m.created, {\n        target: r,\n        expiration: n\n      });\n    }, this.get = t => {\n      this.isInitialized();\n      const s = this.formatTarget(t);\n      return this.getExpiration(s);\n    }, this.del = t => {\n      this.isInitialized();\n      const s = this.formatTarget(t);\n      if (this.has(s)) {\n        const r = this.getExpiration(s);\n        this.expirations.delete(s), this.events.emit(m.deleted, {\n          target: s,\n          expiration: r\n        });\n      }\n    }, this.on = (t, s) => {\n      this.events.on(t, s);\n    }, this.once = (t, s) => {\n      this.events.once(t, s);\n    }, this.off = (t, s) => {\n      this.events.off(t, s);\n    }, this.removeListener = (t, s) => {\n      this.events.removeListener(t, s);\n    }, this.logger = k(e, this.name);\n  }\n  get context() {\n    return j(this.logger);\n  }\n  get storageKey() {\n    return this.storagePrefix + this.version + \"//\" + this.name;\n  }\n  get length() {\n    return this.expirations.size;\n  }\n  get keys() {\n    return Array.from(this.expirations.keys());\n  }\n  get values() {\n    return Array.from(this.expirations.values());\n  }\n  formatTarget(i) {\n    if (typeof i == \"string\") return Ge(i);\n    if (typeof i == \"number\") return ze(i);\n    const {\n      message: e\n    } = c(\"UNKNOWN_TYPE\", `Target type: ${typeof i}`);\n    throw new Error(e);\n  }\n  async setExpirations(i) {\n    await this.core.storage.setItem(this.storageKey, i);\n  }\n  async getExpirations() {\n    return await this.core.storage.getItem(this.storageKey);\n  }\n  async persist() {\n    await this.setExpirations(this.values), this.events.emit(m.sync);\n  }\n  async restore() {\n    try {\n      const i = await this.getExpirations();\n      if (typeof i > \"u\" || !i.length) return;\n      if (this.expirations.size) {\n        const {\n          message: e\n        } = c(\"RESTORE_WILL_OVERRIDE\", this.name);\n        throw this.logger.error(e), new Error(e);\n      }\n      this.cached = i, this.logger.debug(`Successfully Restored expirations for ${this.name}`), this.logger.trace({\n        type: \"method\",\n        method: \"restore\",\n        expirations: this.values\n      });\n    } catch (i) {\n      this.logger.debug(`Failed to Restore expirations for ${this.name}`), this.logger.error(i);\n    }\n  }\n  getExpiration(i) {\n    const e = this.expirations.get(i);\n    if (!e) {\n      const {\n        message: t\n      } = c(\"NO_MATCHING_KEY\", `${this.name}: ${i}`);\n      throw this.logger.error(t), new Error(t);\n    }\n    return e;\n  }\n  checkExpiry(i, e) {\n    const {\n      expiry: t\n    } = e;\n    je(t) - Date.now() <= 0 && this.expire(i, e);\n  }\n  expire(i, e) {\n    this.expirations.delete(i), this.events.emit(m.expired, {\n      target: i,\n      expiration: e\n    });\n  }\n  checkExpirations() {\n    this.expirations.forEach((i, e) => this.checkExpiry(e, i));\n  }\n  registerEventListeners() {\n    this.core.heartbeat.on(Fe.pulse, () => this.checkExpirations()), this.events.on(m.created, i => {\n      const e = m.created;\n      this.logger.info(`Emitting ${e}`), this.logger.debug({\n        type: \"event\",\n        event: e,\n        data: i\n      }), this.persist();\n    }), this.events.on(m.expired, i => {\n      const e = m.expired;\n      this.logger.info(`Emitting ${e}`), this.logger.debug({\n        type: \"event\",\n        event: e,\n        data: i\n      }), this.persist();\n    }), this.events.on(m.deleted, i => {\n      const e = m.deleted;\n      this.logger.info(`Emitting ${e}`), this.logger.debug({\n        type: \"event\",\n        event: e,\n        data: i\n      }), this.persist();\n    });\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const {\n        message: i\n      } = c(\"NOT_INITIALIZED\", this.name);\n      throw new Error(i);\n    }\n  }\n}\nclass ct extends _e {\n  constructor(i, e) {\n    super(i, e), this.core = i, this.logger = e, this.records = new Map(), this.events = new C.EventEmitter(), this.name = ie, this.version = re, this.cached = [], this.initialized = !1, this.storagePrefix = T, this.init = async () => {\n      this.initialized || (this.logger.trace(\"Initialized\"), await this.restore(), this.cached.forEach(t => this.records.set(t.id, t)), this.cached = [], this.registerEventListeners(), this.initialized = !0);\n    }, this.set = (t, s, r) => {\n      if (this.isInitialized(), this.logger.debug(\"Setting JSON-RPC request history record\"), this.logger.trace({\n        type: \"method\",\n        method: \"set\",\n        topic: t,\n        request: s,\n        chainId: r\n      }), this.records.has(s.id)) return;\n      const n = {\n        id: s.id,\n        topic: t,\n        request: {\n          method: s.method,\n          params: s.params || null\n        },\n        chainId: r\n      };\n      this.records.set(n.id, n), this.events.emit(_.created, n);\n    }, this.resolve = async t => {\n      if (this.isInitialized(), this.logger.debug(\"Updating JSON-RPC response history record\"), this.logger.trace({\n        type: \"method\",\n        method: \"update\",\n        response: t\n      }), !this.records.has(t.id)) return;\n      const s = await this.getRecord(t.id);\n      typeof s.response > \"u\" && (s.response = v(t) ? {\n        error: t.error\n      } : {\n        result: t.result\n      }, this.records.set(s.id, s), this.events.emit(_.updated, s));\n    }, this.get = async (t, s) => {\n      this.isInitialized(), this.logger.debug(\"Getting record\"), this.logger.trace({\n        type: \"method\",\n        method: \"get\",\n        topic: t,\n        id: s\n      });\n      const r = await this.getRecord(s);\n      if (r.topic !== t) {\n        const {\n          message: n\n        } = c(\"MISMATCHED_TOPIC\", `${this.name}, ${s}`);\n        throw this.logger.error(n), new Error(n);\n      }\n      return r;\n    }, this.delete = (t, s) => {\n      this.isInitialized(), this.logger.debug(\"Deleting record\"), this.logger.trace({\n        type: \"method\",\n        method: \"delete\",\n        id: s\n      }), this.values.forEach(r => {\n        if (r.topic === t) {\n          if (typeof s < \"u\" && r.id !== s) return;\n          this.records.delete(r.id), this.events.emit(_.deleted, r);\n        }\n      });\n    }, this.exists = async (t, s) => (this.isInitialized(), this.records.has(s) ? (await this.getRecord(s)).topic === t : !1), this.on = (t, s) => {\n      this.events.on(t, s);\n    }, this.once = (t, s) => {\n      this.events.once(t, s);\n    }, this.off = (t, s) => {\n      this.events.off(t, s);\n    }, this.removeListener = (t, s) => {\n      this.events.removeListener(t, s);\n    }, this.logger = k(e, this.name);\n  }\n  get context() {\n    return j(this.logger);\n  }\n  get storageKey() {\n    return this.storagePrefix + this.version + \"//\" + this.name;\n  }\n  get size() {\n    return this.records.size;\n  }\n  get keys() {\n    return Array.from(this.records.keys());\n  }\n  get values() {\n    return Array.from(this.records.values());\n  }\n  get pending() {\n    const i = [];\n    return this.values.forEach(e => {\n      if (typeof e.response < \"u\") return;\n      const t = {\n        topic: e.topic,\n        request: Q(e.request.method, e.request.params, e.id),\n        chainId: e.chainId\n      };\n      return i.push(t);\n    }), i;\n  }\n  async setJsonRpcRecords(i) {\n    await this.core.storage.setItem(this.storageKey, i);\n  }\n  async getJsonRpcRecords() {\n    return await this.core.storage.getItem(this.storageKey);\n  }\n  getRecord(i) {\n    this.isInitialized();\n    const e = this.records.get(i);\n    if (!e) {\n      const {\n        message: t\n      } = c(\"NO_MATCHING_KEY\", `${this.name}: ${i}`);\n      throw new Error(t);\n    }\n    return e;\n  }\n  async persist() {\n    await this.setJsonRpcRecords(this.values), this.events.emit(_.sync);\n  }\n  async restore() {\n    try {\n      const i = await this.getJsonRpcRecords();\n      if (typeof i > \"u\" || !i.length) return;\n      if (this.records.size) {\n        const {\n          message: e\n        } = c(\"RESTORE_WILL_OVERRIDE\", this.name);\n        throw this.logger.error(e), new Error(e);\n      }\n      this.cached = i, this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({\n        type: \"method\",\n        method: \"restore\",\n        records: this.values\n      });\n    } catch (i) {\n      this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(i);\n    }\n  }\n  registerEventListeners() {\n    this.events.on(_.created, i => {\n      const e = _.created;\n      this.logger.info(`Emitting ${e}`), this.logger.debug({\n        type: \"event\",\n        event: e,\n        record: i\n      }), this.persist();\n    }), this.events.on(_.updated, i => {\n      const e = _.updated;\n      this.logger.info(`Emitting ${e}`), this.logger.debug({\n        type: \"event\",\n        event: e,\n        record: i\n      }), this.persist();\n    }), this.events.on(_.deleted, i => {\n      const e = _.deleted;\n      this.logger.info(`Emitting ${e}`), this.logger.debug({\n        type: \"event\",\n        event: e,\n        record: i\n      }), this.persist();\n    });\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const {\n        message: i\n      } = c(\"NOT_INITIALIZED\", this.name);\n      throw new Error(i);\n    }\n  }\n}\nclass ht extends U {\n  constructor(i, e) {\n    super(i, e, ne, T), this.core = i, this.logger = e;\n  }\n}\nclass lt extends U {\n  constructor(i, e) {\n    super(i, e, oe, T), this.core = i, this.logger = e;\n  }\n}\nclass pt extends U {\n  constructor(i, e) {\n    super(i, e, ce, T), this.core = i, this.logger = e;\n  }\n}\nclass z extends Ee {\n  constructor(i) {\n    super(i), this.protocol = Y, this.version = X, this.name = $.name, this.events = new C.EventEmitter(), this.on = (t, s) => this.events.on(t, s), this.once = (t, s) => this.events.once(t, s), this.off = (t, s) => this.events.off(t, s), this.removeListener = (t, s) => this.events.removeListener(t, s), this.connect = async t => {\n      try {\n        return await this.engine.connect(t);\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }, this.pair = async t => {\n      try {\n        return await this.engine.pair(t);\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }, this.approve = async t => {\n      try {\n        return await this.engine.approve(t);\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }, this.reject = async t => {\n      try {\n        return await this.engine.reject(t);\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }, this.update = async t => {\n      try {\n        return await this.engine.update(t);\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }, this.extend = async t => {\n      try {\n        return await this.engine.extend(t);\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }, this.request = async t => {\n      try {\n        return await this.engine.request(t);\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }, this.respond = async t => {\n      try {\n        return await this.engine.respond(t);\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }, this.ping = async t => {\n      try {\n        return await this.engine.ping(t);\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }, this.emit = async t => {\n      try {\n        return await this.engine.emit(t);\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }, this.disconnect = async t => {\n      try {\n        return await this.engine.disconnect(t);\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }, this.find = t => {\n      try {\n        return this.engine.find(t);\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }, this.name = i?.name || $.name, this.metadata = i?.metadata || Me();\n    const e = typeof i?.logger < \"u\" && typeof i?.logger != \"string\" ? i.logger : Ke(me({\n      level: i?.logger || $.logger\n    }));\n    this.core = i?.core || new ue(i), this.logger = k(e, this.name), this.pairing = new ht(this.core, this.logger), this.session = new pt(this.core, this.logger), this.proposal = new lt(this.core, this.logger), this.history = new ct(this.core, this.logger), this.expirer = new at(this.core, this.logger), this.engine = new ot(this);\n  }\n  static async init(i) {\n    const e = new z(i);\n    return await e.initialize(), e;\n  }\n  get context() {\n    return j(this.logger);\n  }\n  async initialize() {\n    this.logger.trace(\"Initialized\");\n    try {\n      await this.core.start(), await this.pairing.init(), await this.session.init(), await this.proposal.init(), await this.history.init(), await this.expirer.init(), await this.engine.init(), this.logger.info(\"SignClient Initilization Success\");\n    } catch (i) {\n      throw this.logger.info(\"SignClient Initilization Failure\"), this.logger.error(i.message), i;\n    }\n  }\n}\nconst dt = z;\nexport { he as ENGINE_CONTEXT, G as ENGINE_RPC_OPTS, te as EXPIRER_CONTEXT, Qe as EXPIRER_DEFAULT_TTL, m as EXPIRER_EVENTS, se as EXPIRER_STORAGE_VERSION, ie as HISTORY_CONTEXT, _ as HISTORY_EVENTS, re as HISTORY_STORAGE_VERSION, ne as PAIRING_CONTEXT, et as PAIRING_DEFAULT_TTL, oe as PROPOSAL_CONTEXT, ae as PROPOSAL_EXPIRY, ce as SESSION_CONTEXT, L as SESSION_EXPIRY, H as SIGN_CLIENT_CONTEXT, $ as SIGN_CLIENT_DEFAULT, Ze as SIGN_CLIENT_EVENTS, Y as SIGN_CLIENT_PROTOCOL, Be as SIGN_CLIENT_STORAGE_OPTIONS, T as SIGN_CLIENT_STORAGE_PREFIX, X as SIGN_CLIENT_VERSION, dt as SignClient, z as default };","map":{"version":3,"names":[],"sources":["C:\\Users\\user\\Desktop\\BCEndterm\\node_modules\\node_modules\\events\\events.js","C:\\Users\\user\\Desktop\\BCEndterm\\node_modules\\@walletconnect\\sign-client\\src\\constants\\client.ts","C:\\Users\\user\\Desktop\\BCEndterm\\node_modules\\@walletconnect\\sign-client\\src\\constants\\expirer.ts","C:\\Users\\user\\Desktop\\BCEndterm\\node_modules\\@walletconnect\\sign-client\\src\\constants\\history.ts","C:\\Users\\user\\Desktop\\BCEndterm\\node_modules\\@walletconnect\\sign-client\\src\\constants\\pairing.ts","C:\\Users\\user\\Desktop\\BCEndterm\\node_modules\\@walletconnect\\sign-client\\src\\constants\\proposal.ts","C:\\Users\\user\\Desktop\\BCEndterm\\node_modules\\@walletconnect\\sign-client\\src\\constants\\session.ts","C:\\Users\\user\\Desktop\\BCEndterm\\node_modules\\@walletconnect\\sign-client\\src\\constants\\engine.ts","C:\\Users\\user\\Desktop\\BCEndterm\\node_modules\\@walletconnect\\sign-client\\src\\controllers\\engine.ts","C:\\Users\\user\\Desktop\\BCEndterm\\node_modules\\@walletconnect\\sign-client\\src\\controllers\\expirer.ts","C:\\Users\\user\\Desktop\\BCEndterm\\node_modules\\@walletconnect\\sign-client\\src\\controllers\\history.ts","C:\\Users\\user\\Desktop\\BCEndterm\\node_modules\\@walletconnect\\sign-client\\src\\controllers\\pairing.ts","C:\\Users\\user\\Desktop\\BCEndterm\\node_modules\\@walletconnect\\sign-client\\src\\controllers\\proposal.ts","C:\\Users\\user\\Desktop\\BCEndterm\\node_modules\\@walletconnect\\sign-client\\src\\controllers\\session.ts","C:\\Users\\user\\Desktop\\BCEndterm\\node_modules\\@walletconnect\\sign-client\\src\\client.ts","C:\\Users\\user\\Desktop\\BCEndterm\\node_modules\\@walletconnect\\sign-client\\src\\index.ts"],"sourcesContent":["// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction EventEmitter() {\n  this._events = this._events || {};\n  this._maxListeners = this._maxListeners || undefined;\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!isNumber(n) || n < 0 || isNaN(n))\n    throw TypeError('n must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nEventEmitter.prototype.emit = function(type) {\n  var er, handler, len, args, i, listeners;\n\n  if (!this._events)\n    this._events = {};\n\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events.error ||\n        (isObject(this._events.error) && !this._events.error.length)) {\n      er = arguments[1];\n      if (er instanceof Error) {\n        throw er; // Unhandled 'error' event\n      } else {\n        // At least give some kind of context to the user\n        var err = new Error('Uncaught, unspecified \"error\" event. (' + er + ')');\n        err.context = er;\n        throw err;\n      }\n    }\n  }\n\n  handler = this._events[type];\n\n  if (isUndefined(handler))\n    return false;\n\n  if (isFunction(handler)) {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n  } else if (isObject(handler)) {\n    args = Array.prototype.slice.call(arguments, 1);\n    listeners = handler.slice();\n    len = listeners.length;\n    for (i = 0; i < len; i++)\n      listeners[i].apply(this, args);\n  }\n\n  return true;\n};\n\nEventEmitter.prototype.addListener = function(type, listener) {\n  var m;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events)\n    this._events = {};\n\n  // To avoid recursion in the case that type === \"newListener\"! Before\n  // adding it to the listeners, first emit \"newListener\".\n  if (this._events.newListener)\n    this.emit('newListener', type,\n              isFunction(listener.listener) ?\n              listener.listener : listener);\n\n  if (!this._events[type])\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  else if (isObject(this._events[type]))\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  else\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n\n  // Check for listener leak\n  if (isObject(this._events[type]) && !this._events[type].warned) {\n    if (!isUndefined(this._maxListeners)) {\n      m = this._maxListeners;\n    } else {\n      m = EventEmitter.defaultMaxListeners;\n    }\n\n    if (m && m > 0 && this._events[type].length > m) {\n      this._events[type].warned = true;\n      console.error('(node) warning: possible EventEmitter memory ' +\n                    'leak detected. %d listeners added. ' +\n                    'Use emitter.setMaxListeners() to increase limit.',\n                    this._events[type].length);\n      if (typeof console.trace === 'function') {\n        // not supported in IE 10\n        console.trace();\n      }\n    }\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  var fired = false;\n\n  function g() {\n    this.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(this, arguments);\n    }\n  }\n\n  g.listener = listener;\n  this.on(type, g);\n\n  return this;\n};\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener = function(type, listener) {\n  var list, position, length, i;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events || !this._events[type])\n    return this;\n\n  list = this._events[type];\n  length = list.length;\n  position = -1;\n\n  if (list === listener ||\n      (isFunction(list.listener) && list.listener === listener)) {\n    delete this._events[type];\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n\n  } else if (isObject(list)) {\n    for (i = length; i-- > 0;) {\n      if (list[i] === listener ||\n          (list[i].listener && list[i].listener === listener)) {\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0)\n      return this;\n\n    if (list.length === 1) {\n      list.length = 0;\n      delete this._events[type];\n    } else {\n      list.splice(position, 1);\n    }\n\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  var key, listeners;\n\n  if (!this._events)\n    return this;\n\n  // not listening for removeListener, no need to emit\n  if (!this._events.removeListener) {\n    if (arguments.length === 0)\n      this._events = {};\n    else if (this._events[type])\n      delete this._events[type];\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    for (key in this._events) {\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = {};\n    return this;\n  }\n\n  listeners = this._events[type];\n\n  if (isFunction(listeners)) {\n    this.removeListener(type, listeners);\n  } else if (listeners) {\n    // LIFO order\n    while (listeners.length)\n      this.removeListener(type, listeners[listeners.length - 1]);\n  }\n  delete this._events[type];\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  var ret;\n  if (!this._events || !this._events[type])\n    ret = [];\n  else if (isFunction(this._events[type]))\n    ret = [this._events[type]];\n  else\n    ret = this._events[type].slice();\n  return ret;\n};\n\nEventEmitter.prototype.listenerCount = function(type) {\n  if (this._events) {\n    var evlistener = this._events[type];\n\n    if (isFunction(evlistener))\n      return 1;\n    else if (evlistener)\n      return evlistener.length;\n  }\n  return 0;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  return emitter.listenerCount(type);\n};\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\n","import { SignClientTypes } from \"@walletconnect/types\";\n\nexport const SIGN_CLIENT_PROTOCOL = \"wc\";\nexport const SIGN_CLIENT_VERSION = 2;\nexport const SIGN_CLIENT_CONTEXT = \"client\";\n\nexport const SIGN_CLIENT_STORAGE_PREFIX = `${SIGN_CLIENT_PROTOCOL}@${SIGN_CLIENT_VERSION}:${SIGN_CLIENT_CONTEXT}:`;\n\nexport const SIGN_CLIENT_DEFAULT = {\n  name: SIGN_CLIENT_CONTEXT,\n  logger: \"error\",\n  controller: false,\n  relayUrl: \"wss://relay.walletconnect.com\",\n};\n\nexport const SIGN_CLIENT_EVENTS: Record<SignClientTypes.Event, SignClientTypes.Event> = {\n  session_proposal: \"session_proposal\",\n  session_update: \"session_update\",\n  session_extend: \"session_extend\",\n  session_ping: \"session_ping\",\n  pairing_ping: \"pairing_ping\",\n  session_delete: \"session_delete\",\n  session_expire: \"session_expire\",\n  pairing_delete: \"pairing_delete\",\n  pairing_expire: \"pairing_expire\",\n  session_request: \"session_request\",\n  session_event: \"session_event\",\n  proposal_expire: \"proposal_expire\",\n};\n\nexport const SIGN_CLIENT_STORAGE_OPTIONS = {\n  database: \":memory:\",\n};\n","import { ONE_DAY } from \"@walletconnect/time\";\n\nexport const EXPIRER_CONTEXT = \"expirer\";\n\nexport const EXPIRER_EVENTS = {\n  created: \"expirer_created\",\n  deleted: \"expirer_deleted\",\n  expired: \"expirer_expired\",\n  sync: \"expirer_sync\",\n};\n\nexport const EXPIRER_STORAGE_VERSION = \"0.3\";\n\nexport const EXPIRER_DEFAULT_TTL = ONE_DAY;\n","export const HISTORY_EVENTS = {\n  created: \"history_created\",\n  updated: \"history_updated\",\n  deleted: \"history_deleted\",\n  sync: \"history_sync\",\n};\n\nexport const HISTORY_CONTEXT = \"history\";\n\nexport const HISTORY_STORAGE_VERSION = \"0.3\";\n","import { THIRTY_DAYS } from \"@walletconnect/time\";\n\nexport const PAIRING_CONTEXT = \"pairing\";\n\nexport const PAIRING_DEFAULT_TTL = THIRTY_DAYS;\n","import { THIRTY_DAYS } from \"@walletconnect/time\";\n\nexport const PROPOSAL_CONTEXT = \"proposal\";\n\nexport const PROPOSAL_EXPIRY = THIRTY_DAYS;\n","import { SEVEN_DAYS } from \"@walletconnect/time\";\n\nexport const SESSION_CONTEXT = \"session\";\n\nexport const SESSION_EXPIRY = SEVEN_DAYS;\n","import { EngineTypes } from \"@walletconnect/types\";\n\nexport const ENGINE_CONTEXT = \"engine\";\n\nexport const ENGINE_RPC_OPTS: EngineTypes.RpcOptsMap = {\n  wc_pairingDelete: {\n    req: {\n      // ttl: ONE_DAY,\n      prompt: false,\n      tag: 1000,\n    },\n    res: {\n      // ttl: ONE_DAY,\n      prompt: false,\n      tag: 1001,\n    },\n  },\n  wc_pairingPing: {\n    req: {\n      // ttl: THIRTY_SECONDS,\n      prompt: false,\n      tag: 1002,\n    },\n    res: {\n      // ttl: THIRTY_SECONDS,\n      prompt: false,\n      tag: 1003,\n    },\n  },\n  wc_sessionPropose: {\n    req: {\n      // ttl: FIVE_MINUTES,\n      prompt: true,\n      tag: 1100,\n    },\n    res: {\n      // ttl: FIVE_MINUTES,\n      prompt: false,\n      tag: 1101,\n    },\n  },\n  wc_sessionSettle: {\n    req: {\n      // ttl: FIVE_MINUTES,\n      prompt: false,\n      tag: 1102,\n    },\n    res: {\n      // ttl: FIVE_MINUTES,\n      prompt: false,\n      tag: 1103,\n    },\n  },\n  wc_sessionUpdate: {\n    req: {\n      // ttl: ONE_DAY,\n      prompt: false,\n      tag: 1104,\n    },\n    res: {\n      // ttl: ONE_DAY,\n      prompt: false,\n      tag: 1105,\n    },\n  },\n  wc_sessionExtend: {\n    req: {\n      // ttl: ONE_DAY,\n      prompt: false,\n      tag: 1106,\n    },\n    res: {\n      // ttl: ONE_DAY,\n      prompt: false,\n      tag: 1107,\n    },\n  },\n  wc_sessionRequest: {\n    req: {\n      // ttl: FIVE_MINUTES,\n      prompt: true,\n      tag: 1108,\n    },\n    res: {\n      // ttl: FIVE_MINUTES,\n      prompt: false,\n      tag: 1109,\n    },\n  },\n  wc_sessionEvent: {\n    req: {\n      // ttl: FIVE_MINUTES,\n      prompt: true,\n      tag: 1110,\n    },\n    res: {\n      // ttl: FIVE_MINUTES,\n      prompt: false,\n      tag: 1111,\n    },\n  },\n\n  wc_sessionDelete: {\n    req: {\n      // ttl: ONE_DAY,\n      prompt: false,\n      tag: 1112,\n    },\n    res: {\n      // ttl: ONE_DAY,\n      prompt: false,\n      tag: 1113,\n    },\n  },\n  wc_sessionPing: {\n    req: {\n      // ttl: THIRTY_SECONDS,\n      prompt: false,\n      tag: 1114,\n    },\n    res: {\n      // ttl: THIRTY_SECONDS,\n      prompt: false,\n      tag: 1115,\n    },\n  },\n};\n","import EventEmmiter from \"events\";\nimport { RELAYER_EVENTS, RELAYER_DEFAULT_PROTOCOL } from \"@walletconnect/core\";\nimport {\n  formatJsonRpcRequest,\n  formatJsonRpcResult,\n  formatJsonRpcError,\n  isJsonRpcRequest,\n  isJsonRpcResponse,\n  isJsonRpcResult,\n  isJsonRpcError,\n} from \"@walletconnect/jsonrpc-utils\";\nimport { FIVE_MINUTES } from \"@walletconnect/time\";\nimport {\n  IEngine,\n  EngineTypes,\n  IEngineEvents,\n  RelayerTypes,\n  EnginePrivate,\n  SessionTypes,\n  JsonRpcTypes,\n  ExpirerTypes,\n} from \"@walletconnect/types\";\nimport {\n  calcExpiry,\n  formatUri,\n  generateRandomBytes32,\n  parseUri,\n  parseExpirerTarget,\n  createDelayedPromise,\n  getInternalError,\n  getSdkError,\n  engineEvent,\n  isValidNamespaces,\n  isValidRelays,\n  isValidUrl,\n  isValidRelay,\n  isValidId,\n  isValidParams,\n  isValidString,\n  isValidErrorReason,\n  isValidNamespacesChainId,\n  isValidNamespacesRequest,\n  isValidNamespacesEvent,\n  isValidRequest,\n  isValidEvent,\n  isValidResponse,\n  isValidRequiredNamespaces,\n  isSessionCompatible,\n  isExpired,\n  isUndefined,\n  isConformingNamespaces,\n  isValidController,\n} from \"@walletconnect/utils\";\n\nimport {\n  EXPIRER_EVENTS,\n  SESSION_EXPIRY,\n  PROPOSAL_EXPIRY,\n  ENGINE_CONTEXT,\n  ENGINE_RPC_OPTS,\n} from \"../constants\";\n\nexport class Engine extends IEngine {\n  private events: IEngineEvents = new EventEmmiter();\n  private initialized = false;\n  public name = ENGINE_CONTEXT;\n\n  constructor(client: IEngine[\"client\"]) {\n    super(client);\n  }\n\n  public init: IEngine[\"init\"] = async () => {\n    if (!this.initialized) {\n      await this.cleanup();\n      this.registerRelayerEvents();\n      this.registerExpirerEvents();\n      this.initialized = true;\n    }\n  };\n\n  // ---------- Public ------------------------------------------------ //\n\n  public connect: IEngine[\"connect\"] = async (params) => {\n    this.isInitialized();\n    await this.isValidConnect(params);\n    const { pairingTopic, requiredNamespaces, relays } = params;\n    let topic = pairingTopic;\n    let uri: string | undefined;\n    let active = false;\n\n    if (topic) {\n      const pairing = this.client.pairing.get(topic);\n      active = pairing.active;\n    }\n\n    if (!topic || !active) {\n      const { topic: newTopic, uri: newUri } = await this.createPairing();\n      topic = newTopic;\n      uri = newUri;\n    }\n\n    const publicKey = await this.client.core.crypto.generateKeyPair();\n    const proposal = {\n      requiredNamespaces,\n      relays: relays ?? [{ protocol: RELAYER_DEFAULT_PROTOCOL }],\n      proposer: {\n        publicKey,\n        metadata: this.client.metadata,\n      },\n    };\n\n    const { reject, resolve, done: approval } = createDelayedPromise<SessionTypes.Struct>();\n    this.events.once<\"session_connect\">(\n      engineEvent(\"session_connect\"),\n      async ({ error, session }) => {\n        if (error) reject(error);\n        else if (session) {\n          session.self.publicKey = publicKey;\n          const completeSession = { ...session, requiredNamespaces };\n          await this.client.session.set(session.topic, completeSession);\n          await this.setExpiry(session.topic, session.expiry);\n          if (topic)\n            await this.client.pairing.update(topic, { peerMetadata: session.peer.metadata });\n          resolve(completeSession);\n        }\n      },\n    );\n\n    if (!topic) {\n      const { message } = getInternalError(\"NO_MATCHING_KEY\", `connect() pairing topic: ${topic}`);\n      throw new Error(message);\n    }\n\n    const id = await this.sendRequest(topic, \"wc_sessionPropose\", proposal);\n    const expiry = calcExpiry(FIVE_MINUTES);\n    await this.setProposal(id, { id, expiry, ...proposal });\n\n    return { uri, approval };\n  };\n\n  public pair: IEngine[\"pair\"] = async (params) => {\n    this.isInitialized();\n    this.isValidPair(params);\n    const { topic, symKey, relay } = parseUri(params.uri);\n    const expiry = calcExpiry(FIVE_MINUTES);\n    const pairing = { topic, relay, expiry, active: false };\n    await this.client.pairing.set(topic, pairing);\n    await this.client.core.crypto.setSymKey(symKey, topic);\n    await this.client.core.relayer.subscribe(topic, { relay });\n    await this.setExpiry(topic, expiry);\n\n    return pairing;\n  };\n\n  public approve: IEngine[\"approve\"] = async (params) => {\n    this.isInitialized();\n    await this.isValidApprove(params);\n    const { id, relayProtocol, namespaces } = params;\n    const { pairingTopic, proposer, requiredNamespaces } = this.client.proposal.get(id);\n\n    const selfPublicKey = await this.client.core.crypto.generateKeyPair();\n    const peerPublicKey = proposer.publicKey;\n    const sessionTopic = await this.client.core.crypto.generateSharedKey(\n      selfPublicKey,\n      peerPublicKey,\n    );\n    const sessionSettle = {\n      relay: { protocol: relayProtocol ?? \"irn\" },\n      namespaces,\n      requiredNamespaces,\n      controller: { publicKey: selfPublicKey, metadata: this.client.metadata },\n      expiry: calcExpiry(SESSION_EXPIRY),\n    };\n\n    await this.client.core.relayer.subscribe(sessionTopic);\n    const requestId = await this.sendRequest(sessionTopic, \"wc_sessionSettle\", sessionSettle);\n    const { done: acknowledged, resolve, reject } = createDelayedPromise<SessionTypes.Struct>();\n    this.events.once(engineEvent(\"session_approve\", requestId), ({ error }) => {\n      if (error) reject(error);\n      else resolve(this.client.session.get(sessionTopic));\n    });\n\n    const session = {\n      ...sessionSettle,\n      topic: sessionTopic,\n      acknowledged: false,\n      self: sessionSettle.controller,\n      peer: {\n        publicKey: proposer.publicKey,\n        metadata: proposer.metadata,\n      },\n      controller: selfPublicKey,\n    };\n    await this.client.session.set(sessionTopic, session);\n    await this.setExpiry(sessionTopic, calcExpiry(SESSION_EXPIRY));\n    if (pairingTopic)\n      await this.client.pairing.update(pairingTopic, { peerMetadata: session.peer.metadata });\n\n    if (pairingTopic && id) {\n      await this.sendResult<\"wc_sessionPropose\">(id, pairingTopic, {\n        relay: {\n          protocol: relayProtocol ?? \"irn\",\n        },\n        responderPublicKey: selfPublicKey,\n      });\n      await this.client.proposal.delete(id, getSdkError(\"USER_DISCONNECTED\"));\n      await this.activatePairing(pairingTopic);\n    }\n\n    return { topic: sessionTopic, acknowledged };\n  };\n\n  public reject: IEngine[\"reject\"] = async (params) => {\n    this.isInitialized();\n    await this.isValidReject(params);\n    const { id, reason } = params;\n    const { pairingTopic } = this.client.proposal.get(id);\n    if (pairingTopic) {\n      await this.sendError(id, pairingTopic, reason);\n      await this.client.proposal.delete(id, getSdkError(\"USER_DISCONNECTED\"));\n    }\n  };\n\n  public update: IEngine[\"update\"] = async (params) => {\n    this.isInitialized();\n    await this.isValidUpdate(params);\n    const { topic, namespaces } = params;\n    const id = await this.sendRequest(topic, \"wc_sessionUpdate\", { namespaces });\n    const { done: acknowledged, resolve, reject } = createDelayedPromise<void>();\n    this.events.once(engineEvent(\"session_update\", id), ({ error }) => {\n      if (error) reject(error);\n      else resolve();\n    });\n    await this.client.session.update(topic, { namespaces });\n\n    return { acknowledged };\n  };\n\n  public extend: IEngine[\"extend\"] = async (params) => {\n    this.isInitialized();\n    await this.isValidExtend(params);\n    const { topic } = params;\n    const id = await this.sendRequest(topic, \"wc_sessionExtend\", {});\n    const { done: acknowledged, resolve, reject } = createDelayedPromise<void>();\n    this.events.once(engineEvent(\"session_extend\", id), ({ error }) => {\n      if (error) reject(error);\n      else resolve();\n    });\n    await this.setExpiry(topic, calcExpiry(SESSION_EXPIRY));\n\n    return { acknowledged };\n  };\n\n  public request: IEngine[\"request\"] = async <T>(params: EngineTypes.RequestParams) => {\n    this.isInitialized();\n    await this.isValidRequest(params);\n    const { chainId, request, topic } = params;\n    const id = await this.sendRequest(topic, \"wc_sessionRequest\", { request, chainId });\n    const { done, resolve, reject } = createDelayedPromise<T>();\n    this.events.once<\"session_request\">(engineEvent(\"session_request\", id), ({ error, result }) => {\n      if (error) reject(error);\n      else resolve(result);\n    });\n    return await done();\n  };\n\n  public respond: IEngine[\"respond\"] = async (params) => {\n    this.isInitialized();\n    await this.isValidRespond(params);\n    const { topic, response } = params;\n    const { id } = response;\n    if (isJsonRpcResult(response)) {\n      await this.sendResult(id, topic, response.result);\n    } else if (isJsonRpcError(response)) {\n      await this.sendError(id, topic, response.error);\n    }\n  };\n\n  public ping: IEngine[\"ping\"] = async (params) => {\n    this.isInitialized();\n    await this.isValidPing(params);\n    const { topic } = params;\n    if (this.client.session.keys.includes(topic)) {\n      const id = await this.sendRequest(topic, \"wc_sessionPing\", {});\n      const { done, resolve, reject } = createDelayedPromise<void>();\n      this.events.once(engineEvent(\"session_ping\", id), ({ error }) => {\n        if (error) reject(error);\n        else resolve();\n      });\n      await done();\n    } else if (this.client.pairing.keys.includes(topic)) {\n      const id = await this.sendRequest(topic, \"wc_pairingPing\", {});\n      const { done, resolve, reject } = createDelayedPromise<void>();\n      this.events.once(engineEvent(\"pairing_ping\", id), ({ error }) => {\n        if (error) reject(error);\n        else resolve();\n      });\n      await done();\n    }\n  };\n\n  public emit: IEngine[\"emit\"] = async (params) => {\n    this.isInitialized();\n    await this.isValidEmit(params);\n    const { topic, event, chainId } = params;\n    await this.sendRequest(topic, \"wc_sessionEvent\", { event, chainId });\n  };\n\n  public disconnect: IEngine[\"disconnect\"] = async (params) => {\n    this.isInitialized();\n    await this.isValidDisconnect(params);\n    const { topic } = params;\n    if (this.client.session.keys.includes(topic)) {\n      await this.sendRequest(topic, \"wc_sessionDelete\", getSdkError(\"USER_DISCONNECTED\"));\n      await this.deleteSession(topic);\n    } else if (this.client.pairing.keys.includes(topic)) {\n      await this.sendRequest(topic, \"wc_pairingDelete\", getSdkError(\"USER_DISCONNECTED\"));\n      await this.deletePairing(topic);\n    }\n  };\n\n  public find: IEngine[\"find\"] = (params) => {\n    this.isInitialized();\n    return this.client.session.getAll().filter((session) => isSessionCompatible(session, params));\n  };\n\n  // ---------- Private Helpers --------------------------------------- //\n\n  private async createPairing() {\n    const symKey = generateRandomBytes32();\n    const topic = await this.client.core.crypto.setSymKey(symKey);\n    const expiry = calcExpiry(FIVE_MINUTES);\n    const relay = { protocol: RELAYER_DEFAULT_PROTOCOL };\n    const pairing = { topic, expiry, relay, active: false };\n    const uri = formatUri({\n      protocol: this.client.protocol,\n      version: this.client.version,\n      topic,\n      symKey,\n      relay,\n    });\n    await this.client.pairing.set(topic, pairing);\n    await this.client.core.relayer.subscribe(topic);\n    await this.setExpiry(topic, expiry);\n\n    return { topic, uri };\n  }\n\n  private activatePairing: EnginePrivate[\"activatePairing\"] = async (topic) => {\n    const expiry = calcExpiry(PROPOSAL_EXPIRY);\n    await this.client.pairing.update(topic, { active: true, expiry });\n    await this.setExpiry(topic, expiry);\n  };\n\n  private deleteSession: EnginePrivate[\"deleteSession\"] = async (topic) => {\n    const { self } = this.client.session.get(topic);\n    // Await the unsubscribe first to avoid deleting the symKey too early below.\n    await this.client.core.relayer.unsubscribe(topic);\n    await Promise.all([\n      this.client.session.delete(topic, getSdkError(\"USER_DISCONNECTED\")),\n      this.client.core.crypto.deleteKeyPair(self.publicKey),\n      this.client.core.crypto.deleteSymKey(topic),\n      this.client.expirer.del(topic),\n    ]);\n  };\n\n  private deletePairing: EnginePrivate[\"deleteSession\"] = async (topic) => {\n    // Await the unsubscribe first to avoid deleting the symKey too early below.\n    await this.client.core.relayer.unsubscribe(topic);\n    await Promise.all([\n      this.client.pairing.delete(topic, getSdkError(\"USER_DISCONNECTED\")),\n      this.client.core.crypto.deleteSymKey(topic),\n      this.client.expirer.del(topic),\n    ]);\n  };\n\n  private deleteProposal: EnginePrivate[\"deleteProposal\"] = async (id) => {\n    await Promise.all([\n      this.client.proposal.delete(id, getSdkError(\"USER_DISCONNECTED\")),\n      this.client.expirer.del(id),\n    ]);\n  };\n\n  private setExpiry: EnginePrivate[\"setExpiry\"] = async (topic, expiry) => {\n    if (this.client.pairing.keys.includes(topic)) {\n      await this.client.pairing.update(topic, { expiry });\n    } else if (this.client.session.keys.includes(topic)) {\n      await this.client.session.update(topic, { expiry });\n    }\n    this.client.expirer.set(topic, expiry);\n  };\n\n  private setProposal: EnginePrivate[\"setProposal\"] = async (id, proposal) => {\n    await this.client.proposal.set(id, proposal);\n    this.client.expirer.set(id, proposal.expiry);\n  };\n\n  private sendRequest: EnginePrivate[\"sendRequest\"] = async (topic, method, params) => {\n    const payload = formatJsonRpcRequest(method, params);\n    const message = await this.client.core.crypto.encode(topic, payload);\n    const opts = ENGINE_RPC_OPTS[method].req;\n    this.client.history.set(topic, payload);\n    await this.client.core.relayer.publish(topic, message, opts);\n\n    return payload.id;\n  };\n\n  private sendResult: EnginePrivate[\"sendResult\"] = async (id, topic, result) => {\n    const payload = formatJsonRpcResult(id, result);\n    const message = await this.client.core.crypto.encode(topic, payload);\n    const record = await this.client.history.get(topic, id);\n    const opts = ENGINE_RPC_OPTS[record.request.method].res;\n    await this.client.core.relayer.publish(topic, message, opts);\n    await this.client.history.resolve(payload);\n  };\n\n  private sendError: EnginePrivate[\"sendError\"] = async (id, topic, error) => {\n    const payload = formatJsonRpcError(id, error);\n    const message = await this.client.core.crypto.encode(topic, payload);\n    const record = await this.client.history.get(topic, id);\n    const opts = ENGINE_RPC_OPTS[record.request.method].res;\n    await this.client.core.relayer.publish(topic, message, opts);\n    await this.client.history.resolve(payload);\n  };\n\n  private cleanup: EnginePrivate[\"cleanup\"] = async () => {\n    const sessionTopics: string[] = [];\n    const pairingTopics: string[] = [];\n    const proposalIds: number[] = [];\n    this.client.session.getAll().forEach((session) => {\n      if (isExpired(session.expiry)) sessionTopics.push(session.topic);\n    });\n    this.client.pairing.getAll().forEach((pairing) => {\n      if (isExpired(pairing.expiry)) pairingTopics.push(pairing.topic);\n    });\n    this.client.proposal.getAll().forEach((proposal) => {\n      if (isExpired(proposal.expiry)) proposalIds.push(proposal.id);\n    });\n    await Promise.all([\n      ...sessionTopics.map(this.deleteSession),\n      ...pairingTopics.map(this.deletePairing),\n      ...proposalIds.map(this.deleteProposal),\n    ]);\n  };\n\n  private isInitialized() {\n    if (!this.initialized) {\n      const { message } = getInternalError(\"NOT_INITIALIZED\", this.name);\n      throw new Error(message);\n    }\n  }\n\n  // ---------- Relay Events Router ----------------------------------- //\n\n  private registerRelayerEvents() {\n    this.client.core.relayer.on(\n      RELAYER_EVENTS.message,\n      async (event: RelayerTypes.MessageEvent) => {\n        const { topic, message } = event;\n        const payload = await this.client.core.crypto.decode(topic, message);\n        if (isJsonRpcRequest(payload)) {\n          this.client.history.set(topic, payload);\n          this.onRelayEventRequest({ topic, payload });\n        } else if (isJsonRpcResponse(payload)) {\n          await this.client.history.resolve(payload);\n          this.onRelayEventResponse({ topic, payload });\n        }\n      },\n    );\n  }\n\n  private onRelayEventRequest: EnginePrivate[\"onRelayEventRequest\"] = (event) => {\n    const { topic, payload } = event;\n    const reqMethod = payload.method as JsonRpcTypes.WcMethod;\n\n    switch (reqMethod) {\n      case \"wc_sessionPropose\":\n        return this.onSessionProposeRequest(topic, payload);\n      case \"wc_sessionSettle\":\n        return this.onSessionSettleRequest(topic, payload);\n      case \"wc_sessionUpdate\":\n        return this.onSessionUpdateRequest(topic, payload);\n      case \"wc_sessionExtend\":\n        return this.onSessionExtendRequest(topic, payload);\n      case \"wc_sessionPing\":\n        return this.onSessionPingRequest(topic, payload);\n      case \"wc_pairingPing\":\n        return this.onPairingPingRequest(topic, payload);\n      case \"wc_sessionDelete\":\n        return this.onSessionDeleteRequest(topic, payload);\n      case \"wc_pairingDelete\":\n        return this.onPairingDeleteRequest(topic, payload);\n      case \"wc_sessionRequest\":\n        return this.onSessionRequest(topic, payload);\n      case \"wc_sessionEvent\":\n        return this.onSessionEventRequest(topic, payload);\n      default:\n        return this.client.logger.info(`Unsupported request method ${reqMethod}`);\n    }\n  };\n\n  private onRelayEventResponse: EnginePrivate[\"onRelayEventResponse\"] = async (event) => {\n    const { topic, payload } = event;\n    const record = await this.client.history.get(topic, payload.id);\n    const resMethod = record.request.method as JsonRpcTypes.WcMethod;\n\n    switch (resMethod) {\n      case \"wc_sessionPropose\":\n        return this.onSessionProposeResponse(topic, payload);\n      case \"wc_sessionSettle\":\n        return this.onSessionSettleResponse(topic, payload);\n      case \"wc_sessionUpdate\":\n        return this.onSessionUpdateResponse(topic, payload);\n      case \"wc_sessionExtend\":\n        return this.onSessionExtendResponse(topic, payload);\n      case \"wc_sessionPing\":\n        return this.onSessionPingResponse(topic, payload);\n      case \"wc_pairingPing\":\n        return this.onPairingPingResponse(topic, payload);\n      case \"wc_sessionRequest\":\n        return this.onSessionRequestResponse(topic, payload);\n      default:\n        return this.client.logger.info(`Unsupported response method ${resMethod}`);\n    }\n  };\n\n  // ---------- Relay Events Handlers --------------------------------- //\n\n  private onSessionProposeRequest: EnginePrivate[\"onSessionProposeRequest\"] = async (\n    topic,\n    payload,\n  ) => {\n    const { params, id } = payload;\n    try {\n      this.isValidConnect({ ...payload.params });\n      const expiry = calcExpiry(FIVE_MINUTES);\n      const proposal = { id, pairingTopic: topic, expiry, ...params };\n      await this.setProposal(id, proposal);\n      this.client.events.emit(\"session_proposal\", { id, params: proposal });\n    } catch (err: any) {\n      await this.sendError(id, topic, err);\n      this.client.logger.error(err);\n    }\n  };\n\n  private onSessionProposeResponse: EnginePrivate[\"onSessionProposeResponse\"] = async (\n    topic,\n    payload,\n  ) => {\n    const { id } = payload;\n    if (isJsonRpcResult(payload)) {\n      const { result } = payload;\n      this.client.logger.trace({ type: \"method\", method: \"onSessionProposeResponse\", result });\n      const proposal = this.client.proposal.get(id);\n      this.client.logger.trace({ type: \"method\", method: \"onSessionProposeResponse\", proposal });\n      const selfPublicKey = proposal.proposer.publicKey;\n      this.client.logger.trace({\n        type: \"method\",\n        method: \"onSessionProposeResponse\",\n        selfPublicKey,\n      });\n      const peerPublicKey = result.responderPublicKey;\n      this.client.logger.trace({\n        type: \"method\",\n        method: \"onSessionProposeResponse\",\n        peerPublicKey,\n      });\n      const sessionTopic = await this.client.core.crypto.generateSharedKey(\n        selfPublicKey,\n        peerPublicKey,\n      );\n      this.client.logger.trace({\n        type: \"method\",\n        method: \"onSessionProposeResponse\",\n        sessionTopic,\n      });\n      const subscriptionId = await this.client.core.relayer.subscribe(sessionTopic);\n      this.client.logger.trace({\n        type: \"method\",\n        method: \"onSessionProposeResponse\",\n        subscriptionId,\n      });\n      await this.activatePairing(topic);\n    } else if (isJsonRpcError(payload)) {\n      await this.client.proposal.delete(id, getSdkError(\"USER_DISCONNECTED\"));\n      this.events.emit(engineEvent(\"session_connect\"), { error: payload.error });\n    }\n  };\n\n  private onSessionSettleRequest: EnginePrivate[\"onSessionSettleRequest\"] = async (\n    topic,\n    payload,\n  ) => {\n    const { id, params } = payload;\n    try {\n      this.isValidSessionSettleRequest(params);\n      const { relay, controller, expiry, namespaces } = payload.params;\n      const session = {\n        topic,\n        relay,\n        expiry,\n        namespaces,\n        acknowledged: true,\n        controller: controller.publicKey,\n        self: {\n          publicKey: \"\",\n          metadata: this.client.metadata,\n        },\n        peer: {\n          publicKey: controller.publicKey,\n          metadata: controller.metadata,\n        },\n      };\n      await this.sendResult<\"wc_sessionSettle\">(payload.id, topic, true);\n      this.events.emit(engineEvent(\"session_connect\"), { session });\n    } catch (err: any) {\n      await this.sendError(id, topic, err);\n      this.client.logger.error(err);\n    }\n  };\n\n  private onSessionSettleResponse: EnginePrivate[\"onSessionSettleResponse\"] = async (\n    topic,\n    payload,\n  ) => {\n    const { id } = payload;\n    if (isJsonRpcResult(payload)) {\n      await this.client.session.update(topic, { acknowledged: true });\n      this.events.emit(engineEvent(\"session_approve\", id), {});\n    } else if (isJsonRpcError(payload)) {\n      await this.client.session.delete(topic, getSdkError(\"USER_DISCONNECTED\"));\n      this.events.emit(engineEvent(\"session_approve\", id), { error: payload.error });\n    }\n  };\n\n  private onSessionUpdateRequest: EnginePrivate[\"onSessionUpdateRequest\"] = async (\n    topic,\n    payload,\n  ) => {\n    const { params, id } = payload;\n    try {\n      this.isValidUpdate({ topic, ...params });\n      await this.client.session.update(topic, { namespaces: params.namespaces });\n      await this.sendResult<\"wc_sessionUpdate\">(id, topic, true);\n      this.client.events.emit(\"session_update\", { id, topic, params });\n    } catch (err: any) {\n      await this.sendError(id, topic, err);\n      this.client.logger.error(err);\n    }\n  };\n\n  private onSessionUpdateResponse: EnginePrivate[\"onSessionUpdateResponse\"] = (_topic, payload) => {\n    const { id } = payload;\n    if (isJsonRpcResult(payload)) {\n      this.events.emit(engineEvent(\"session_update\", id), {});\n    } else if (isJsonRpcError(payload)) {\n      this.events.emit(engineEvent(\"session_update\", id), { error: payload.error });\n    }\n  };\n\n  private onSessionExtendRequest: EnginePrivate[\"onSessionExtendRequest\"] = async (\n    topic,\n    payload,\n  ) => {\n    const { id } = payload;\n    try {\n      this.isValidExtend({ topic });\n      await this.setExpiry(topic, calcExpiry(SESSION_EXPIRY));\n      await this.sendResult<\"wc_sessionExtend\">(id, topic, true);\n      this.client.events.emit(\"session_extend\", { id, topic });\n    } catch (err: any) {\n      await this.sendError(id, topic, err);\n      this.client.logger.error(err);\n    }\n  };\n\n  private onSessionExtendResponse: EnginePrivate[\"onSessionExtendResponse\"] = (_topic, payload) => {\n    const { id } = payload;\n    if (isJsonRpcResult(payload)) {\n      this.events.emit(engineEvent(\"session_extend\", id), {});\n    } else if (isJsonRpcError(payload)) {\n      this.events.emit(engineEvent(\"session_extend\", id), { error: payload.error });\n    }\n  };\n\n  private onSessionPingRequest: EnginePrivate[\"onSessionPingRequest\"] = async (topic, payload) => {\n    const { id } = payload;\n    try {\n      this.isValidPing({ topic });\n      await this.sendResult<\"wc_sessionPing\">(id, topic, true);\n      this.client.events.emit(\"session_ping\", { id, topic });\n    } catch (err: any) {\n      await this.sendError(id, topic, err);\n      this.client.logger.error(err);\n    }\n  };\n\n  private onSessionPingResponse: EnginePrivate[\"onSessionPingResponse\"] = (_topic, payload) => {\n    const { id } = payload;\n    if (isJsonRpcResult(payload)) {\n      this.events.emit(engineEvent(\"session_ping\", id), {});\n    } else if (isJsonRpcError(payload)) {\n      this.events.emit(engineEvent(\"session_ping\", id), { error: payload.error });\n    }\n  };\n\n  private onPairingPingRequest: EnginePrivate[\"onPairingPingRequest\"] = async (topic, payload) => {\n    const { id } = payload;\n    try {\n      this.isValidPing({ topic });\n      await this.sendResult<\"wc_pairingPing\">(id, topic, true);\n      this.client.events.emit(\"pairing_ping\", { id, topic });\n    } catch (err: any) {\n      await this.sendError(id, topic, err);\n      this.client.logger.error(err);\n    }\n  };\n\n  private onPairingPingResponse: EnginePrivate[\"onPairingPingResponse\"] = (_topic, payload) => {\n    const { id } = payload;\n    if (isJsonRpcResult(payload)) {\n      this.events.emit(engineEvent(\"pairing_ping\", id), {});\n    } else if (isJsonRpcError(payload)) {\n      this.events.emit(engineEvent(\"pairing_ping\", id), { error: payload.error });\n    }\n  };\n\n  private onSessionDeleteRequest: EnginePrivate[\"onSessionDeleteRequest\"] = async (\n    topic,\n    payload,\n  ) => {\n    const { id } = payload;\n    try {\n      this.isValidDisconnect({ topic, reason: payload.params });\n      // RPC request needs to happen before deletion as it utalises session encryption\n      await this.sendResult<\"wc_sessionDelete\">(id, topic, true);\n      await this.deleteSession(topic);\n      this.client.events.emit(\"session_delete\", { id, topic });\n    } catch (err: any) {\n      await this.sendError(id, topic, err);\n      this.client.logger.error(err);\n    }\n  };\n\n  private onPairingDeleteRequest: EnginePrivate[\"onPairingDeleteRequest\"] = async (\n    topic,\n    payload,\n  ) => {\n    const { id } = payload;\n    try {\n      this.isValidDisconnect({ topic, reason: payload.params });\n      // RPC request needs to happen before deletion as it utalises pairing encryption\n      await this.sendResult<\"wc_pairingDelete\">(id, topic, true);\n      await this.deletePairing(topic);\n      this.client.events.emit(\"pairing_delete\", { id, topic });\n    } catch (err: any) {\n      await this.sendError(id, topic, err);\n      this.client.logger.error(err);\n    }\n  };\n\n  private onSessionRequest: EnginePrivate[\"onSessionRequest\"] = async (topic, payload) => {\n    const { id, params } = payload;\n    try {\n      this.isValidRequest({ topic, ...params });\n      this.client.events.emit(\"session_request\", { id, topic, params });\n    } catch (err: any) {\n      await this.sendError(id, topic, err);\n      this.client.logger.error(err);\n    }\n  };\n\n  private onSessionRequestResponse: EnginePrivate[\"onSessionRequestResponse\"] = (\n    _topic,\n    payload,\n  ) => {\n    const { id } = payload;\n    if (isJsonRpcResult(payload)) {\n      this.events.emit(engineEvent(\"session_request\", id), { result: payload.result });\n    } else if (isJsonRpcError(payload)) {\n      this.events.emit(engineEvent(\"session_request\", id), { error: payload.error });\n    }\n  };\n\n  private onSessionEventRequest: EnginePrivate[\"onSessionEventRequest\"] = async (\n    topic,\n    payload,\n  ) => {\n    const { id, params } = payload;\n    try {\n      this.isValidEmit({ topic, ...params });\n      this.client.events.emit(\"session_event\", { id, topic, params });\n    } catch (err: any) {\n      await this.sendError(id, topic, err);\n      this.client.logger.error(err);\n    }\n  };\n\n  // ---------- Expirer Events ---------------------------------------- //\n\n  private registerExpirerEvents() {\n    this.client.expirer.on(EXPIRER_EVENTS.expired, async (event: ExpirerTypes.Expiration) => {\n      const { topic, id } = parseExpirerTarget(event.target);\n      if (topic) {\n        if (this.client.session.keys.includes(topic)) {\n          await this.deleteSession(topic);\n          this.client.events.emit(\"session_expire\", { topic });\n        } else if (this.client.pairing.keys.includes(topic)) {\n          await this.deletePairing(topic);\n          this.client.events.emit(\"pairing_expire\", { topic });\n        }\n      } else if (id) {\n        await this.deleteProposal(id);\n      }\n    });\n  }\n\n  // ---------- Validation Helpers ------------------------------------ //\n  private async isValidPairingTopic(topic: any) {\n    if (!isValidString(topic, false)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `pairing topic should be a string: ${topic}`,\n      );\n      throw new Error(message);\n    }\n    if (!this.client.pairing.keys.includes(topic)) {\n      const { message } = getInternalError(\n        \"NO_MATCHING_KEY\",\n        `pairing topic doesn't exist: ${topic}`,\n      );\n      throw new Error(message);\n    }\n    if (isExpired(this.client.pairing.get(topic).expiry)) {\n      await this.deletePairing(topic);\n      const { message } = getInternalError(\"EXPIRED\", `pairing topic: ${topic}`);\n      throw new Error(message);\n    }\n  }\n\n  private async isValidSessionTopic(topic: any) {\n    if (!isValidString(topic, false)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `session topic should be a string: ${topic}`,\n      );\n      throw new Error(message);\n    }\n    if (!this.client.session.keys.includes(topic)) {\n      const { message } = getInternalError(\n        \"NO_MATCHING_KEY\",\n        `session topic doesn't exist: ${topic}`,\n      );\n      throw new Error(message);\n    }\n    if (isExpired(this.client.session.get(topic).expiry)) {\n      await this.deleteSession(topic);\n      const { message } = getInternalError(\"EXPIRED\", `session topic: ${topic}`);\n      throw new Error(message);\n    }\n  }\n\n  private async isValidSessionOrPairingTopic(topic: string) {\n    if (this.client.session.keys.includes(topic)) await this.isValidSessionTopic(topic);\n    else if (this.client.pairing.keys.includes(topic)) await this.isValidPairingTopic(topic);\n    else if (!isValidString(topic, false)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `session or pairing topic should be a string: ${topic}`,\n      );\n      throw new Error(message);\n    } else {\n      const { message } = getInternalError(\n        \"NO_MATCHING_KEY\",\n        `session or pairing topic doesn't exist: ${topic}`,\n      );\n      throw new Error(message);\n    }\n  }\n\n  private async isValidProposalId(id: any) {\n    if (!isValidId(id)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `proposal id should be a number: ${id}`,\n      );\n      throw new Error(message);\n    }\n    if (!this.client.proposal.keys.includes(id)) {\n      const { message } = getInternalError(\"NO_MATCHING_KEY\", `proposal id doesn't exist: ${id}`);\n      throw new Error(message);\n    }\n    if (isExpired(this.client.proposal.get(id).expiry)) {\n      await this.deleteProposal(id);\n      const { message } = getInternalError(\"EXPIRED\", `proposal id: ${id}`);\n      throw new Error(message);\n    }\n  }\n\n  // ---------- Validation  ------------------------------------------- //\n\n  private isValidConnect: EnginePrivate[\"isValidConnect\"] = async (params) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `connect() params: ${JSON.stringify(params)}`,\n      );\n      throw new Error(message);\n    }\n    const { pairingTopic, requiredNamespaces, relays } = params;\n    if (!isUndefined(pairingTopic)) await this.isValidPairingTopic(pairingTopic);\n    const validRequiredNamespacesError = isValidRequiredNamespaces(requiredNamespaces, \"connect()\");\n    if (validRequiredNamespacesError) throw new Error(validRequiredNamespacesError.message);\n    if (!isValidRelays(relays, true)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `connect() relays: ${relays}`);\n      throw new Error(message);\n    }\n  };\n\n  private isValidPair: EnginePrivate[\"isValidPair\"] = (params) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `pair() params: ${params}`);\n      throw new Error(message);\n    }\n    if (!isValidUrl(params.uri)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `pair() uri: ${params.uri}`);\n      throw new Error(message);\n    }\n  };\n\n  private isValidApprove: EnginePrivate[\"isValidApprove\"] = async (params) => {\n    if (!isValidParams(params))\n      throw new Error(\n        getInternalError(\"MISSING_OR_INVALID\", `approve() params: ${params}`).message,\n      );\n    const { id, namespaces, relayProtocol } = params;\n    await this.isValidProposalId(id);\n    const proposal = this.client.proposal.get(id);\n    const validNamespacesError = isValidNamespaces(namespaces, \"approve()\");\n    if (validNamespacesError) throw new Error(validNamespacesError.message);\n    const conformingNamespacesError = isConformingNamespaces(\n      proposal.requiredNamespaces,\n      namespaces,\n      \"update()\",\n    );\n    if (conformingNamespacesError) throw new Error(conformingNamespacesError.message);\n    if (!isValidString(relayProtocol, true)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `approve() relayProtocol: ${relayProtocol}`,\n      );\n      throw new Error(message);\n    }\n  };\n\n  private isValidReject: EnginePrivate[\"isValidReject\"] = async (params) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `reject() params: ${params}`);\n      throw new Error(message);\n    }\n    const { id, reason } = params;\n    await this.isValidProposalId(id);\n    if (!isValidErrorReason(reason)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `reject() reason: ${JSON.stringify(reason)}`,\n      );\n      throw new Error(message);\n    }\n  };\n\n  private isValidSessionSettleRequest: EnginePrivate[\"isValidSessionSettleRequest\"] = (params) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `onSessionSettleRequest() params: ${params}`,\n      );\n      throw new Error(message);\n    }\n    const { relay, controller, namespaces, expiry } = params;\n    if (!isValidRelay(relay)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `onSessionSettleRequest() relay protocol should be a string`,\n      );\n      throw new Error(message);\n    }\n    const validControllerError = isValidController(controller, \"onSessionSettleRequest()\");\n    if (validControllerError) throw new Error(validControllerError.message);\n    const validNamespacesError = isValidNamespaces(namespaces, \"onSessionSettleRequest()\");\n    if (validNamespacesError) throw new Error(validNamespacesError.message);\n    if (isExpired(expiry)) {\n      const { message } = getInternalError(\"EXPIRED\", `onSessionSettleRequest()`);\n      throw new Error(message);\n    }\n  };\n\n  private isValidUpdate: EnginePrivate[\"isValidUpdate\"] = async (params) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `update() params: ${params}`);\n      throw new Error(message);\n    }\n    const { topic, namespaces } = params;\n    await this.isValidSessionTopic(topic);\n    const session = this.client.session.get(topic);\n    const validNamespacesError = isValidNamespaces(namespaces, \"update()\");\n    if (validNamespacesError) throw new Error(validNamespacesError.message);\n    const conformingNamespacesError = isConformingNamespaces(\n      session.requiredNamespaces,\n      namespaces,\n      \"update()\",\n    );\n    if (conformingNamespacesError) throw new Error(conformingNamespacesError.message);\n    // TODO(ilja) - check if wallet\n  };\n\n  private isValidExtend: EnginePrivate[\"isValidExtend\"] = async (params) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `extend() params: ${params}`);\n      throw new Error(message);\n    }\n    const { topic } = params;\n    await this.isValidSessionTopic(topic);\n    // TODO(ilja) - check if wallet\n  };\n\n  private isValidRequest: EnginePrivate[\"isValidRequest\"] = async (params) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `request() params: ${params}`);\n      throw new Error(message);\n    }\n    const { topic, request, chainId } = params;\n    await this.isValidSessionTopic(topic);\n    const { namespaces } = this.client.session.get(topic);\n    if (!isValidNamespacesChainId(namespaces, chainId)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `request() chainId: ${chainId}`);\n      throw new Error(message);\n    }\n    if (!isValidRequest(request)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `request() ${JSON.stringify(request)}`,\n      );\n      throw new Error(message);\n    }\n    if (!isValidNamespacesRequest(namespaces, chainId, request.method)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `request() method: ${request.method}`,\n      );\n      throw new Error(message);\n    }\n  };\n\n  private isValidRespond: EnginePrivate[\"isValidRespond\"] = async (params) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `respond() params: ${params}`);\n      throw new Error(message);\n    }\n    const { topic, response } = params;\n    await this.isValidSessionTopic(topic);\n    if (!isValidResponse(response)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `respond() response: ${JSON.stringify(response)}`,\n      );\n      throw new Error(message);\n    }\n  };\n\n  private isValidPing: EnginePrivate[\"isValidPing\"] = async (params) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `ping() params: ${params}`);\n      throw new Error(message);\n    }\n    const { topic } = params;\n    await this.isValidSessionOrPairingTopic(topic);\n  };\n\n  private isValidEmit: EnginePrivate[\"isValidEmit\"] = async (params) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `emit() params: ${params}`);\n      throw new Error(message);\n    }\n    const { topic, event, chainId } = params;\n    await this.isValidSessionTopic(topic);\n    const { namespaces } = this.client.session.get(topic);\n    if (!isValidNamespacesChainId(namespaces, chainId)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `emit() chainId: ${chainId}`);\n      throw new Error(message);\n    }\n    if (!isValidEvent(event)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `emit() event: ${JSON.stringify(event)}`,\n      );\n      throw new Error(message);\n    }\n    if (!isValidNamespacesEvent(namespaces, chainId, event.name)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `emit() event: ${JSON.stringify(event)}`,\n      );\n      throw new Error(message);\n    }\n  };\n\n  private isValidDisconnect: EnginePrivate[\"isValidDisconnect\"] = async (params) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `disconnect() params: ${params}`);\n      throw new Error(message);\n    }\n    const { topic } = params;\n    await this.isValidSessionOrPairingTopic(topic);\n  };\n}\n","import { HEARTBEAT_EVENTS } from \"@walletconnect/heartbeat\";\nimport { generateChildLogger, getLoggerContext } from \"@walletconnect/logger\";\nimport { toMiliseconds } from \"@walletconnect/time\";\nimport { ExpirerTypes, ICore, IExpirer } from \"@walletconnect/types\";\nimport { getInternalError, formatIdTarget, formatTopicTarget } from \"@walletconnect/utils\";\nimport { EventEmitter } from \"events\";\nimport { Logger } from \"pino\";\nimport {\n  SIGN_CLIENT_STORAGE_PREFIX,\n  EXPIRER_CONTEXT,\n  EXPIRER_EVENTS,\n  EXPIRER_STORAGE_VERSION,\n} from \"../constants\";\n\nexport class Expirer extends IExpirer {\n  public expirations = new Map<string, ExpirerTypes.Expiration>();\n  public events = new EventEmitter();\n  public name = EXPIRER_CONTEXT;\n  public version = EXPIRER_STORAGE_VERSION;\n\n  private cached: ExpirerTypes.Expiration[] = [];\n  private initialized = false;\n\n  private storagePrefix = SIGN_CLIENT_STORAGE_PREFIX;\n\n  constructor(public core: ICore, public logger: Logger) {\n    super(core, logger);\n    this.logger = generateChildLogger(logger, this.name);\n  }\n\n  public init: IExpirer[\"init\"] = async () => {\n    if (!this.initialized) {\n      this.logger.trace(`Initialized`);\n      await this.restore();\n      this.cached.forEach((expiration) => this.expirations.set(expiration.target, expiration));\n      this.cached = [];\n      this.registerEventListeners();\n      this.initialized = true;\n    }\n  };\n\n  get context(): string {\n    return getLoggerContext(this.logger);\n  }\n\n  get storageKey(): string {\n    return this.storagePrefix + this.version + \"//\" + this.name;\n  }\n\n  get length(): number {\n    return this.expirations.size;\n  }\n\n  get keys(): string[] {\n    return Array.from(this.expirations.keys());\n  }\n\n  get values(): ExpirerTypes.Expiration[] {\n    return Array.from(this.expirations.values());\n  }\n\n  public has: IExpirer[\"has\"] = (key) => {\n    try {\n      const target = this.formatTarget(key);\n      const expiration = this.getExpiration(target);\n      return typeof expiration !== \"undefined\";\n    } catch (e) {\n      // ignore\n      return false;\n    }\n  };\n\n  public set: IExpirer[\"set\"] = (key, expiry) => {\n    this.isInitialized();\n    const target = this.formatTarget(key);\n    const expiration = { target, expiry };\n    this.expirations.set(target, expiration);\n    this.checkExpiry(target, expiration);\n    this.events.emit(EXPIRER_EVENTS.created, {\n      target,\n      expiration,\n    } as ExpirerTypes.Created);\n  };\n\n  public get: IExpirer[\"get\"] = (key) => {\n    this.isInitialized();\n    const target = this.formatTarget(key);\n    return this.getExpiration(target);\n  };\n\n  public del: IExpirer[\"del\"] = (key) => {\n    this.isInitialized();\n    const target = this.formatTarget(key);\n    const exists = this.has(target);\n    if (exists) {\n      const expiration = this.getExpiration(target);\n      this.expirations.delete(target);\n      this.events.emit(EXPIRER_EVENTS.deleted, {\n        target,\n        expiration,\n      } as ExpirerTypes.Deleted);\n    }\n  };\n\n  public on: IExpirer[\"on\"] = (event, listener) => {\n    this.events.on(event, listener);\n  };\n\n  public once: IExpirer[\"once\"] = (event, listener) => {\n    this.events.once(event, listener);\n  };\n\n  public off: IExpirer[\"off\"] = (event, listener) => {\n    this.events.off(event, listener);\n  };\n\n  public removeListener: IExpirer[\"removeListener\"] = (event, listener) => {\n    this.events.removeListener(event, listener);\n  };\n\n  // ---------- Private ----------------------------------------------- //\n\n  private formatTarget(key: string | number) {\n    if (typeof key === \"string\") {\n      return formatTopicTarget(key);\n    } else if (typeof key === \"number\") {\n      return formatIdTarget(key);\n    }\n    const { message } = getInternalError(\"UNKNOWN_TYPE\", `Target type: ${typeof key}`);\n    throw new Error(message);\n  }\n\n  private async setExpirations(expirations: ExpirerTypes.Expiration[]): Promise<void> {\n    await this.core.storage.setItem<ExpirerTypes.Expiration[]>(this.storageKey, expirations);\n  }\n\n  private async getExpirations(): Promise<ExpirerTypes.Expiration[] | undefined> {\n    const expirations = await this.core.storage.getItem<ExpirerTypes.Expiration[]>(this.storageKey);\n    return expirations;\n  }\n\n  private async persist() {\n    await this.setExpirations(this.values);\n    this.events.emit(EXPIRER_EVENTS.sync);\n  }\n\n  private async restore() {\n    try {\n      const persisted = await this.getExpirations();\n      if (typeof persisted === \"undefined\") return;\n      if (!persisted.length) return;\n      if (this.expirations.size) {\n        const { message } = getInternalError(\"RESTORE_WILL_OVERRIDE\", this.name);\n        this.logger.error(message);\n        throw new Error(message);\n      }\n      this.cached = persisted;\n      this.logger.debug(`Successfully Restored expirations for ${this.name}`);\n      this.logger.trace({ type: \"method\", method: \"restore\", expirations: this.values });\n    } catch (e) {\n      this.logger.debug(`Failed to Restore expirations for ${this.name}`);\n      this.logger.error(e as any);\n    }\n  }\n\n  private getExpiration(target: string): ExpirerTypes.Expiration {\n    const expiration = this.expirations.get(target);\n    if (!expiration) {\n      const { message } = getInternalError(\"NO_MATCHING_KEY\", `${this.name}: ${target}`);\n      this.logger.error(message);\n      throw new Error(message);\n    }\n    return expiration;\n  }\n\n  private checkExpiry(target: string, expiration: ExpirerTypes.Expiration): void {\n    const { expiry } = expiration;\n    const msToTimeout = toMiliseconds(expiry) - Date.now();\n    if (msToTimeout <= 0) this.expire(target, expiration);\n  }\n\n  private expire(target: string, expiration: ExpirerTypes.Expiration): void {\n    this.expirations.delete(target);\n    this.events.emit(EXPIRER_EVENTS.expired, {\n      target,\n      expiration,\n    } as ExpirerTypes.Expired);\n  }\n\n  private checkExpirations(): void {\n    this.expirations.forEach((expiration, target) => this.checkExpiry(target, expiration));\n  }\n\n  private registerEventListeners(): void {\n    this.core.heartbeat.on(HEARTBEAT_EVENTS.pulse, () => this.checkExpirations());\n    this.events.on(EXPIRER_EVENTS.created, (createdEvent: ExpirerTypes.Created) => {\n      const eventName = EXPIRER_EVENTS.created;\n      this.logger.info(`Emitting ${eventName}`);\n      this.logger.debug({ type: \"event\", event: eventName, data: createdEvent });\n      this.persist();\n    });\n    this.events.on(EXPIRER_EVENTS.expired, (expiredEvent: ExpirerTypes.Expired) => {\n      const eventName = EXPIRER_EVENTS.expired;\n      this.logger.info(`Emitting ${eventName}`);\n      this.logger.debug({ type: \"event\", event: eventName, data: expiredEvent });\n      this.persist();\n    });\n    this.events.on(EXPIRER_EVENTS.deleted, (deletedEvent: ExpirerTypes.Deleted) => {\n      const eventName = EXPIRER_EVENTS.deleted;\n      this.logger.info(`Emitting ${eventName}`);\n      this.logger.debug({ type: \"event\", event: eventName, data: deletedEvent });\n      this.persist();\n    });\n  }\n\n  private isInitialized() {\n    if (!this.initialized) {\n      const { message } = getInternalError(\"NOT_INITIALIZED\", this.name);\n      throw new Error(message);\n    }\n  }\n}\n","import { formatJsonRpcRequest, isJsonRpcError } from \"@walletconnect/jsonrpc-utils\";\nimport { generateChildLogger, getLoggerContext } from \"@walletconnect/logger\";\nimport { IJsonRpcHistory, JsonRpcRecord, RequestEvent, ICore } from \"@walletconnect/types\";\nimport { getInternalError } from \"@walletconnect/utils\";\nimport { EventEmitter } from \"events\";\nimport { Logger } from \"pino\";\nimport {\n  SIGN_CLIENT_STORAGE_PREFIX,\n  HISTORY_CONTEXT,\n  HISTORY_EVENTS,\n  HISTORY_STORAGE_VERSION,\n} from \"../constants\";\n\nexport class JsonRpcHistory extends IJsonRpcHistory {\n  public records = new Map<number, JsonRpcRecord>();\n  public events = new EventEmitter();\n  public name = HISTORY_CONTEXT;\n  public version = HISTORY_STORAGE_VERSION;\n  private cached: JsonRpcRecord[] = [];\n  private initialized = false;\n\n  private storagePrefix = SIGN_CLIENT_STORAGE_PREFIX;\n\n  constructor(public core: ICore, public logger: Logger) {\n    super(core, logger);\n    this.logger = generateChildLogger(logger, this.name);\n  }\n\n  public init: IJsonRpcHistory[\"init\"] = async () => {\n    if (!this.initialized) {\n      this.logger.trace(`Initialized`);\n      await this.restore();\n      this.cached.forEach((record) => this.records.set(record.id, record));\n      this.cached = [];\n      this.registerEventListeners();\n      this.initialized = true;\n    }\n  };\n\n  get context(): string {\n    return getLoggerContext(this.logger);\n  }\n\n  get storageKey(): string {\n    return this.storagePrefix + this.version + \"//\" + this.name;\n  }\n\n  get size(): number {\n    return this.records.size;\n  }\n\n  get keys(): number[] {\n    return Array.from(this.records.keys());\n  }\n\n  get values() {\n    return Array.from(this.records.values());\n  }\n\n  get pending(): RequestEvent[] {\n    const requests: RequestEvent[] = [];\n    this.values.forEach((record) => {\n      if (typeof record.response !== \"undefined\") return;\n      const requestEvent: RequestEvent = {\n        topic: record.topic,\n        request: formatJsonRpcRequest(record.request.method, record.request.params, record.id),\n        chainId: record.chainId,\n      };\n      return requests.push(requestEvent);\n    });\n    return requests;\n  }\n\n  public set: IJsonRpcHistory[\"set\"] = (topic, request, chainId) => {\n    this.isInitialized();\n    this.logger.debug(`Setting JSON-RPC request history record`);\n    this.logger.trace({ type: \"method\", method: \"set\", topic, request, chainId });\n    if (this.records.has(request.id)) return;\n    const record: JsonRpcRecord = {\n      id: request.id,\n      topic,\n      request: { method: request.method, params: request.params || null },\n      chainId,\n    };\n    this.records.set(record.id, record);\n    this.events.emit(HISTORY_EVENTS.created, record);\n  };\n\n  public resolve: IJsonRpcHistory[\"resolve\"] = async (response) => {\n    this.isInitialized();\n    this.logger.debug(`Updating JSON-RPC response history record`);\n    this.logger.trace({ type: \"method\", method: \"update\", response });\n    if (!this.records.has(response.id)) return;\n    const record = await this.getRecord(response.id);\n    if (typeof record.response !== \"undefined\") return;\n    record.response = isJsonRpcError(response)\n      ? { error: response.error }\n      : { result: response.result };\n    this.records.set(record.id, record);\n    this.events.emit(HISTORY_EVENTS.updated, record);\n  };\n\n  public get: IJsonRpcHistory[\"get\"] = async (topic, id) => {\n    this.isInitialized();\n    this.logger.debug(`Getting record`);\n    this.logger.trace({ type: \"method\", method: \"get\", topic, id });\n    const record = await this.getRecord(id);\n    if (record.topic !== topic) {\n      const { message } = getInternalError(\"MISMATCHED_TOPIC\", `${this.name}, ${id}`);\n      this.logger.error(message);\n      throw new Error(message);\n    }\n    return record;\n  };\n\n  public delete: IJsonRpcHistory[\"delete\"] = (topic, id) => {\n    this.isInitialized();\n    this.logger.debug(`Deleting record`);\n    this.logger.trace({ type: \"method\", method: \"delete\", id });\n    this.values.forEach((record: JsonRpcRecord) => {\n      if (record.topic === topic) {\n        if (typeof id !== \"undefined\" && record.id !== id) return;\n        this.records.delete(record.id);\n        this.events.emit(HISTORY_EVENTS.deleted, record);\n      }\n    });\n  };\n\n  public exists: IJsonRpcHistory[\"exists\"] = async (topic, id) => {\n    this.isInitialized();\n    if (!this.records.has(id)) return false;\n    const record = await this.getRecord(id);\n    return record.topic === topic;\n  };\n\n  public on: IJsonRpcHistory[\"on\"] = (event, listener) => {\n    this.events.on(event, listener);\n  };\n\n  public once: IJsonRpcHistory[\"once\"] = (event, listener) => {\n    this.events.once(event, listener);\n  };\n\n  public off: IJsonRpcHistory[\"off\"] = (event, listener) => {\n    this.events.off(event, listener);\n  };\n\n  public removeListener: IJsonRpcHistory[\"removeListener\"] = (event, listener) => {\n    this.events.removeListener(event, listener);\n  };\n\n  // ---------- Private ----------------------------------------------- //\n\n  private async setJsonRpcRecords(records: JsonRpcRecord[]): Promise<void> {\n    await this.core.storage.setItem<JsonRpcRecord[]>(this.storageKey, records);\n  }\n\n  private async getJsonRpcRecords(): Promise<JsonRpcRecord[] | undefined> {\n    const records = await this.core.storage.getItem<JsonRpcRecord[]>(this.storageKey);\n    return records;\n  }\n\n  private getRecord(id: number) {\n    this.isInitialized();\n    const record = this.records.get(id);\n    if (!record) {\n      const { message } = getInternalError(\"NO_MATCHING_KEY\", `${this.name}: ${id}`);\n      throw new Error(message);\n    }\n    return record;\n  }\n\n  private async persist() {\n    await this.setJsonRpcRecords(this.values);\n    this.events.emit(HISTORY_EVENTS.sync);\n  }\n\n  private async restore() {\n    try {\n      const persisted = await this.getJsonRpcRecords();\n      if (typeof persisted === \"undefined\") return;\n      if (!persisted.length) return;\n      if (this.records.size) {\n        const { message } = getInternalError(\"RESTORE_WILL_OVERRIDE\", this.name);\n        this.logger.error(message);\n        throw new Error(message);\n      }\n      this.cached = persisted;\n      this.logger.debug(`Successfully Restored records for ${this.name}`);\n      this.logger.trace({ type: \"method\", method: \"restore\", records: this.values });\n    } catch (e) {\n      this.logger.debug(`Failed to Restore records for ${this.name}`);\n      this.logger.error(e as any);\n    }\n  }\n\n  private registerEventListeners(): void {\n    this.events.on(HISTORY_EVENTS.created, (record: JsonRpcRecord) => {\n      const eventName = HISTORY_EVENTS.created;\n      this.logger.info(`Emitting ${eventName}`);\n      this.logger.debug({ type: \"event\", event: eventName, record });\n      this.persist();\n    });\n    this.events.on(HISTORY_EVENTS.updated, (record: JsonRpcRecord) => {\n      const eventName = HISTORY_EVENTS.updated;\n      this.logger.info(`Emitting ${eventName}`);\n      this.logger.debug({ type: \"event\", event: eventName, record });\n      this.persist();\n    });\n\n    this.events.on(HISTORY_EVENTS.deleted, (record: JsonRpcRecord) => {\n      const eventName = HISTORY_EVENTS.deleted;\n      this.logger.info(`Emitting ${eventName}`);\n      this.logger.debug({ type: \"event\", event: eventName, record });\n      this.persist();\n    });\n  }\n\n  private isInitialized() {\n    if (!this.initialized) {\n      const { message } = getInternalError(\"NOT_INITIALIZED\", this.name);\n      throw new Error(message);\n    }\n  }\n}\n","import { Logger } from \"pino\";\nimport { Store } from \"@walletconnect/core\";\nimport { ICore, PairingTypes } from \"@walletconnect/types\";\n\nimport { SIGN_CLIENT_STORAGE_PREFIX, PAIRING_CONTEXT } from \"../constants\";\n\nexport class Pairing extends Store<string, PairingTypes.Struct> {\n  constructor(public core: ICore, public logger: Logger) {\n    super(core, logger, PAIRING_CONTEXT, SIGN_CLIENT_STORAGE_PREFIX);\n  }\n}\n","import { Logger } from \"pino\";\nimport { Store } from \"@walletconnect/core\";\nimport { ICore, ProposalTypes } from \"@walletconnect/types\";\n\nimport { SIGN_CLIENT_STORAGE_PREFIX, PROPOSAL_CONTEXT } from \"../constants\";\n\nexport class Proposal extends Store<number, ProposalTypes.Struct> {\n  constructor(public core: ICore, public logger: Logger) {\n    super(core, logger, PROPOSAL_CONTEXT, SIGN_CLIENT_STORAGE_PREFIX);\n  }\n}\n","import { Logger } from \"pino\";\nimport { Store } from \"@walletconnect/core\";\nimport { ICore, SessionTypes } from \"@walletconnect/types\";\n\nimport { SIGN_CLIENT_STORAGE_PREFIX, SESSION_CONTEXT } from \"../constants\";\n\nexport class Session extends Store<string, SessionTypes.Struct> {\n  constructor(public core: ICore, public logger: Logger) {\n    super(core, logger, SESSION_CONTEXT, SIGN_CLIENT_STORAGE_PREFIX);\n  }\n}\n","import { Core } from \"@walletconnect/core\";\nimport {\n  generateChildLogger,\n  getDefaultLoggerOptions,\n  getLoggerContext,\n} from \"@walletconnect/logger\";\nimport { SignClientTypes, ISignClient, ISignClientEvents, EngineTypes } from \"@walletconnect/types\";\nimport { getAppMetadata } from \"@walletconnect/utils\";\nimport { EventEmitter } from \"events\";\nimport pino from \"pino\";\nimport { SIGN_CLIENT_DEFAULT, SIGN_CLIENT_PROTOCOL, SIGN_CLIENT_VERSION } from \"./constants\";\nimport { Engine, Expirer, JsonRpcHistory, Pairing, Proposal, Session } from \"./controllers\";\n\nexport class SignClient extends ISignClient {\n  public readonly protocol = SIGN_CLIENT_PROTOCOL;\n  public readonly version = SIGN_CLIENT_VERSION;\n  public readonly name: ISignClient[\"name\"] = SIGN_CLIENT_DEFAULT.name;\n  public readonly metadata: ISignClient[\"metadata\"];\n\n  public core: ISignClient[\"core\"];\n  public logger: ISignClient[\"logger\"];\n  public events: ISignClient[\"events\"] = new EventEmitter();\n  public engine: ISignClient[\"engine\"];\n  public pairing: ISignClient[\"pairing\"];\n  public session: ISignClient[\"session\"];\n  public proposal: ISignClient[\"proposal\"];\n  public history: ISignClient[\"history\"];\n  public expirer: ISignClient[\"expirer\"];\n\n  static async init(opts?: SignClientTypes.Options) {\n    const client = new SignClient(opts);\n    await client.initialize();\n\n    return client;\n  }\n\n  constructor(opts?: SignClientTypes.Options) {\n    super(opts);\n\n    this.name = opts?.name || SIGN_CLIENT_DEFAULT.name;\n    this.metadata = opts?.metadata || getAppMetadata();\n\n    const logger =\n      typeof opts?.logger !== \"undefined\" && typeof opts?.logger !== \"string\"\n        ? opts.logger\n        : pino(getDefaultLoggerOptions({ level: opts?.logger || SIGN_CLIENT_DEFAULT.logger }));\n\n    this.core = opts?.core || new Core(opts);\n    this.logger = generateChildLogger(logger, this.name);\n    this.pairing = new Pairing(this.core, this.logger);\n    this.session = new Session(this.core, this.logger);\n    this.proposal = new Proposal(this.core, this.logger);\n    this.history = new JsonRpcHistory(this.core, this.logger);\n    this.expirer = new Expirer(this.core, this.logger);\n    this.engine = new Engine(this);\n  }\n\n  get context() {\n    return getLoggerContext(this.logger);\n  }\n\n  // ---------- Events ----------------------------------------------- //\n\n  public on: ISignClientEvents[\"on\"] = (name, listener) => {\n    return this.events.on(name, listener);\n  };\n\n  public once: ISignClientEvents[\"once\"] = (name, listener) => {\n    return this.events.once(name, listener);\n  };\n\n  public off: ISignClientEvents[\"off\"] = (name, listener) => {\n    return this.events.off(name, listener);\n  };\n\n  public removeListener: ISignClientEvents[\"removeListener\"] = (name, listener) => {\n    return this.events.removeListener(name, listener);\n  };\n\n  // ---------- Engine ----------------------------------------------- //\n\n  public connect: ISignClient[\"connect\"] = async (params) => {\n    try {\n      return await this.engine.connect(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public pair: ISignClient[\"pair\"] = async (params) => {\n    try {\n      return await this.engine.pair(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public approve: ISignClient[\"approve\"] = async (params) => {\n    try {\n      return await this.engine.approve(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public reject: ISignClient[\"reject\"] = async (params) => {\n    try {\n      return await this.engine.reject(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public update: ISignClient[\"update\"] = async (params) => {\n    try {\n      return await this.engine.update(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public extend: ISignClient[\"extend\"] = async (params) => {\n    try {\n      return await this.engine.extend(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public request: ISignClient[\"request\"] = async <T>(params: EngineTypes.RequestParams) => {\n    try {\n      return await this.engine.request<T>(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public respond: ISignClient[\"respond\"] = async (params) => {\n    try {\n      return await this.engine.respond(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public ping: ISignClient[\"ping\"] = async (params) => {\n    try {\n      return await this.engine.ping(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public emit: ISignClient[\"emit\"] = async (params) => {\n    try {\n      return await this.engine.emit(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public disconnect: ISignClient[\"disconnect\"] = async (params) => {\n    try {\n      return await this.engine.disconnect(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public find: ISignClient[\"find\"] = (params) => {\n    try {\n      return this.engine.find(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  // ---------- Private ----------------------------------------------- //\n\n  private async initialize() {\n    this.logger.trace(`Initialized`);\n    try {\n      await this.core.start();\n      await this.pairing.init();\n      await this.session.init();\n      await this.proposal.init();\n      await this.history.init();\n      await this.expirer.init();\n      await this.engine.init();\n      this.logger.info(`SignClient Initilization Success`);\n    } catch (error: any) {\n      this.logger.info(`SignClient Initilization Failure`);\n      this.logger.error(error.message);\n      throw error;\n    }\n  }\n}\n","import { SignClient as Client } from \"./client\";\n\nexport * from \"./constants\";\n\nexport const SignClient = Client;\nexport default Client;\n"],"mappings":"","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}