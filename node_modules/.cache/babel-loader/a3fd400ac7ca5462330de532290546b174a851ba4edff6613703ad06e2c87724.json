{"ast":null,"code":"import { BaseMessageSignerWalletAdapter, scopePollingDetectionStrategy, WalletAccountError, WalletAdapterNetwork, WalletConfigError, WalletConnectionError, WalletDisconnectedError, WalletDisconnectionError, WalletError, WalletLoadError, WalletNotConnectedError, WalletNotReadyError, WalletPublicKeyError, WalletReadyState, WalletSignMessageError, WalletSignTransactionError, WalletTimeoutError, WalletWindowBlockedError, WalletWindowClosedError } from '@solana/wallet-adapter-base';\nimport { PublicKey } from '@solana/web3.js';\nexport class BaseSolletWalletAdapter extends BaseMessageSignerWalletAdapter {\n  constructor({\n    provider,\n    network = WalletAdapterNetwork.Mainnet,\n    timeout = 10000\n  } = {}) {\n    super();\n    this.supportedTransactionVersions = null;\n    this._readyState = typeof window === 'undefined' || typeof document === 'undefined' ? WalletReadyState.Unsupported : WalletReadyState.NotDetected;\n    this._disconnected = () => {\n      const wallet = this._wallet;\n      if (wallet) {\n        wallet.off('disconnect', this._disconnected);\n        this._wallet = null;\n        this._publicKey = null;\n        this.emit('error', new WalletDisconnectedError());\n        this.emit('disconnect');\n      }\n    };\n    this._provider = provider;\n    this._network = network;\n    this._timeout = timeout;\n    this._connecting = false;\n    this._wallet = null;\n    this._publicKey = null;\n    if (this._readyState !== WalletReadyState.Unsupported) {\n      if (typeof this._provider === 'string') {\n        this._readyState = WalletReadyState.Loadable;\n      } else {\n        scopePollingDetectionStrategy(() => {\n          if (typeof window.sollet?.postMessage === 'function') {\n            this._readyState = WalletReadyState.Installed;\n            this.emit('readyStateChange', this._readyState);\n            return true;\n          }\n          return false;\n        });\n      }\n    }\n  }\n  get publicKey() {\n    return this._publicKey;\n  }\n  get connecting() {\n    return this._connecting;\n  }\n  get connected() {\n    return !!this._wallet?.connected;\n  }\n  get readyState() {\n    return this._readyState;\n  }\n  async connect() {\n    try {\n      if (this.connected || this.connecting) return;\n      if (this._readyState !== WalletReadyState.Loadable && this._readyState !== WalletReadyState.Installed) throw new WalletNotReadyError();\n      this._connecting = true;\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      const provider = this._provider || window.sollet;\n      let SolWalletAdapterClass;\n      try {\n        SolWalletAdapterClass = (await import('@project-serum/sol-wallet-adapter')).default;\n      } catch (error) {\n        throw new WalletLoadError(error?.message, error);\n      }\n      let wallet;\n      try {\n        wallet = new SolWalletAdapterClass(provider, this._network);\n      } catch (error) {\n        throw new WalletConfigError(error?.message, error);\n      }\n      try {\n        // HACK: sol-wallet-adapter doesn't reject or emit an event if the popup or extension is closed or blocked\n        const handleDisconnect = wallet.handleDisconnect;\n        let timeout;\n        let interval;\n        try {\n          await new Promise((resolve, reject) => {\n            const connect = () => {\n              if (timeout) clearTimeout(timeout);\n              wallet.off('connect', connect);\n              resolve();\n            };\n            wallet.handleDisconnect = (...args) => {\n              wallet.off('connect', connect);\n              reject(new WalletWindowClosedError());\n              return handleDisconnect.apply(wallet, args);\n            };\n            wallet.on('connect', connect);\n            wallet.connect().catch(reason => {\n              wallet.off('connect', connect);\n              reject(reason);\n            });\n            if (typeof provider === 'string') {\n              let count = 0;\n              interval = setInterval(() => {\n                const popup = wallet._popup;\n                if (popup) {\n                  if (popup.closed) reject(new WalletWindowClosedError());\n                } else {\n                  if (count > 50) reject(new WalletWindowBlockedError());\n                }\n                count++;\n              }, 100);\n            } else {\n              // HACK: sol-wallet-adapter doesn't reject or emit an event if the extension is closed or ignored\n              timeout = setTimeout(() => reject(new WalletTimeoutError()), this._timeout);\n            }\n          });\n        } finally {\n          wallet.handleDisconnect = handleDisconnect;\n          if (interval) clearInterval(interval);\n        }\n      } catch (error) {\n        if (error instanceof WalletError) throw error;\n        throw new WalletConnectionError(error?.message, error);\n      }\n      if (!wallet.publicKey) throw new WalletAccountError();\n      let publicKey;\n      try {\n        publicKey = new PublicKey(wallet.publicKey.toBytes());\n      } catch (error) {\n        throw new WalletPublicKeyError(error?.message, error);\n      }\n      wallet.on('disconnect', this._disconnected);\n      this._wallet = wallet;\n      this._publicKey = publicKey;\n      this.emit('connect', publicKey);\n    } catch (error) {\n      this.emit('error', error);\n      throw error;\n    } finally {\n      this._connecting = false;\n    }\n  }\n  async disconnect() {\n    const wallet = this._wallet;\n    if (wallet) {\n      wallet.off('disconnect', this._disconnected);\n      this._wallet = null;\n      this._publicKey = null;\n      // HACK: sol-wallet-adapter doesn't reliably fulfill its promise or emit an event on disconnect\n      const handleDisconnect = wallet.handleDisconnect;\n      try {\n        await new Promise((resolve, reject) => {\n          const timeout = setTimeout(() => resolve(), 250);\n          wallet.handleDisconnect = (...args) => {\n            clearTimeout(timeout);\n            resolve();\n            // HACK: sol-wallet-adapter rejects with an uncaught promise error\n            wallet._responsePromises = new Map();\n            return handleDisconnect.apply(wallet, args);\n          };\n          wallet.disconnect().then(() => {\n            clearTimeout(timeout);\n            resolve();\n          }, error => {\n            clearTimeout(timeout);\n            // HACK: sol-wallet-adapter rejects with an error on disconnect\n            if (error?.message === 'Wallet disconnected') {\n              resolve();\n            } else {\n              reject(error);\n            }\n          });\n        });\n      } catch (error) {\n        this.emit('error', new WalletDisconnectionError(error?.message, error));\n      } finally {\n        wallet.handleDisconnect = handleDisconnect;\n      }\n    }\n    this.emit('disconnect');\n  }\n  async signTransaction(transaction) {\n    try {\n      const wallet = this._wallet;\n      if (!wallet) throw new WalletNotConnectedError();\n      try {\n        return (await wallet.signTransaction(transaction)) || transaction;\n      } catch (error) {\n        throw new WalletSignTransactionError(error?.message, error);\n      }\n    } catch (error) {\n      this.emit('error', error);\n      throw error;\n    }\n  }\n  async signAllTransactions(transactions) {\n    try {\n      const wallet = this._wallet;\n      if (!wallet) throw new WalletNotConnectedError();\n      try {\n        return (await wallet.signAllTransactions(transactions)) || transactions;\n      } catch (error) {\n        throw new WalletSignTransactionError(error?.message, error);\n      }\n    } catch (error) {\n      this.emit('error', error);\n      throw error;\n    }\n  }\n  async signMessage(message) {\n    try {\n      const wallet = this._wallet;\n      if (!wallet) throw new WalletNotConnectedError();\n      try {\n        const {\n          signature\n        } = await wallet.sign(message, 'utf8');\n        return Uint8Array.from(signature);\n      } catch (error) {\n        throw new WalletSignMessageError(error?.message, error);\n      }\n    } catch (error) {\n      this.emit('error', error);\n      throw error;\n    }\n  }\n}","map":{"version":3,"names":["BaseMessageSignerWalletAdapter","scopePollingDetectionStrategy","WalletAccountError","WalletAdapterNetwork","WalletConfigError","WalletConnectionError","WalletDisconnectedError","WalletDisconnectionError","WalletError","WalletLoadError","WalletNotConnectedError","WalletNotReadyError","WalletPublicKeyError","WalletReadyState","WalletSignMessageError","WalletSignTransactionError","WalletTimeoutError","WalletWindowBlockedError","WalletWindowClosedError","PublicKey","BaseSolletWalletAdapter","constructor","provider","network","Mainnet","timeout","supportedTransactionVersions","_readyState","window","document","Unsupported","NotDetected","_disconnected","wallet","_wallet","off","_publicKey","emit","_provider","_network","_timeout","_connecting","Loadable","sollet","postMessage","Installed","publicKey","connecting","connected","readyState","connect","SolWalletAdapterClass","default","error","message","handleDisconnect","interval","Promise","resolve","reject","clearTimeout","args","apply","on","catch","reason","count","setInterval","popup","_popup","closed","setTimeout","clearInterval","toBytes","disconnect","_responsePromises","Map","then","signTransaction","transaction","signAllTransactions","transactions","signMessage","signature","sign","Uint8Array","from"],"sources":["C:\\Users\\user\\Desktop\\BCEndterm\\node_modules\\@solana\\wallet-adapter-sollet\\src\\base.ts"],"sourcesContent":["import type { default as SolWalletAdapter } from '@project-serum/sol-wallet-adapter';\nimport {\n    BaseMessageSignerWalletAdapter,\n    scopePollingDetectionStrategy,\n    WalletAccountError,\n    WalletAdapterNetwork,\n    WalletConfigError,\n    WalletConnectionError,\n    WalletDisconnectedError,\n    WalletDisconnectionError,\n    WalletError,\n    WalletLoadError,\n    WalletNotConnectedError,\n    WalletNotReadyError,\n    WalletPublicKeyError,\n    WalletReadyState,\n    WalletSignMessageError,\n    WalletSignTransactionError,\n    WalletTimeoutError,\n    WalletWindowBlockedError,\n    WalletWindowClosedError,\n} from '@solana/wallet-adapter-base';\nimport type { Transaction } from '@solana/web3.js';\nimport { PublicKey } from '@solana/web3.js';\n\ninterface SolletWallet {\n    postMessage?(...args: unknown[]): unknown;\n}\n\ninterface SolletWindow extends Window {\n    sollet?: SolletWallet;\n}\n\ndeclare const window: SolletWindow;\n\nexport interface SolletWalletAdapterConfig {\n    provider?: string | SolletWallet;\n    network?: WalletAdapterNetwork;\n    timeout?: number;\n}\n\nexport abstract class BaseSolletWalletAdapter extends BaseMessageSignerWalletAdapter {\n    readonly supportedTransactionVersions = null;\n\n    protected _provider: string | SolletWallet | undefined;\n    protected _network: WalletAdapterNetwork;\n    protected _timeout: number;\n    protected _connecting: boolean;\n    protected _wallet: SolWalletAdapter | null;\n    protected _publicKey: PublicKey | null;\n    protected _readyState: WalletReadyState =\n        typeof window === 'undefined' || typeof document === 'undefined'\n            ? WalletReadyState.Unsupported\n            : WalletReadyState.NotDetected;\n\n    constructor({ provider, network = WalletAdapterNetwork.Mainnet, timeout = 10000 }: SolletWalletAdapterConfig = {}) {\n        super();\n\n        this._provider = provider;\n        this._network = network;\n        this._timeout = timeout;\n        this._connecting = false;\n        this._wallet = null;\n        this._publicKey = null;\n\n        if (this._readyState !== WalletReadyState.Unsupported) {\n            if (typeof this._provider === 'string') {\n                this._readyState = WalletReadyState.Loadable;\n            } else {\n                scopePollingDetectionStrategy(() => {\n                    if (typeof window.sollet?.postMessage === 'function') {\n                        this._readyState = WalletReadyState.Installed;\n                        this.emit('readyStateChange', this._readyState);\n                        return true;\n                    }\n                    return false;\n                });\n            }\n        }\n    }\n\n    get publicKey() {\n        return this._publicKey;\n    }\n\n    get connecting() {\n        return this._connecting;\n    }\n\n    get connected() {\n        return !!this._wallet?.connected;\n    }\n\n    get readyState() {\n        return this._readyState;\n    }\n\n    async connect(): Promise<void> {\n        try {\n            if (this.connected || this.connecting) return;\n            if (this._readyState !== WalletReadyState.Loadable && this._readyState !== WalletReadyState.Installed)\n                throw new WalletNotReadyError();\n\n            this._connecting = true;\n\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            const provider = this._provider || window.sollet!;\n\n            let SolWalletAdapterClass: typeof SolWalletAdapter;\n            try {\n                SolWalletAdapterClass = (await import('@project-serum/sol-wallet-adapter')).default;\n            } catch (error: any) {\n                throw new WalletLoadError(error?.message, error);\n            }\n\n            let wallet: SolWalletAdapter;\n            try {\n                wallet = new SolWalletAdapterClass(provider, this._network);\n            } catch (error: any) {\n                throw new WalletConfigError(error?.message, error);\n            }\n\n            try {\n                // HACK: sol-wallet-adapter doesn't reject or emit an event if the popup or extension is closed or blocked\n                const handleDisconnect: (...args: unknown[]) => unknown = (wallet as any).handleDisconnect;\n                let timeout: NodeJS.Timer | undefined;\n                let interval: NodeJS.Timer | undefined;\n                try {\n                    await new Promise<void>((resolve, reject) => {\n                        const connect = () => {\n                            if (timeout) clearTimeout(timeout);\n                            wallet.off('connect', connect);\n                            resolve();\n                        };\n\n                        (wallet as any).handleDisconnect = (...args: unknown[]): unknown => {\n                            wallet.off('connect', connect);\n                            reject(new WalletWindowClosedError());\n                            return handleDisconnect.apply(wallet, args);\n                        };\n\n                        wallet.on('connect', connect);\n\n                        wallet.connect().catch((reason: any) => {\n                            wallet.off('connect', connect);\n                            reject(reason);\n                        });\n\n                        if (typeof provider === 'string') {\n                            let count = 0;\n\n                            interval = setInterval(() => {\n                                const popup = (wallet as any)._popup;\n                                if (popup) {\n                                    if (popup.closed) reject(new WalletWindowClosedError());\n                                } else {\n                                    if (count > 50) reject(new WalletWindowBlockedError());\n                                }\n\n                                count++;\n                            }, 100);\n                        } else {\n                            // HACK: sol-wallet-adapter doesn't reject or emit an event if the extension is closed or ignored\n                            timeout = setTimeout(() => reject(new WalletTimeoutError()), this._timeout);\n                        }\n                    });\n                } finally {\n                    (wallet as any).handleDisconnect = handleDisconnect;\n                    if (interval) clearInterval(interval);\n                }\n            } catch (error: any) {\n                if (error instanceof WalletError) throw error;\n                throw new WalletConnectionError(error?.message, error);\n            }\n\n            if (!wallet.publicKey) throw new WalletAccountError();\n\n            let publicKey: PublicKey;\n            try {\n                publicKey = new PublicKey(wallet.publicKey.toBytes());\n            } catch (error: any) {\n                throw new WalletPublicKeyError(error?.message, error);\n            }\n\n            wallet.on('disconnect', this._disconnected);\n\n            this._wallet = wallet;\n            this._publicKey = publicKey;\n\n            this.emit('connect', publicKey);\n        } catch (error: any) {\n            this.emit('error', error);\n            throw error;\n        } finally {\n            this._connecting = false;\n        }\n    }\n\n    async disconnect(): Promise<void> {\n        const wallet = this._wallet;\n        if (wallet) {\n            wallet.off('disconnect', this._disconnected);\n\n            this._wallet = null;\n            this._publicKey = null;\n\n            // HACK: sol-wallet-adapter doesn't reliably fulfill its promise or emit an event on disconnect\n            const handleDisconnect: (...args: unknown[]) => unknown = (wallet as any).handleDisconnect;\n            try {\n                await new Promise<void>((resolve, reject) => {\n                    const timeout = setTimeout(() => resolve(), 250);\n\n                    (wallet as any).handleDisconnect = (...args: unknown[]): unknown => {\n                        clearTimeout(timeout);\n                        resolve();\n                        // HACK: sol-wallet-adapter rejects with an uncaught promise error\n                        (wallet as any)._responsePromises = new Map();\n                        return handleDisconnect.apply(wallet, args);\n                    };\n\n                    wallet.disconnect().then(\n                        () => {\n                            clearTimeout(timeout);\n                            resolve();\n                        },\n                        (error: any) => {\n                            clearTimeout(timeout);\n                            // HACK: sol-wallet-adapter rejects with an error on disconnect\n                            if (error?.message === 'Wallet disconnected') {\n                                resolve();\n                            } else {\n                                reject(error);\n                            }\n                        }\n                    );\n                });\n            } catch (error: any) {\n                this.emit('error', new WalletDisconnectionError(error?.message, error));\n            } finally {\n                (wallet as any).handleDisconnect = handleDisconnect;\n            }\n        }\n\n        this.emit('disconnect');\n    }\n\n    async signTransaction<T extends Transaction>(transaction: T): Promise<T> {\n        try {\n            const wallet = this._wallet;\n            if (!wallet) throw new WalletNotConnectedError();\n\n            try {\n                return ((await wallet.signTransaction(transaction)) as T) || transaction;\n            } catch (error: any) {\n                throw new WalletSignTransactionError(error?.message, error);\n            }\n        } catch (error: any) {\n            this.emit('error', error);\n            throw error;\n        }\n    }\n\n    async signAllTransactions<T extends Transaction>(transactions: T[]): Promise<T[]> {\n        try {\n            const wallet = this._wallet;\n            if (!wallet) throw new WalletNotConnectedError();\n\n            try {\n                return ((await wallet.signAllTransactions(transactions)) as T[]) || transactions;\n            } catch (error: any) {\n                throw new WalletSignTransactionError(error?.message, error);\n            }\n        } catch (error: any) {\n            this.emit('error', error);\n            throw error;\n        }\n    }\n\n    async signMessage(message: Uint8Array): Promise<Uint8Array> {\n        try {\n            const wallet = this._wallet;\n            if (!wallet) throw new WalletNotConnectedError();\n\n            try {\n                const { signature } = await wallet.sign(message, 'utf8');\n                return Uint8Array.from(signature);\n            } catch (error: any) {\n                throw new WalletSignMessageError(error?.message, error);\n            }\n        } catch (error: any) {\n            this.emit('error', error);\n            throw error;\n        }\n    }\n\n    private _disconnected = () => {\n        const wallet = this._wallet;\n        if (wallet) {\n            wallet.off('disconnect', this._disconnected);\n\n            this._wallet = null;\n            this._publicKey = null;\n\n            this.emit('error', new WalletDisconnectedError());\n            this.emit('disconnect');\n        }\n    };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}