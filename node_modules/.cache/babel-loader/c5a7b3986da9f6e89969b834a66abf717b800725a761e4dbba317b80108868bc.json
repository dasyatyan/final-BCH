{"ast":null,"code":"import { BaseWalletAdapter } from './adapter.js';\nimport { WalletSendTransactionError, WalletSignTransactionError } from './errors.js';\nexport class BaseSignerWalletAdapter extends BaseWalletAdapter {\n  async sendTransaction(transaction, connection, options = {}) {\n    let emit = true;\n    try {\n      if ('version' in transaction) {\n        if (!this.supportedTransactionVersions) throw new WalletSendTransactionError(`Sending versioned transactions isn't supported by this wallet`);\n        if (!this.supportedTransactionVersions.has(transaction.version)) throw new WalletSendTransactionError(`Sending transaction version ${transaction.version} isn't supported by this wallet`);\n        try {\n          transaction = await this.signTransaction(transaction);\n          const rawTransaction = transaction.serialize();\n          return await connection.sendRawTransaction(rawTransaction, options);\n        } catch (error) {\n          // If the error was thrown by `signTransaction`, rethrow it and don't emit a duplicate event\n          if (error instanceof WalletSignTransactionError) {\n            emit = false;\n            throw error;\n          }\n          throw new WalletSendTransactionError(error?.message, error);\n        }\n      } else {\n        try {\n          const {\n            signers,\n            ...sendOptions\n          } = options;\n          transaction = await this.prepareTransaction(transaction, connection, sendOptions);\n          signers?.length && transaction.partialSign(...signers);\n          transaction = await this.signTransaction(transaction);\n          const rawTransaction = transaction.serialize();\n          return await connection.sendRawTransaction(rawTransaction, sendOptions);\n        } catch (error) {\n          // If the error was thrown by `signTransaction`, rethrow it and don't emit a duplicate event\n          if (error instanceof WalletSignTransactionError) {\n            emit = false;\n            throw error;\n          }\n          throw new WalletSendTransactionError(error?.message, error);\n        }\n      }\n    } catch (error) {\n      if (emit) {\n        this.emit('error', error);\n      }\n      throw error;\n    }\n  }\n  async signAllTransactions(transactions) {\n    for (const transaction of transactions) {\n      if ('version' in transaction) {\n        if (!this.supportedTransactionVersions) throw new WalletSignTransactionError(`Signing versioned transactions isn't supported by this wallet`);\n        if (!this.supportedTransactionVersions.has(transaction.version)) throw new WalletSignTransactionError(`Signing transaction version ${transaction.version} isn't supported by this wallet`);\n      }\n    }\n    const signedTransactions = [];\n    for (const transaction of transactions) {\n      signedTransactions.push(await this.signTransaction(transaction));\n    }\n    return signedTransactions;\n  }\n}\nexport class BaseMessageSignerWalletAdapter extends BaseSignerWalletAdapter {}","map":{"version":3,"names":["BaseWalletAdapter","WalletSendTransactionError","WalletSignTransactionError","BaseSignerWalletAdapter","sendTransaction","transaction","connection","options","emit","supportedTransactionVersions","has","version","signTransaction","rawTransaction","serialize","sendRawTransaction","error","message","signers","sendOptions","prepareTransaction","length","partialSign","signAllTransactions","transactions","signedTransactions","push","BaseMessageSignerWalletAdapter"],"sources":["C:\\Users\\user\\Desktop\\BCEndterm\\node_modules\\@solana\\wallet-adapter-base\\src\\signer.ts"],"sourcesContent":["import type { Connection, TransactionSignature } from '@solana/web3.js';\nimport type { SendTransactionOptions, WalletAdapter, WalletAdapterProps } from './adapter.js';\nimport { BaseWalletAdapter } from './adapter.js';\nimport { WalletSendTransactionError, WalletSignTransactionError } from './errors.js';\nimport type { TransactionOrVersionedTransaction } from './types.js';\n\nexport interface SignerWalletAdapterProps<Name extends string = string> extends WalletAdapterProps<Name> {\n    signTransaction<T extends TransactionOrVersionedTransaction<this['supportedTransactionVersions']>>(\n        transaction: T\n    ): Promise<T>;\n    signAllTransactions<T extends TransactionOrVersionedTransaction<this['supportedTransactionVersions']>>(\n        transactions: T[]\n    ): Promise<T[]>;\n}\n\nexport type SignerWalletAdapter<Name extends string = string> = WalletAdapter<Name> & SignerWalletAdapterProps<Name>;\n\nexport abstract class BaseSignerWalletAdapter<Name extends string = string>\n    extends BaseWalletAdapter<Name>\n    implements SignerWalletAdapter<Name>\n{\n    async sendTransaction(\n        transaction: TransactionOrVersionedTransaction<this['supportedTransactionVersions']>,\n        connection: Connection,\n        options: SendTransactionOptions = {}\n    ): Promise<TransactionSignature> {\n        let emit = true;\n        try {\n            if ('version' in transaction) {\n                if (!this.supportedTransactionVersions)\n                    throw new WalletSendTransactionError(\n                        `Sending versioned transactions isn't supported by this wallet`\n                    );\n\n                if (!this.supportedTransactionVersions.has(transaction.version))\n                    throw new WalletSendTransactionError(\n                        `Sending transaction version ${transaction.version} isn't supported by this wallet`\n                    );\n\n                try {\n                    transaction = await this.signTransaction(transaction);\n\n                    const rawTransaction = transaction.serialize();\n\n                    return await connection.sendRawTransaction(rawTransaction, options);\n                } catch (error: any) {\n                    // If the error was thrown by `signTransaction`, rethrow it and don't emit a duplicate event\n                    if (error instanceof WalletSignTransactionError) {\n                        emit = false;\n                        throw error;\n                    }\n                    throw new WalletSendTransactionError(error?.message, error);\n                }\n            } else {\n                try {\n                    const { signers, ...sendOptions } = options;\n\n                    transaction = await this.prepareTransaction(transaction, connection, sendOptions);\n\n                    signers?.length && transaction.partialSign(...signers);\n\n                    transaction = await this.signTransaction(transaction);\n\n                    const rawTransaction = transaction.serialize();\n\n                    return await connection.sendRawTransaction(rawTransaction, sendOptions);\n                } catch (error: any) {\n                    // If the error was thrown by `signTransaction`, rethrow it and don't emit a duplicate event\n                    if (error instanceof WalletSignTransactionError) {\n                        emit = false;\n                        throw error;\n                    }\n                    throw new WalletSendTransactionError(error?.message, error);\n                }\n            }\n        } catch (error: any) {\n            if (emit) {\n                this.emit('error', error);\n            }\n            throw error;\n        }\n    }\n\n    abstract signTransaction<T extends TransactionOrVersionedTransaction<this['supportedTransactionVersions']>>(\n        transaction: T\n    ): Promise<T>;\n\n    async signAllTransactions<T extends TransactionOrVersionedTransaction<this['supportedTransactionVersions']>>(\n        transactions: T[]\n    ): Promise<T[]> {\n        for (const transaction of transactions) {\n            if ('version' in transaction) {\n                if (!this.supportedTransactionVersions)\n                    throw new WalletSignTransactionError(\n                        `Signing versioned transactions isn't supported by this wallet`\n                    );\n\n                if (!this.supportedTransactionVersions.has(transaction.version))\n                    throw new WalletSignTransactionError(\n                        `Signing transaction version ${transaction.version} isn't supported by this wallet`\n                    );\n            }\n        }\n\n        const signedTransactions: T[] = [];\n        for (const transaction of transactions) {\n            signedTransactions.push(await this.signTransaction(transaction));\n        }\n        return signedTransactions;\n    }\n}\n\nexport interface MessageSignerWalletAdapterProps<Name extends string = string> extends WalletAdapterProps<Name> {\n    signMessage(message: Uint8Array): Promise<Uint8Array>;\n}\n\nexport type MessageSignerWalletAdapter<Name extends string = string> = WalletAdapter<Name> &\n    MessageSignerWalletAdapterProps<Name>;\n\nexport abstract class BaseMessageSignerWalletAdapter<Name extends string = string>\n    extends BaseSignerWalletAdapter<Name>\n    implements MessageSignerWalletAdapter<Name>\n{\n    abstract signMessage(message: Uint8Array): Promise<Uint8Array>;\n}\n"],"mappings":"AAEA,SAASA,iBAAiB,QAAQ,cAAc;AAChD,SAASC,0BAA0B,EAAEC,0BAA0B,QAAQ,aAAa;AAcpF,OAAM,MAAgBC,uBAClB,SAAQH,iBAAuB;EAG/B,MAAMI,eAAeA,CACjBC,WAAoF,EACpFC,UAAsB,EACtBC,OAAA,GAAkC,EAAE;IAEpC,IAAIC,IAAI,GAAG,IAAI;IACf,IAAI;MACA,IAAI,SAAS,IAAIH,WAAW,EAAE;QAC1B,IAAI,CAAC,IAAI,CAACI,4BAA4B,EAClC,MAAM,IAAIR,0BAA0B,CAChC,+DAA+D,CAClE;QAEL,IAAI,CAAC,IAAI,CAACQ,4BAA4B,CAACC,GAAG,CAACL,WAAW,CAACM,OAAO,CAAC,EAC3D,MAAM,IAAIV,0BAA0B,CAChC,+BAA+BI,WAAW,CAACM,OAAO,iCAAiC,CACtF;QAEL,IAAI;UACAN,WAAW,GAAG,MAAM,IAAI,CAACO,eAAe,CAACP,WAAW,CAAC;UAErD,MAAMQ,cAAc,GAAGR,WAAW,CAACS,SAAS,EAAE;UAE9C,OAAO,MAAMR,UAAU,CAACS,kBAAkB,CAACF,cAAc,EAAEN,OAAO,CAAC;SACtE,CAAC,OAAOS,KAAU,EAAE;UACjB;UACA,IAAIA,KAAK,YAAYd,0BAA0B,EAAE;YAC7CM,IAAI,GAAG,KAAK;YACZ,MAAMQ,KAAK;;UAEf,MAAM,IAAIf,0BAA0B,CAACe,KAAK,EAAEC,OAAO,EAAED,KAAK,CAAC;;OAElE,MAAM;QACH,IAAI;UACA,MAAM;YAAEE,OAAO;YAAE,GAAGC;UAAW,CAAE,GAAGZ,OAAO;UAE3CF,WAAW,GAAG,MAAM,IAAI,CAACe,kBAAkB,CAACf,WAAW,EAAEC,UAAU,EAAEa,WAAW,CAAC;UAEjFD,OAAO,EAAEG,MAAM,IAAIhB,WAAW,CAACiB,WAAW,CAAC,GAAGJ,OAAO,CAAC;UAEtDb,WAAW,GAAG,MAAM,IAAI,CAACO,eAAe,CAACP,WAAW,CAAC;UAErD,MAAMQ,cAAc,GAAGR,WAAW,CAACS,SAAS,EAAE;UAE9C,OAAO,MAAMR,UAAU,CAACS,kBAAkB,CAACF,cAAc,EAAEM,WAAW,CAAC;SAC1E,CAAC,OAAOH,KAAU,EAAE;UACjB;UACA,IAAIA,KAAK,YAAYd,0BAA0B,EAAE;YAC7CM,IAAI,GAAG,KAAK;YACZ,MAAMQ,KAAK;;UAEf,MAAM,IAAIf,0BAA0B,CAACe,KAAK,EAAEC,OAAO,EAAED,KAAK,CAAC;;;KAGtE,CAAC,OAAOA,KAAU,EAAE;MACjB,IAAIR,IAAI,EAAE;QACN,IAAI,CAACA,IAAI,CAAC,OAAO,EAAEQ,KAAK,CAAC;;MAE7B,MAAMA,KAAK;;EAEnB;EAMA,MAAMO,mBAAmBA,CACrBC,YAAiB;IAEjB,KAAK,MAAMnB,WAAW,IAAImB,YAAY,EAAE;MACpC,IAAI,SAAS,IAAInB,WAAW,EAAE;QAC1B,IAAI,CAAC,IAAI,CAACI,4BAA4B,EAClC,MAAM,IAAIP,0BAA0B,CAChC,+DAA+D,CAClE;QAEL,IAAI,CAAC,IAAI,CAACO,4BAA4B,CAACC,GAAG,CAACL,WAAW,CAACM,OAAO,CAAC,EAC3D,MAAM,IAAIT,0BAA0B,CAChC,+BAA+BG,WAAW,CAACM,OAAO,iCAAiC,CACtF;;;IAIb,MAAMc,kBAAkB,GAAQ,EAAE;IAClC,KAAK,MAAMpB,WAAW,IAAImB,YAAY,EAAE;MACpCC,kBAAkB,CAACC,IAAI,CAAC,MAAM,IAAI,CAACd,eAAe,CAACP,WAAW,CAAC,CAAC;;IAEpE,OAAOoB,kBAAkB;EAC7B;;AAUJ,OAAM,MAAgBE,8BAClB,SAAQxB,uBAA6B","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}