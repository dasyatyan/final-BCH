{"ast":null,"code":"import { IEvents as c } from \"@walletconnect/events\";\nclass m extends c {\n  constructor(t) {\n    super(), this.opts = t, this.protocol = \"wc\", this.version = 2;\n  }\n}\nclass _ {\n  constructor(t, s, i) {\n    this.core = t, this.logger = s;\n  }\n}\nclass g extends c {\n  constructor(t, s) {\n    super(), this.core = t, this.logger = s, this.records = new Map();\n  }\n}\nclass p {\n  constructor(t, s) {\n    this.logger = t, this.core = s;\n  }\n}\nclass d extends c {\n  constructor(t, s) {\n    super(), this.relayer = t, this.logger = s;\n  }\n}\nclass L extends c {\n  constructor(t) {\n    super();\n  }\n}\nclass x {\n  constructor(t, s, i, h) {\n    this.core = t, this.logger = s, this.name = i;\n  }\n}\nclass E {\n  constructor() {\n    this.map = new Map();\n  }\n}\nclass b extends c {\n  constructor(t, s) {\n    super(), this.relayer = t, this.logger = s;\n  }\n}\nclass w {\n  constructor(t, s) {\n    this.core = t, this.logger = s;\n  }\n}\nfunction r() {\n  this._events = this._events || {}, this._maxListeners = this._maxListeners || void 0;\n}\nvar f = r;\nr.EventEmitter = r, r.prototype._events = void 0, r.prototype._maxListeners = void 0, r.defaultMaxListeners = 10, r.prototype.setMaxListeners = function (e) {\n  if (!I(e) || e < 0 || isNaN(e)) throw TypeError(\"n must be a positive number\");\n  return this._maxListeners = e, this;\n}, r.prototype.emit = function (e) {\n  var t, s, i, h, n, u;\n  if (this._events || (this._events = {}), e === \"error\" && (!this._events.error || l(this._events.error) && !this._events.error.length)) {\n    if (t = arguments[1], t instanceof Error) throw t;\n    var a = new Error('Uncaught, unspecified \"error\" event. (' + t + \")\");\n    throw a.context = t, a;\n  }\n  if (s = this._events[e], v(s)) return !1;\n  if (o(s)) switch (arguments.length) {\n    case 1:\n      s.call(this);\n      break;\n    case 2:\n      s.call(this, arguments[1]);\n      break;\n    case 3:\n      s.call(this, arguments[1], arguments[2]);\n      break;\n    default:\n      h = Array.prototype.slice.call(arguments, 1), s.apply(this, h);\n  } else if (l(s)) for (h = Array.prototype.slice.call(arguments, 1), u = s.slice(), i = u.length, n = 0; n < i; n++) u[n].apply(this, h);\n  return !0;\n}, r.prototype.addListener = function (e, t) {\n  var s;\n  if (!o(t)) throw TypeError(\"listener must be a function\");\n  return this._events || (this._events = {}), this._events.newListener && this.emit(\"newListener\", e, o(t.listener) ? t.listener : t), this._events[e] ? l(this._events[e]) ? this._events[e].push(t) : this._events[e] = [this._events[e], t] : this._events[e] = t, l(this._events[e]) && !this._events[e].warned && (v(this._maxListeners) ? s = r.defaultMaxListeners : s = this._maxListeners, s && s > 0 && this._events[e].length > s && (this._events[e].warned = !0, console.error(\"(node) warning: possible EventEmitter memory leak detected. %d listeners added. Use emitter.setMaxListeners() to increase limit.\", this._events[e].length), typeof console.trace == \"function\" && console.trace())), this;\n}, r.prototype.on = r.prototype.addListener, r.prototype.once = function (e, t) {\n  if (!o(t)) throw TypeError(\"listener must be a function\");\n  var s = !1;\n  function i() {\n    this.removeListener(e, i), s || (s = !0, t.apply(this, arguments));\n  }\n  return i.listener = t, this.on(e, i), this;\n}, r.prototype.removeListener = function (e, t) {\n  var s, i, h, n;\n  if (!o(t)) throw TypeError(\"listener must be a function\");\n  if (!this._events || !this._events[e]) return this;\n  if (s = this._events[e], h = s.length, i = -1, s === t || o(s.listener) && s.listener === t) delete this._events[e], this._events.removeListener && this.emit(\"removeListener\", e, t);else if (l(s)) {\n    for (n = h; n-- > 0;) if (s[n] === t || s[n].listener && s[n].listener === t) {\n      i = n;\n      break;\n    }\n    if (i < 0) return this;\n    s.length === 1 ? (s.length = 0, delete this._events[e]) : s.splice(i, 1), this._events.removeListener && this.emit(\"removeListener\", e, t);\n  }\n  return this;\n}, r.prototype.removeAllListeners = function (e) {\n  var t, s;\n  if (!this._events) return this;\n  if (!this._events.removeListener) return arguments.length === 0 ? this._events = {} : this._events[e] && delete this._events[e], this;\n  if (arguments.length === 0) {\n    for (t in this._events) t !== \"removeListener\" && this.removeAllListeners(t);\n    return this.removeAllListeners(\"removeListener\"), this._events = {}, this;\n  }\n  if (s = this._events[e], o(s)) this.removeListener(e, s);else if (s) for (; s.length;) this.removeListener(e, s[s.length - 1]);\n  return delete this._events[e], this;\n}, r.prototype.listeners = function (e) {\n  var t;\n  return !this._events || !this._events[e] ? t = [] : o(this._events[e]) ? t = [this._events[e]] : t = this._events[e].slice(), t;\n}, r.prototype.listenerCount = function (e) {\n  if (this._events) {\n    var t = this._events[e];\n    if (o(t)) return 1;\n    if (t) return t.length;\n  }\n  return 0;\n}, r.listenerCount = function (e, t) {\n  return e.listenerCount(t);\n};\nfunction o(e) {\n  return typeof e == \"function\";\n}\nfunction I(e) {\n  return typeof e == \"number\";\n}\nfunction l(e) {\n  return typeof e == \"object\" && e !== null;\n}\nfunction v(e) {\n  return e === void 0;\n}\nclass y extends f {\n  constructor() {\n    super();\n  }\n}\nclass C {\n  constructor(t) {\n    this.opts = t, this.protocol = \"wc\", this.version = 2;\n  }\n}\nclass M extends f.EventEmitter {\n  constructor() {\n    super();\n  }\n}\nclass k {\n  constructor(t) {\n    this.client = t;\n  }\n}\nclass T extends c {\n  constructor(t, s) {\n    super(), this.core = t, this.logger = s;\n  }\n}\nexport { m as ICore, _ as ICrypto, k as IEngine, M as IEngineEvents, T as IExpirer, g as IJsonRpcHistory, w as IKeyChain, p as IMessageTracker, d as IPublisher, L as IRelayer, C as ISignClient, y as ISignClientEvents, x as IStore, b as ISubscriber, E as ISubscriberTopicMap };","map":{"version":3,"names":[],"sources":["C:\\Users\\user\\Desktop\\BCEndterm\\node_modules\\@walletconnect\\core\\node_modules\\@walletconnect\\types\\src\\core\\core.ts","C:\\Users\\user\\Desktop\\BCEndterm\\node_modules\\@walletconnect\\core\\node_modules\\@walletconnect\\types\\src\\core\\crypto.ts","C:\\Users\\user\\Desktop\\BCEndterm\\node_modules\\@walletconnect\\core\\node_modules\\@walletconnect\\types\\src\\core\\history.ts","C:\\Users\\user\\Desktop\\BCEndterm\\node_modules\\@walletconnect\\core\\node_modules\\@walletconnect\\types\\src\\core\\messages.ts","C:\\Users\\user\\Desktop\\BCEndterm\\node_modules\\@walletconnect\\core\\node_modules\\@walletconnect\\types\\src\\core\\publisher.ts","C:\\Users\\user\\Desktop\\BCEndterm\\node_modules\\@walletconnect\\core\\node_modules\\@walletconnect\\types\\src\\core\\relayer.ts","C:\\Users\\user\\Desktop\\BCEndterm\\node_modules\\@walletconnect\\core\\node_modules\\@walletconnect\\types\\src\\core\\store.ts","C:\\Users\\user\\Desktop\\BCEndterm\\node_modules\\@walletconnect\\core\\node_modules\\@walletconnect\\types\\src\\core\\subscriber.ts","C:\\Users\\user\\Desktop\\BCEndterm\\node_modules\\@walletconnect\\core\\node_modules\\@walletconnect\\types\\src\\core\\keychain.ts","C:\\Users\\user\\Desktop\\BCEndterm\\node_modules\\@walletconnect\\core\\node_modules\\node_modules\\events\\events.js","C:\\Users\\user\\Desktop\\BCEndterm\\node_modules\\@walletconnect\\core\\node_modules\\@walletconnect\\types\\src\\sign-client\\client.ts","C:\\Users\\user\\Desktop\\BCEndterm\\node_modules\\@walletconnect\\core\\node_modules\\@walletconnect\\types\\src\\sign-client\\engine.ts","C:\\Users\\user\\Desktop\\BCEndterm\\node_modules\\@walletconnect\\core\\node_modules\\@walletconnect\\types\\src\\sign-client\\expirer.ts"],"sourcesContent":["import { Logger } from \"pino\";\nimport { IEvents } from \"@walletconnect/events\";\nimport { IHeartBeat } from \"@walletconnect/heartbeat\";\nimport { IKeyValueStorage, KeyValueStorageOptions } from \"@walletconnect/keyvaluestorage\";\n\nimport { ICrypto } from \"./crypto\";\nimport { IRelayer } from \"./relayer\";\nimport { IKeyChain } from \"./keychain\";\n\nexport declare namespace CoreTypes {\n  interface Options {\n    projectId?: string;\n    name?: string;\n    relayUrl?: string;\n    logger?: string | Logger;\n    keychain?: IKeyChain;\n    storage?: IKeyValueStorage;\n    storageOptions?: KeyValueStorageOptions;\n  }\n}\n\nexport abstract class ICore extends IEvents {\n  public readonly protocol = \"wc\";\n  public readonly version = 2;\n\n  public abstract readonly name: string;\n  public abstract readonly context: string;\n  public abstract readonly relayUrl?: string;\n  public abstract readonly projectId?: string;\n\n  public abstract logger: Logger;\n  public abstract heartbeat: IHeartBeat;\n  public abstract crypto: ICrypto;\n  public abstract relayer: IRelayer;\n  public abstract storage: IKeyValueStorage;\n\n  constructor(public opts?: CoreTypes.Options) {\n    super();\n  }\n\n  public abstract start(): Promise<void>;\n}\n","import { JsonRpcPayload } from \"@walletconnect/jsonrpc-types\";\nimport { Logger } from \"pino\";\nimport { ICore } from \"./core\";\nimport { IKeyChain } from \"./keychain\";\n\nexport declare namespace CryptoTypes {\n  export interface Participant {\n    publicKey: string;\n  }\n\n  export interface KeyPair {\n    privateKey: string;\n    publicKey: string;\n  }\n\n  export interface EncryptParams {\n    message: string;\n    symKey: string;\n    type?: number;\n    iv?: string;\n    senderPublicKey?: string;\n  }\n\n  export interface DecryptParams {\n    symKey: string;\n    encoded: string;\n  }\n\n  export interface EncodingParams {\n    type: Uint8Array;\n    sealed: Uint8Array;\n    iv: Uint8Array;\n    senderPublicKey?: Uint8Array;\n  }\n\n  export interface EncodeOptions {\n    type?: number;\n    senderPublicKey?: string;\n    receiverPublicKey?: string;\n  }\n\n  export interface DecodeOptions {\n    receiverPublicKey?: string;\n  }\n\n  export interface EncodingValidation {\n    type: number;\n    senderPublicKey?: string;\n    receiverPublicKey?: string;\n  }\n\n  export interface TypeOneParams {\n    type: 1;\n    senderPublicKey: string;\n    receiverPublicKey: string;\n  }\n}\n\nexport abstract class ICrypto {\n  public abstract name: string;\n\n  public abstract readonly context: string;\n\n  public abstract keychain: IKeyChain;\n\n  constructor(\n    public core: ICore,\n    public logger: Logger,\n    // @ts-ignore\n    keychain?: IKeyChain,\n  ) {}\n\n  public abstract init(): Promise<void>;\n\n  public abstract hasKeys(tag: string): boolean;\n\n  public abstract getClientId(): Promise<string>;\n\n  public abstract generateKeyPair(): Promise<string>;\n\n  public abstract generateSharedKey(\n    selfPublicKey: string,\n    peerPublicKey: string,\n    overrideTopic?: string,\n  ): Promise<string>;\n\n  public abstract setSymKey(symKey: string, overrideTopic?: string): Promise<string>;\n\n  public abstract deleteKeyPair(publicKey: string): Promise<void>;\n\n  public abstract deleteSymKey(topic: string): Promise<void>;\n\n  public abstract encode(\n    topic: string,\n    payload: JsonRpcPayload,\n    opts?: CryptoTypes.EncodeOptions,\n  ): Promise<string>;\n\n  public abstract decode(\n    topic: string,\n    encoded: string,\n    opts?: CryptoTypes.DecodeOptions,\n  ): Promise<JsonRpcPayload>;\n\n  public abstract signJWT(aud: string): Promise<string>;\n}\n","import { Logger } from \"pino\";\nimport { IEvents } from \"@walletconnect/events\";\nimport {\n  ErrorResponse,\n  JsonRpcRequest,\n  JsonRpcResponse,\n  RequestArguments,\n} from \"@walletconnect/jsonrpc-types\";\n\nimport { ICore } from \"./core\";\n\nexport interface JsonRpcRecord {\n  id: number;\n  topic: string;\n  request: RequestArguments;\n  chainId?: string;\n  response?: { result: any } | { error: ErrorResponse };\n}\n\nexport interface RequestEvent {\n  topic: string;\n  request: JsonRpcRequest;\n  chainId?: string;\n}\n\nexport abstract class IJsonRpcHistory extends IEvents {\n  public records = new Map<number, JsonRpcRecord>();\n\n  public abstract readonly context: string;\n\n  public abstract readonly size: number;\n\n  public abstract readonly keys: number[];\n\n  public abstract readonly values: JsonRpcRecord[];\n\n  public abstract readonly pending: RequestEvent[];\n\n  constructor(public core: ICore, public logger: Logger) {\n    super();\n  }\n\n  public abstract init(): Promise<void>;\n\n  public abstract set(topic: string, request: JsonRpcRequest, chainId?: string): void;\n\n  public abstract get(topic: string, id: number): Promise<JsonRpcRecord>;\n\n  public abstract resolve(response: JsonRpcResponse): Promise<void>;\n\n  public abstract delete(topic: string, id?: number): void;\n\n  public abstract exists(topic: string, id: number): Promise<boolean>;\n}\n","import { Logger } from \"pino\";\n\nimport { ICore } from \"./core\";\n\nexport type MessageRecord = Record<string, string>;\n\nexport abstract class IMessageTracker {\n  public abstract messages: Map<string, MessageRecord>;\n\n  public abstract name: string;\n\n  public abstract readonly context: string;\n\n  constructor(public logger: Logger, public core: ICore) {}\n\n  public abstract init(): Promise<void>;\n\n  public abstract set(topic: string, message: string): Promise<string>;\n\n  public abstract get(topic: string): MessageRecord;\n\n  public abstract has(topic: string, message: string): boolean;\n\n  public abstract del(topic: string): Promise<void>;\n}\n","import { Logger } from \"pino\";\nimport { IEvents } from \"@walletconnect/events\";\n\nimport { IRelayer, RelayerTypes } from \"./relayer\";\n\nexport declare namespace PublisherTypes {\n  export interface Params {\n    topic: string;\n    message: string;\n    opts: Required<RelayerTypes.PublishOptions>;\n  }\n}\n\nexport abstract class IPublisher extends IEvents {\n  public abstract name: string;\n\n  public abstract readonly context: string;\n\n  constructor(public relayer: IRelayer, public logger: Logger) {\n    super();\n  }\n\n  public abstract publish(\n    topic: string,\n    message: string,\n    opts?: RelayerTypes.PublishOptions,\n  ): Promise<void>;\n}\n","import { Logger } from \"pino\";\nimport { IEvents } from \"@walletconnect/events\";\nimport { IJsonRpcProvider } from \"@walletconnect/jsonrpc-types\";\n\nimport { ICore } from \"./core\";\nimport { IMessageTracker } from \"./messages\";\nimport { IPublisher } from \"./publisher\";\nimport { ISubscriber } from \"./subscriber\";\n\nexport declare namespace RelayerTypes {\n  export interface ProtocolOptions {\n    protocol: string;\n    data?: string;\n  }\n\n  export interface PublishOptions {\n    relay?: ProtocolOptions;\n    ttl?: number;\n    prompt?: boolean;\n    tag?: number;\n  }\n\n  export interface SubscribeOptions {\n    relay: ProtocolOptions;\n  }\n\n  export interface UnsubscribeOptions {\n    id?: string;\n    relay: ProtocolOptions;\n  }\n\n  export type RequestOptions = PublishOptions | SubscribeOptions | UnsubscribeOptions;\n\n  export interface MessageEvent {\n    topic: string;\n    message: string;\n  }\n\n  export interface RpcUrlParams {\n    protocol: string;\n    version: number;\n    auth: string;\n    relayUrl: string;\n    sdkVersion: string;\n    projectId?: string;\n  }\n}\n\nexport interface RelayerOptions {\n  core: ICore;\n  logger?: string | Logger;\n  relayUrl?: string;\n  projectId?: string;\n}\n\nexport interface RelayerClientMetadata {\n  protocol: string;\n  version: number;\n  env: string;\n  host?: string;\n}\n\nexport abstract class IRelayer extends IEvents {\n  public abstract core: ICore;\n\n  public abstract logger: Logger;\n\n  public abstract subscriber: ISubscriber;\n\n  public abstract publisher: IPublisher;\n\n  public abstract messages: IMessageTracker;\n\n  public abstract provider: IJsonRpcProvider;\n\n  public abstract name: string;\n\n  public abstract readonly context: string;\n\n  public abstract readonly connected: boolean;\n\n  public abstract readonly connecting: boolean;\n\n  constructor(\n    // @ts-ignore\n    opts: RelayerOptions,\n  ) {\n    super();\n  }\n\n  public abstract init(): Promise<void>;\n\n  public abstract publish(\n    topic: string,\n    message: string,\n    opts?: RelayerTypes.PublishOptions,\n  ): Promise<void>;\n\n  public abstract subscribe(topic: string, opts?: RelayerTypes.SubscribeOptions): Promise<string>;\n\n  public abstract unsubscribe(topic: string, opts?: RelayerTypes.UnsubscribeOptions): Promise<void>;\n}\n","import { ErrorResponse } from \"@walletconnect/jsonrpc-types\";\nimport { Logger } from \"pino\";\nimport { ICore } from \"./core\";\n\nexport abstract class IStore<Key, Value> {\n  public abstract map: Map<Key, Value>;\n\n  public abstract readonly context: string;\n\n  public abstract readonly length: number;\n\n  public abstract readonly keys: Key[];\n\n  public abstract readonly values: Value[];\n\n  constructor(\n    public core: ICore,\n    public logger: Logger,\n    public name: string,\n    // @ts-ignore\n    storagePrefix?: string,\n  ) {}\n\n  public abstract init(): Promise<void>;\n\n  public abstract set(key: Key, value: Value): Promise<void>;\n\n  public abstract get(key: Key): Value;\n\n  public abstract getAll(filter?: Partial<Value>): Value[];\n\n  public abstract update(key: Key, update: Partial<Value>): Promise<void>;\n\n  public abstract delete(key: Key, reason: ErrorResponse): Promise<void>;\n}\n","import { Logger } from \"pino\";\nimport { IEvents } from \"@walletconnect/events\";\nimport { ErrorResponse } from \"@walletconnect/jsonrpc-types\";\n\nimport { IRelayer, RelayerTypes } from \"./relayer\";\n\nexport declare namespace SubscriberTypes {\n  export interface Params extends RelayerTypes.SubscribeOptions {\n    topic: string;\n  }\n\n  export interface Active extends Params {\n    id: string;\n  }\n}\n\nexport declare namespace SubscriberEvents {\n  export type Created = SubscriberTypes.Active;\n\n  export interface Deleted extends SubscriberTypes.Active {\n    reason: ErrorResponse;\n  }\n\n  export type Expired = Deleted;\n}\n\nexport abstract class ISubscriberTopicMap {\n  public map = new Map<string, string[]>();\n\n  public abstract readonly topics: string[];\n\n  public abstract set(topic: string, id: string): void;\n\n  public abstract get(topic: string): string[];\n\n  public abstract exists(topic: string, id: string): boolean;\n\n  public abstract delete(topic: string, id?: string): void;\n\n  public abstract clear(): void;\n}\n\nexport abstract class ISubscriber extends IEvents {\n  public abstract subscriptions: Map<string, SubscriberTypes.Active>;\n\n  public abstract topicMap: ISubscriberTopicMap;\n\n  public abstract readonly length: number;\n\n  public abstract readonly ids: string[];\n\n  public abstract readonly values: SubscriberTypes.Active[];\n\n  public abstract readonly topics: string[];\n\n  public abstract name: string;\n\n  public abstract readonly context: string;\n\n  constructor(public relayer: IRelayer, public logger: Logger) {\n    super();\n  }\n\n  public abstract init(): Promise<void>;\n\n  public abstract subscribe(topic: string, opts?: RelayerTypes.SubscribeOptions): Promise<string>;\n\n  public abstract unsubscribe(topic: string, opts?: RelayerTypes.UnsubscribeOptions): Promise<void>;\n\n  public abstract isSubscribed(topic: string): Promise<boolean>;\n}\n","import { Logger } from \"pino\";\nimport { ICore } from \"./core\";\n\nexport abstract class IKeyChain {\n  public abstract keychain: Map<string, string>;\n\n  public abstract name: string;\n\n  public abstract readonly context: string;\n\n  constructor(public core: ICore, public logger: Logger) {}\n\n  public abstract init(): Promise<void>;\n\n  public abstract has(tag: string, opts?: any): boolean;\n\n  public abstract set(tag: string, key: string, opts?: any): Promise<void>;\n\n  public abstract get(tag: string, opts?: any): string;\n\n  public abstract del(tag: string, opts?: any): Promise<void>;\n}\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction EventEmitter() {\n  this._events = this._events || {};\n  this._maxListeners = this._maxListeners || undefined;\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!isNumber(n) || n < 0 || isNaN(n))\n    throw TypeError('n must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nEventEmitter.prototype.emit = function(type) {\n  var er, handler, len, args, i, listeners;\n\n  if (!this._events)\n    this._events = {};\n\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events.error ||\n        (isObject(this._events.error) && !this._events.error.length)) {\n      er = arguments[1];\n      if (er instanceof Error) {\n        throw er; // Unhandled 'error' event\n      } else {\n        // At least give some kind of context to the user\n        var err = new Error('Uncaught, unspecified \"error\" event. (' + er + ')');\n        err.context = er;\n        throw err;\n      }\n    }\n  }\n\n  handler = this._events[type];\n\n  if (isUndefined(handler))\n    return false;\n\n  if (isFunction(handler)) {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n  } else if (isObject(handler)) {\n    args = Array.prototype.slice.call(arguments, 1);\n    listeners = handler.slice();\n    len = listeners.length;\n    for (i = 0; i < len; i++)\n      listeners[i].apply(this, args);\n  }\n\n  return true;\n};\n\nEventEmitter.prototype.addListener = function(type, listener) {\n  var m;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events)\n    this._events = {};\n\n  // To avoid recursion in the case that type === \"newListener\"! Before\n  // adding it to the listeners, first emit \"newListener\".\n  if (this._events.newListener)\n    this.emit('newListener', type,\n              isFunction(listener.listener) ?\n              listener.listener : listener);\n\n  if (!this._events[type])\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  else if (isObject(this._events[type]))\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  else\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n\n  // Check for listener leak\n  if (isObject(this._events[type]) && !this._events[type].warned) {\n    if (!isUndefined(this._maxListeners)) {\n      m = this._maxListeners;\n    } else {\n      m = EventEmitter.defaultMaxListeners;\n    }\n\n    if (m && m > 0 && this._events[type].length > m) {\n      this._events[type].warned = true;\n      console.error('(node) warning: possible EventEmitter memory ' +\n                    'leak detected. %d listeners added. ' +\n                    'Use emitter.setMaxListeners() to increase limit.',\n                    this._events[type].length);\n      if (typeof console.trace === 'function') {\n        // not supported in IE 10\n        console.trace();\n      }\n    }\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  var fired = false;\n\n  function g() {\n    this.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(this, arguments);\n    }\n  }\n\n  g.listener = listener;\n  this.on(type, g);\n\n  return this;\n};\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener = function(type, listener) {\n  var list, position, length, i;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events || !this._events[type])\n    return this;\n\n  list = this._events[type];\n  length = list.length;\n  position = -1;\n\n  if (list === listener ||\n      (isFunction(list.listener) && list.listener === listener)) {\n    delete this._events[type];\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n\n  } else if (isObject(list)) {\n    for (i = length; i-- > 0;) {\n      if (list[i] === listener ||\n          (list[i].listener && list[i].listener === listener)) {\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0)\n      return this;\n\n    if (list.length === 1) {\n      list.length = 0;\n      delete this._events[type];\n    } else {\n      list.splice(position, 1);\n    }\n\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  var key, listeners;\n\n  if (!this._events)\n    return this;\n\n  // not listening for removeListener, no need to emit\n  if (!this._events.removeListener) {\n    if (arguments.length === 0)\n      this._events = {};\n    else if (this._events[type])\n      delete this._events[type];\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    for (key in this._events) {\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = {};\n    return this;\n  }\n\n  listeners = this._events[type];\n\n  if (isFunction(listeners)) {\n    this.removeListener(type, listeners);\n  } else if (listeners) {\n    // LIFO order\n    while (listeners.length)\n      this.removeListener(type, listeners[listeners.length - 1]);\n  }\n  delete this._events[type];\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  var ret;\n  if (!this._events || !this._events[type])\n    ret = [];\n  else if (isFunction(this._events[type]))\n    ret = [this._events[type]];\n  else\n    ret = this._events[type].slice();\n  return ret;\n};\n\nEventEmitter.prototype.listenerCount = function(type) {\n  if (this._events) {\n    var evlistener = this._events[type];\n\n    if (isFunction(evlistener))\n      return 1;\n    else if (evlistener)\n      return evlistener.length;\n  }\n  return 0;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  return emitter.listenerCount(type);\n};\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\n","import EventEmmiter from \"events\";\nimport { Logger } from \"pino\";\nimport { IEngine } from \"./engine\";\nimport { IPairing } from \"./pairing\";\nimport { IProposal, ProposalTypes } from \"./proposal\";\nimport { ISession, SessionTypes } from \"./session\";\nimport { IJsonRpcHistory } from \"../core/history\";\nimport { CoreTypes, ICore } from \"../core/core\";\nimport { IExpirer } from \"./expirer\";\n\nexport declare namespace SignClientTypes {\n  type Event =\n    | \"session_proposal\"\n    | \"session_update\"\n    | \"session_extend\"\n    | \"session_ping\"\n    | \"pairing_ping\"\n    | \"session_delete\"\n    | \"pairing_delete\"\n    | \"session_expire\"\n    | \"pairing_expire\"\n    | \"session_request\"\n    | \"session_event\"\n    | \"proposal_expire\";\n\n  interface BaseEventArgs<T = unknown> {\n    id: number;\n    topic: string;\n    params: T;\n  }\n\n  interface EventArguments {\n    session_proposal: Omit<BaseEventArgs<ProposalTypes.Struct>, \"topic\">;\n    session_update: BaseEventArgs<{ namespaces: SessionTypes.Namespaces }>;\n    session_extend: Omit<BaseEventArgs, \"params\">;\n    session_ping: Omit<BaseEventArgs, \"params\">;\n    pairing_ping: Omit<BaseEventArgs, \"params\">;\n    session_delete: Omit<BaseEventArgs, \"params\">;\n    pairing_delete: Omit<BaseEventArgs, \"params\">;\n    session_expire: { topic: string };\n    pairing_expire: { topic: string };\n    session_request: BaseEventArgs<{\n      request: { method: string; params: any };\n      chainId: string;\n    }>;\n    session_event: BaseEventArgs<{\n      event: { name: string; data: any };\n      chainId: string;\n    }>;\n    proposal_expire: { id: number };\n  }\n\n  type Metadata = {\n    name: string;\n    description: string;\n    url: string;\n    icons: string[];\n  };\n\n  interface Options extends CoreTypes.Options {\n    core?: ICore;\n    metadata?: Metadata;\n  }\n}\n\nexport abstract class ISignClientEvents extends EventEmmiter {\n  constructor() {\n    super();\n  }\n\n  public abstract emit: <E extends SignClientTypes.Event>(\n    event: E,\n    args: SignClientTypes.EventArguments[E],\n  ) => boolean;\n\n  public abstract on: <E extends SignClientTypes.Event>(\n    event: E,\n    listener: (args: SignClientTypes.EventArguments[E]) => any,\n  ) => this;\n\n  public abstract once: <E extends SignClientTypes.Event>(\n    event: E,\n    listener: (args: SignClientTypes.EventArguments[E]) => any,\n  ) => this;\n\n  public abstract off: <E extends SignClientTypes.Event>(\n    event: E,\n    listener: (args: SignClientTypes.EventArguments[E]) => any,\n  ) => this;\n\n  public abstract removeListener: <E extends SignClientTypes.Event>(\n    event: E,\n    listener: (args: SignClientTypes.EventArguments[E]) => any,\n  ) => this;\n}\n\nexport abstract class ISignClient {\n  public readonly protocol = \"wc\";\n  public readonly version = 2;\n\n  public abstract readonly name: string;\n  public abstract readonly context: string;\n  public abstract readonly metadata: SignClientTypes.Metadata;\n\n  public abstract core: ICore;\n  public abstract logger: Logger;\n  public abstract events: ISignClientEvents;\n  public abstract engine: IEngine;\n  public abstract pairing: IPairing;\n  public abstract session: ISession;\n  public abstract proposal: IProposal;\n  public abstract history: IJsonRpcHistory;\n  public abstract expirer: IExpirer;\n\n  constructor(public opts?: SignClientTypes.Options) {}\n\n  public abstract connect: IEngine[\"connect\"];\n  public abstract pair: IEngine[\"pair\"];\n  public abstract approve: IEngine[\"approve\"];\n  public abstract reject: IEngine[\"reject\"];\n  public abstract update: IEngine[\"update\"];\n  public abstract extend: IEngine[\"extend\"];\n  public abstract request: IEngine[\"request\"];\n  public abstract respond: IEngine[\"respond\"];\n  public abstract ping: IEngine[\"ping\"];\n  public abstract emit: IEngine[\"emit\"];\n  public abstract disconnect: IEngine[\"disconnect\"];\n  public abstract find: IEngine[\"find\"];\n}\n","import {\n  JsonRpcResponse,\n  JsonRpcRequest,\n  ErrorResponse,\n  JsonRpcResult,\n  JsonRpcError,\n} from \"@walletconnect/jsonrpc-types\";\nimport { ISignClient } from \"./client\";\nimport { RelayerTypes } from \"../core/relayer\";\nimport { SessionTypes } from \"./session\";\nimport { ProposalTypes } from \"./proposal\";\nimport { PairingTypes } from \"./pairing\";\nimport { JsonRpcTypes } from \"./jsonrpc\";\nimport { EventEmitter } from \"events\";\n\nexport declare namespace EngineTypes {\n  type Event =\n    | \"session_connect\"\n    | \"session_approve\"\n    | \"session_update\"\n    | \"session_extend\"\n    | \"session_ping\"\n    | \"pairing_ping\"\n    | \"session_request\";\n\n  interface EventArguments {\n    session_connect: {\n      error?: ErrorResponse;\n      session?: Omit<SessionTypes.Struct, \"requiredNamespaces\">;\n    };\n    session_approve: { error?: ErrorResponse };\n    session_update: { error?: ErrorResponse };\n    session_extend: { error?: ErrorResponse };\n    session_ping: { error?: ErrorResponse };\n    pairing_ping: { error?: ErrorResponse };\n    session_request: { error?: ErrorResponse; result?: any };\n  }\n\n  interface UriParameters {\n    protocol: string;\n    version: number;\n    topic: string;\n    symKey: string;\n    relay: RelayerTypes.ProtocolOptions;\n  }\n\n  interface EventCallback<T extends JsonRpcRequest | JsonRpcResponse> {\n    topic: string;\n    payload: T;\n  }\n\n  interface ConnectParams {\n    requiredNamespaces: ProposalTypes.RequiredNamespaces;\n    pairingTopic?: string;\n    relays?: RelayerTypes.ProtocolOptions[];\n  }\n\n  interface PairParams {\n    uri: string;\n  }\n\n  interface ApproveParams {\n    id: number;\n    namespaces: SessionTypes.Namespaces;\n    relayProtocol?: string;\n  }\n\n  interface RejectParams {\n    id: number;\n    reason: ErrorResponse;\n  }\n\n  interface UpdateParams {\n    topic: string;\n    namespaces: SessionTypes.Namespaces;\n  }\n\n  interface ExtendParams {\n    topic: string;\n  }\n\n  interface RequestParams {\n    topic: string;\n    request: {\n      method: string;\n      params: any;\n    };\n    chainId: string;\n  }\n\n  interface RespondParams {\n    topic: string;\n    response: JsonRpcResponse;\n  }\n\n  interface EmitParams {\n    topic: string;\n    event: {\n      name: string;\n      data: any;\n    };\n    chainId: string;\n  }\n\n  interface PingParams {\n    topic: string;\n  }\n\n  interface DisconnectParams {\n    topic: string;\n    reason: ErrorResponse;\n  }\n\n  interface FindParams {\n    requiredNamespaces: ProposalTypes.RequiredNamespaces;\n  }\n\n  type AcknowledgedPromise = Promise<{ acknowledged: () => Promise<void> }>;\n\n  interface RpcOpts {\n    req: RelayerTypes.PublishOptions;\n    res: RelayerTypes.PublishOptions;\n  }\n\n  type RpcOptsMap = Record<JsonRpcTypes.WcMethod, RpcOpts>;\n}\n\nexport abstract class IEngineEvents extends EventEmitter {\n  constructor() {\n    super();\n  }\n\n  public abstract emit: <E extends EngineTypes.Event>(\n    event: string,\n    args: EngineTypes.EventArguments[E],\n  ) => boolean;\n\n  public abstract once: <E extends EngineTypes.Event>(\n    event: string,\n    listener: (args: EngineTypes.EventArguments[E]) => any,\n  ) => this;\n}\n\n// -- private method interface -------------------------------------- //\n\nexport interface EnginePrivate {\n  sendRequest<M extends JsonRpcTypes.WcMethod>(\n    topic: string,\n    method: M,\n    params: JsonRpcTypes.RequestParams[M],\n  ): Promise<number>;\n\n  sendResult<M extends JsonRpcTypes.WcMethod>(\n    id: number,\n    topic: string,\n    result: JsonRpcTypes.Results[M],\n  ): Promise<void>;\n\n  sendError(id: number, topic: string, error: JsonRpcTypes.Error): Promise<void>;\n\n  onRelayEventRequest(event: EngineTypes.EventCallback<JsonRpcRequest>): void;\n\n  onRelayEventResponse(event: EngineTypes.EventCallback<JsonRpcResponse>): Promise<void>;\n\n  activatePairing(topic: string): Promise<void>;\n\n  deleteSession(topic: string): Promise<void>;\n\n  deletePairing(topic: string): Promise<void>;\n\n  deleteProposal(id: number): Promise<void>;\n\n  setExpiry(topic: string, expiry: number): Promise<void>;\n\n  setProposal(id: number, proposal: ProposalTypes.Struct): Promise<void>;\n\n  cleanup(): Promise<void>;\n\n  onSessionProposeRequest(\n    topic: string,\n    payload: JsonRpcRequest<JsonRpcTypes.RequestParams[\"wc_sessionPropose\"]>,\n  ): Promise<void>;\n\n  onSessionProposeResponse(\n    topic: string,\n    payload: JsonRpcResult<JsonRpcTypes.Results[\"wc_sessionPropose\"]> | JsonRpcError,\n  ): Promise<void>;\n\n  onSessionSettleRequest(\n    topic: string,\n    payload: JsonRpcRequest<JsonRpcTypes.RequestParams[\"wc_sessionSettle\"]>,\n  ): Promise<void>;\n\n  onSessionSettleResponse(\n    topic: string,\n    payload: JsonRpcResult<JsonRpcTypes.Results[\"wc_sessionSettle\"]> | JsonRpcError,\n  ): Promise<void>;\n\n  onSessionUpdateRequest(\n    topic: string,\n    payload: JsonRpcRequest<JsonRpcTypes.RequestParams[\"wc_sessionUpdate\"]>,\n  ): Promise<void>;\n\n  onSessionUpdateResponse(\n    topic: string,\n    payload: JsonRpcResult<JsonRpcTypes.Results[\"wc_sessionUpdate\"]> | JsonRpcError,\n  ): void;\n\n  onSessionExtendRequest(\n    topic: string,\n    payload: JsonRpcRequest<JsonRpcTypes.RequestParams[\"wc_sessionExtend\"]>,\n  ): Promise<void>;\n\n  onSessionExtendResponse(\n    topic: string,\n    payload: JsonRpcResult<JsonRpcTypes.Results[\"wc_sessionExtend\"]> | JsonRpcError,\n  ): void;\n\n  onSessionPingRequest(\n    topic: string,\n    payload: JsonRpcRequest<JsonRpcTypes.RequestParams[\"wc_sessionPing\"]>,\n  ): Promise<void>;\n\n  onSessionPingResponse(\n    topic: string,\n    payload: JsonRpcResult<JsonRpcTypes.Results[\"wc_sessionPing\"]> | JsonRpcError,\n  ): void;\n\n  onPairingPingRequest(\n    topic: string,\n    payload: JsonRpcRequest<JsonRpcTypes.RequestParams[\"wc_pairingPing\"]>,\n  ): Promise<void>;\n\n  onPairingPingResponse(\n    topic: string,\n    payload: JsonRpcResult<JsonRpcTypes.Results[\"wc_pairingPing\"]> | JsonRpcError,\n  ): void;\n\n  onSessionDeleteRequest(\n    topic: string,\n    payload: JsonRpcRequest<JsonRpcTypes.RequestParams[\"wc_sessionDelete\"]>,\n  ): Promise<void>;\n\n  onPairingDeleteRequest(\n    topic: string,\n    payload: JsonRpcRequest<JsonRpcTypes.RequestParams[\"wc_pairingDelete\"]>,\n  ): Promise<void>;\n\n  onSessionRequest(\n    topic: string,\n    payload: JsonRpcRequest<JsonRpcTypes.RequestParams[\"wc_sessionRequest\"]>,\n  ): Promise<void>;\n\n  onSessionRequestResponse(\n    topic: string,\n    payload: JsonRpcResult<JsonRpcTypes.Results[\"wc_sessionRequest\"]> | JsonRpcError,\n  ): void;\n\n  onSessionEventRequest(\n    topic: string,\n    payload: JsonRpcRequest<JsonRpcTypes.RequestParams[\"wc_sessionEvent\"]>,\n  ): Promise<void>;\n\n  // -- Validators ---------------------------------------------------- //\n  isValidConnect(params: EngineTypes.ConnectParams): Promise<void>;\n\n  isValidPair(params: EngineTypes.PairParams): void;\n\n  isValidSessionSettleRequest(params: JsonRpcTypes.RequestParams[\"wc_sessionSettle\"]): void;\n\n  isValidApprove(params: EngineTypes.ApproveParams): Promise<void>;\n\n  isValidReject(params: EngineTypes.RejectParams): Promise<void>;\n\n  isValidUpdate(params: EngineTypes.UpdateParams): Promise<void>;\n\n  isValidExtend(params: EngineTypes.ExtendParams): Promise<void>;\n\n  isValidRequest(params: EngineTypes.RequestParams): Promise<void>;\n\n  isValidRespond(params: EngineTypes.RespondParams): Promise<void>;\n\n  isValidPing(params: EngineTypes.PingParams): Promise<void>;\n\n  isValidEmit(params: EngineTypes.EmitParams): Promise<void>;\n\n  isValidDisconnect(params: EngineTypes.DisconnectParams): Promise<void>;\n}\n\n// -- class interface ----------------------------------------------- //\n\nexport abstract class IEngine {\n  constructor(public client: ISignClient) {}\n\n  public abstract init(): Promise<void>;\n\n  public abstract connect(\n    params: EngineTypes.ConnectParams,\n  ): Promise<{ uri?: string; approval: () => Promise<SessionTypes.Struct> }>;\n\n  public abstract pair(params: EngineTypes.PairParams): Promise<PairingTypes.Struct>;\n\n  public abstract approve(\n    params: EngineTypes.ApproveParams,\n  ): Promise<{ topic: string; acknowledged: () => Promise<SessionTypes.Struct> }>;\n\n  public abstract reject(params: EngineTypes.RejectParams): Promise<void>;\n\n  public abstract update(params: EngineTypes.UpdateParams): EngineTypes.AcknowledgedPromise;\n\n  public abstract extend(params: EngineTypes.ExtendParams): EngineTypes.AcknowledgedPromise;\n\n  public abstract request<T>(params: EngineTypes.RequestParams): Promise<T>;\n\n  public abstract respond(params: EngineTypes.RespondParams): Promise<void>;\n\n  public abstract emit(params: EngineTypes.EmitParams): Promise<void>;\n\n  public abstract ping(params: EngineTypes.PingParams): Promise<void>;\n\n  public abstract disconnect(params: EngineTypes.DisconnectParams): Promise<void>;\n\n  public abstract find: (params: EngineTypes.FindParams) => SessionTypes.Struct[];\n}\n","import { Logger } from \"pino\";\nimport { IEvents } from \"@walletconnect/events\";\n\nimport { ICore } from \"../core/core\";\n\nexport declare namespace ExpirerTypes {\n  interface Expiration {\n    target: string;\n    expiry: number;\n  }\n\n  interface Created {\n    target: string;\n    expiration: Expiration;\n  }\n\n  interface Deleted {\n    target: string;\n    expiration: Expiration;\n  }\n\n  interface Expired {\n    target: string;\n    expiration: Expiration;\n  }\n}\n\nexport abstract class IExpirer extends IEvents {\n  public abstract name: string;\n\n  public abstract readonly context: string;\n\n  public abstract readonly length: number;\n\n  public abstract readonly keys: string[];\n\n  public abstract readonly values: ExpirerTypes.Expiration[];\n\n  constructor(public core: ICore, public logger: Logger) {\n    super();\n  }\n\n  public abstract init(): Promise<void>;\n\n  public abstract has(key: string | number): boolean;\n\n  public abstract set(key: string | number, expiry: number): void;\n\n  public abstract get(key: string | number): ExpirerTypes.Expiration;\n\n  public abstract del(key: string | number): void;\n}\n"],"mappings":"","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}