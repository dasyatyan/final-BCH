{"ast":null,"code":"import ee from \"pino\";\nimport at from \"@walletconnect/keyvaluestorage\";\nimport { HEARTBEAT_EVENTS as te, HeartBeat as ot } from \"@walletconnect/heartbeat\";\nimport { generateChildLogger as I, getLoggerContext as A, getDefaultLoggerOptions as se } from \"@walletconnect/logger\";\nimport { IMessageTracker as ut, IPublisher as ht, ISubscriber as ct, IRelayer as lt, IStore as Dt, ICore as dt } from \"@walletconnect/types\";\nimport { safeJsonStringify as gt, safeJsonParse as pt } from \"@walletconnect/safe-json\";\nimport * as N from \"@walletconnect/relay-auth\";\nimport { getInternalError as m, mapToObj as ie, objToMap as re, generateKeyPair as bt, generateRandomBytes32 as ne, deriveSymKey as ft, hashKey as yt, validateEncoding as mt, isTypeOneEnvelope as ae, encrypt as Et, validateDecoding as vt, decrypt as wt, hashMessage as B, getRelayProtocolName as V, getRelayProtocolApi as G, isUndefined as q, getSdkError as Ct, formatRelayRpcUrl as _t, isProposalStruct as St, isSessionStruct as It } from \"@walletconnect/utils\";\nimport { ONE_DAY as At, SIX_HOURS as Ot, ONE_SECOND as Rt, THIRTY_DAYS as Tt, FIVE_SECONDS as zt, Watch as Pt, toMiliseconds as xt } from \"@walletconnect/time\";\nimport { JsonRpcProvider as Lt } from \"@walletconnect/jsonrpc-provider\";\nimport { isJsonRpcRequest as Ft, formatJsonRpcResult as Ut } from \"@walletconnect/jsonrpc-utils\";\nimport Nt from \"@walletconnect/jsonrpc-ws-connection\";\nimport Bt from \"lodash.isequal\";\nfunction D() {\n  this._events = this._events || {}, this._maxListeners = this._maxListeners || void 0;\n}\nvar M = D;\nD.EventEmitter = D, D.prototype._events = void 0, D.prototype._maxListeners = void 0, D.defaultMaxListeners = 10, D.prototype.setMaxListeners = function (s) {\n  if (!Mt(s) || s < 0 || isNaN(s)) throw TypeError(\"n must be a positive number\");\n  return this._maxListeners = s, this;\n}, D.prototype.emit = function (s) {\n  var e, t, i, r, n, a;\n  if (this._events || (this._events = {}), s === \"error\" && (!this._events.error || P(this._events.error) && !this._events.error.length)) {\n    if (e = arguments[1], e instanceof Error) throw e;\n    var o = new Error('Uncaught, unspecified \"error\" event. (' + e + \")\");\n    throw o.context = e, o;\n  }\n  if (t = this._events[s], oe(t)) return !1;\n  if (_(t)) switch (arguments.length) {\n    case 1:\n      t.call(this);\n      break;\n    case 2:\n      t.call(this, arguments[1]);\n      break;\n    case 3:\n      t.call(this, arguments[1], arguments[2]);\n      break;\n    default:\n      r = Array.prototype.slice.call(arguments, 1), t.apply(this, r);\n  } else if (P(t)) for (r = Array.prototype.slice.call(arguments, 1), a = t.slice(), i = a.length, n = 0; n < i; n++) a[n].apply(this, r);\n  return !0;\n}, D.prototype.addListener = function (s, e) {\n  var t;\n  if (!_(e)) throw TypeError(\"listener must be a function\");\n  return this._events || (this._events = {}), this._events.newListener && this.emit(\"newListener\", s, _(e.listener) ? e.listener : e), this._events[s] ? P(this._events[s]) ? this._events[s].push(e) : this._events[s] = [this._events[s], e] : this._events[s] = e, P(this._events[s]) && !this._events[s].warned && (oe(this._maxListeners) ? t = D.defaultMaxListeners : t = this._maxListeners, t && t > 0 && this._events[s].length > t && (this._events[s].warned = !0, console.error(\"(node) warning: possible EventEmitter memory leak detected. %d listeners added. Use emitter.setMaxListeners() to increase limit.\", this._events[s].length), typeof console.trace == \"function\" && console.trace())), this;\n}, D.prototype.on = D.prototype.addListener, D.prototype.once = function (s, e) {\n  if (!_(e)) throw TypeError(\"listener must be a function\");\n  var t = !1;\n  function i() {\n    this.removeListener(s, i), t || (t = !0, e.apply(this, arguments));\n  }\n  return i.listener = e, this.on(s, i), this;\n}, D.prototype.removeListener = function (s, e) {\n  var t, i, r, n;\n  if (!_(e)) throw TypeError(\"listener must be a function\");\n  if (!this._events || !this._events[s]) return this;\n  if (t = this._events[s], r = t.length, i = -1, t === e || _(t.listener) && t.listener === e) delete this._events[s], this._events.removeListener && this.emit(\"removeListener\", s, e);else if (P(t)) {\n    for (n = r; n-- > 0;) if (t[n] === e || t[n].listener && t[n].listener === e) {\n      i = n;\n      break;\n    }\n    if (i < 0) return this;\n    t.length === 1 ? (t.length = 0, delete this._events[s]) : t.splice(i, 1), this._events.removeListener && this.emit(\"removeListener\", s, e);\n  }\n  return this;\n}, D.prototype.removeAllListeners = function (s) {\n  var e, t;\n  if (!this._events) return this;\n  if (!this._events.removeListener) return arguments.length === 0 ? this._events = {} : this._events[s] && delete this._events[s], this;\n  if (arguments.length === 0) {\n    for (e in this._events) e !== \"removeListener\" && this.removeAllListeners(e);\n    return this.removeAllListeners(\"removeListener\"), this._events = {}, this;\n  }\n  if (t = this._events[s], _(t)) this.removeListener(s, t);else if (t) for (; t.length;) this.removeListener(s, t[t.length - 1]);\n  return delete this._events[s], this;\n}, D.prototype.listeners = function (s) {\n  var e;\n  return !this._events || !this._events[s] ? e = [] : _(this._events[s]) ? e = [this._events[s]] : e = this._events[s].slice(), e;\n}, D.prototype.listenerCount = function (s) {\n  if (this._events) {\n    var e = this._events[s];\n    if (_(e)) return 1;\n    if (e) return e.length;\n  }\n  return 0;\n}, D.listenerCount = function (s, e) {\n  return s.listenerCount(e);\n};\nfunction _(s) {\n  return typeof s == \"function\";\n}\nfunction Mt(s) {\n  return typeof s == \"number\";\n}\nfunction P(s) {\n  return typeof s == \"object\" && s !== null;\n}\nfunction oe(s) {\n  return s === void 0;\n}\nfunction Kt(s, e) {\n  if (s.length >= 255) throw new TypeError(\"Alphabet too long\");\n  for (var t = new Uint8Array(256), i = 0; i < t.length; i++) t[i] = 255;\n  for (var r = 0; r < s.length; r++) {\n    var n = s.charAt(r),\n      a = n.charCodeAt(0);\n    if (t[a] !== 255) throw new TypeError(n + \" is ambiguous\");\n    t[a] = r;\n  }\n  var o = s.length,\n    u = s.charAt(0),\n    p = Math.log(o) / Math.log(256),\n    c = Math.log(256) / Math.log(o);\n  function l(h) {\n    if (h instanceof Uint8Array || (ArrayBuffer.isView(h) ? h = new Uint8Array(h.buffer, h.byteOffset, h.byteLength) : Array.isArray(h) && (h = Uint8Array.from(h))), !(h instanceof Uint8Array)) throw new TypeError(\"Expected Uint8Array\");\n    if (h.length === 0) return \"\";\n    for (var g = 0, R = 0, f = 0, E = h.length; f !== E && h[f] === 0;) f++, g++;\n    for (var v = (E - f) * c + 1 >>> 0, b = new Uint8Array(v); f !== E;) {\n      for (var w = h[f], S = 0, y = v - 1; (w !== 0 || S < R) && y !== -1; y--, S++) w += 256 * b[y] >>> 0, b[y] = w % o >>> 0, w = w / o >>> 0;\n      if (w !== 0) throw new Error(\"Non-zero carry\");\n      R = S, f++;\n    }\n    for (var C = v - R; C !== v && b[C] === 0;) C++;\n    for (var U = u.repeat(g); C < v; ++C) U += s.charAt(b[C]);\n    return U;\n  }\n  function F(h) {\n    if (typeof h != \"string\") throw new TypeError(\"Expected String\");\n    if (h.length === 0) return new Uint8Array();\n    var g = 0;\n    if (h[g] !== \" \") {\n      for (var R = 0, f = 0; h[g] === u;) R++, g++;\n      for (var E = (h.length - g) * p + 1 >>> 0, v = new Uint8Array(E); h[g];) {\n        var b = t[h.charCodeAt(g)];\n        if (b === 255) return;\n        for (var w = 0, S = E - 1; (b !== 0 || w < f) && S !== -1; S--, w++) b += o * v[S] >>> 0, v[S] = b % 256 >>> 0, b = b / 256 >>> 0;\n        if (b !== 0) throw new Error(\"Non-zero carry\");\n        f = w, g++;\n      }\n      if (h[g] !== \" \") {\n        for (var y = E - f; y !== E && v[y] === 0;) y++;\n        for (var C = new Uint8Array(R + (E - y)), U = R; y !== E;) C[U++] = v[y++];\n        return C;\n      }\n    }\n  }\n  function Y(h) {\n    var g = F(h);\n    if (g) return g;\n    throw new Error(`Non-${e} character`);\n  }\n  return {\n    encode: l,\n    decodeUnsafe: F,\n    decode: Y\n  };\n}\nvar kt = Kt,\n  $t = kt;\nconst ue = s => {\n    if (s instanceof Uint8Array && s.constructor.name === \"Uint8Array\") return s;\n    if (s instanceof ArrayBuffer) return new Uint8Array(s);\n    if (ArrayBuffer.isView(s)) return new Uint8Array(s.buffer, s.byteOffset, s.byteLength);\n    throw new Error(\"Unknown type, must be binary type\");\n  },\n  jt = s => new TextEncoder().encode(s),\n  Yt = s => new TextDecoder().decode(s);\nclass Vt {\n  constructor(e, t, i) {\n    this.name = e, this.prefix = t, this.baseEncode = i;\n  }\n  encode(e) {\n    if (e instanceof Uint8Array) return `${this.prefix}${this.baseEncode(e)}`;\n    throw Error(\"Unknown type, must be binary type\");\n  }\n}\nclass Gt {\n  constructor(e, t, i) {\n    if (this.name = e, this.prefix = t, t.codePointAt(0) === void 0) throw new Error(\"Invalid prefix character\");\n    this.prefixCodePoint = t.codePointAt(0), this.baseDecode = i;\n  }\n  decode(e) {\n    if (typeof e == \"string\") {\n      if (e.codePointAt(0) !== this.prefixCodePoint) throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);\n      return this.baseDecode(e.slice(this.prefix.length));\n    } else throw Error(\"Can only multibase decode strings\");\n  }\n  or(e) {\n    return he(this, e);\n  }\n}\nclass qt {\n  constructor(e) {\n    this.decoders = e;\n  }\n  or(e) {\n    return he(this, e);\n  }\n  decode(e) {\n    const t = e[0],\n      i = this.decoders[t];\n    if (i) return i.decode(e);\n    throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);\n  }\n}\nconst he = (s, e) => new qt({\n  ...(s.decoders || {\n    [s.prefix]: s\n  }),\n  ...(e.decoders || {\n    [e.prefix]: e\n  })\n});\nclass Jt {\n  constructor(e, t, i, r) {\n    this.name = e, this.prefix = t, this.baseEncode = i, this.baseDecode = r, this.encoder = new Vt(e, t, i), this.decoder = new Gt(e, t, r);\n  }\n  encode(e) {\n    return this.encoder.encode(e);\n  }\n  decode(e) {\n    return this.decoder.decode(e);\n  }\n}\nconst K = ({\n    name: s,\n    prefix: e,\n    encode: t,\n    decode: i\n  }) => new Jt(s, e, t, i),\n  x = ({\n    prefix: s,\n    name: e,\n    alphabet: t\n  }) => {\n    const {\n      encode: i,\n      decode: r\n    } = $t(t, e);\n    return K({\n      prefix: s,\n      name: e,\n      encode: i,\n      decode: n => ue(r(n))\n    });\n  },\n  Wt = (s, e, t, i) => {\n    const r = {};\n    for (let c = 0; c < e.length; ++c) r[e[c]] = c;\n    let n = s.length;\n    for (; s[n - 1] === \"=\";) --n;\n    const a = new Uint8Array(n * t / 8 | 0);\n    let o = 0,\n      u = 0,\n      p = 0;\n    for (let c = 0; c < n; ++c) {\n      const l = r[s[c]];\n      if (l === void 0) throw new SyntaxError(`Non-${i} character`);\n      u = u << t | l, o += t, o >= 8 && (o -= 8, a[p++] = 255 & u >> o);\n    }\n    if (o >= t || 255 & u << 8 - o) throw new SyntaxError(\"Unexpected end of data\");\n    return a;\n  },\n  Xt = (s, e, t) => {\n    const i = e[e.length - 1] === \"=\",\n      r = (1 << t) - 1;\n    let n = \"\",\n      a = 0,\n      o = 0;\n    for (let u = 0; u < s.length; ++u) for (o = o << 8 | s[u], a += 8; a > t;) a -= t, n += e[r & o >> a];\n    if (a && (n += e[r & o << t - a]), i) for (; n.length * t & 7;) n += \"=\";\n    return n;\n  },\n  d = ({\n    name: s,\n    prefix: e,\n    bitsPerChar: t,\n    alphabet: i\n  }) => K({\n    prefix: e,\n    name: s,\n    encode(r) {\n      return Xt(r, i, t);\n    },\n    decode(r) {\n      return Wt(r, i, t, s);\n    }\n  }),\n  Ht = K({\n    prefix: \"\\0\",\n    name: \"identity\",\n    encode: s => Yt(s),\n    decode: s => jt(s)\n  });\nvar Zt = Object.freeze({\n  __proto__: null,\n  identity: Ht\n});\nconst Qt = d({\n  prefix: \"0\",\n  name: \"base2\",\n  alphabet: \"01\",\n  bitsPerChar: 1\n});\nvar es = Object.freeze({\n  __proto__: null,\n  base2: Qt\n});\nconst ts = d({\n  prefix: \"7\",\n  name: \"base8\",\n  alphabet: \"01234567\",\n  bitsPerChar: 3\n});\nvar ss = Object.freeze({\n  __proto__: null,\n  base8: ts\n});\nconst is = x({\n  prefix: \"9\",\n  name: \"base10\",\n  alphabet: \"0123456789\"\n});\nvar rs = Object.freeze({\n  __proto__: null,\n  base10: is\n});\nconst ns = d({\n    prefix: \"f\",\n    name: \"base16\",\n    alphabet: \"0123456789abcdef\",\n    bitsPerChar: 4\n  }),\n  as = d({\n    prefix: \"F\",\n    name: \"base16upper\",\n    alphabet: \"0123456789ABCDEF\",\n    bitsPerChar: 4\n  });\nvar os = Object.freeze({\n  __proto__: null,\n  base16: ns,\n  base16upper: as\n});\nconst us = d({\n    prefix: \"b\",\n    name: \"base32\",\n    alphabet: \"abcdefghijklmnopqrstuvwxyz234567\",\n    bitsPerChar: 5\n  }),\n  hs = d({\n    prefix: \"B\",\n    name: \"base32upper\",\n    alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\",\n    bitsPerChar: 5\n  }),\n  cs = d({\n    prefix: \"c\",\n    name: \"base32pad\",\n    alphabet: \"abcdefghijklmnopqrstuvwxyz234567=\",\n    bitsPerChar: 5\n  }),\n  ls = d({\n    prefix: \"C\",\n    name: \"base32padupper\",\n    alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=\",\n    bitsPerChar: 5\n  }),\n  Ds = d({\n    prefix: \"v\",\n    name: \"base32hex\",\n    alphabet: \"0123456789abcdefghijklmnopqrstuv\",\n    bitsPerChar: 5\n  }),\n  ds = d({\n    prefix: \"V\",\n    name: \"base32hexupper\",\n    alphabet: \"0123456789ABCDEFGHIJKLMNOPQRSTUV\",\n    bitsPerChar: 5\n  }),\n  gs = d({\n    prefix: \"t\",\n    name: \"base32hexpad\",\n    alphabet: \"0123456789abcdefghijklmnopqrstuv=\",\n    bitsPerChar: 5\n  }),\n  ps = d({\n    prefix: \"T\",\n    name: \"base32hexpadupper\",\n    alphabet: \"0123456789ABCDEFGHIJKLMNOPQRSTUV=\",\n    bitsPerChar: 5\n  }),\n  bs = d({\n    prefix: \"h\",\n    name: \"base32z\",\n    alphabet: \"ybndrfg8ejkmcpqxot1uwisza345h769\",\n    bitsPerChar: 5\n  });\nvar fs = Object.freeze({\n  __proto__: null,\n  base32: us,\n  base32upper: hs,\n  base32pad: cs,\n  base32padupper: ls,\n  base32hex: Ds,\n  base32hexupper: ds,\n  base32hexpad: gs,\n  base32hexpadupper: ps,\n  base32z: bs\n});\nconst ys = x({\n    prefix: \"k\",\n    name: \"base36\",\n    alphabet: \"0123456789abcdefghijklmnopqrstuvwxyz\"\n  }),\n  ms = x({\n    prefix: \"K\",\n    name: \"base36upper\",\n    alphabet: \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  });\nvar Es = Object.freeze({\n  __proto__: null,\n  base36: ys,\n  base36upper: ms\n});\nconst vs = x({\n    name: \"base58btc\",\n    prefix: \"z\",\n    alphabet: \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\"\n  }),\n  ws = x({\n    name: \"base58flickr\",\n    prefix: \"Z\",\n    alphabet: \"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ\"\n  });\nvar Cs = Object.freeze({\n  __proto__: null,\n  base58btc: vs,\n  base58flickr: ws\n});\nconst _s = d({\n    prefix: \"m\",\n    name: \"base64\",\n    alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\",\n    bitsPerChar: 6\n  }),\n  Ss = d({\n    prefix: \"M\",\n    name: \"base64pad\",\n    alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\",\n    bitsPerChar: 6\n  }),\n  Is = d({\n    prefix: \"u\",\n    name: \"base64url\",\n    alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\",\n    bitsPerChar: 6\n  }),\n  As = d({\n    prefix: \"U\",\n    name: \"base64urlpad\",\n    alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=\",\n    bitsPerChar: 6\n  });\nvar Os = Object.freeze({\n  __proto__: null,\n  base64: _s,\n  base64pad: Ss,\n  base64url: Is,\n  base64urlpad: As\n});\nconst ce = Array.from(\"\\u{1F680}\\u{1FA90}\\u2604\\u{1F6F0}\\u{1F30C}\\u{1F311}\\u{1F312}\\u{1F313}\\u{1F314}\\u{1F315}\\u{1F316}\\u{1F317}\\u{1F318}\\u{1F30D}\\u{1F30F}\\u{1F30E}\\u{1F409}\\u2600\\u{1F4BB}\\u{1F5A5}\\u{1F4BE}\\u{1F4BF}\\u{1F602}\\u2764\\u{1F60D}\\u{1F923}\\u{1F60A}\\u{1F64F}\\u{1F495}\\u{1F62D}\\u{1F618}\\u{1F44D}\\u{1F605}\\u{1F44F}\\u{1F601}\\u{1F525}\\u{1F970}\\u{1F494}\\u{1F496}\\u{1F499}\\u{1F622}\\u{1F914}\\u{1F606}\\u{1F644}\\u{1F4AA}\\u{1F609}\\u263A\\u{1F44C}\\u{1F917}\\u{1F49C}\\u{1F614}\\u{1F60E}\\u{1F607}\\u{1F339}\\u{1F926}\\u{1F389}\\u{1F49E}\\u270C\\u2728\\u{1F937}\\u{1F631}\\u{1F60C}\\u{1F338}\\u{1F64C}\\u{1F60B}\\u{1F497}\\u{1F49A}\\u{1F60F}\\u{1F49B}\\u{1F642}\\u{1F493}\\u{1F929}\\u{1F604}\\u{1F600}\\u{1F5A4}\\u{1F603}\\u{1F4AF}\\u{1F648}\\u{1F447}\\u{1F3B6}\\u{1F612}\\u{1F92D}\\u2763\\u{1F61C}\\u{1F48B}\\u{1F440}\\u{1F62A}\\u{1F611}\\u{1F4A5}\\u{1F64B}\\u{1F61E}\\u{1F629}\\u{1F621}\\u{1F92A}\\u{1F44A}\\u{1F973}\\u{1F625}\\u{1F924}\\u{1F449}\\u{1F483}\\u{1F633}\\u270B\\u{1F61A}\\u{1F61D}\\u{1F634}\\u{1F31F}\\u{1F62C}\\u{1F643}\\u{1F340}\\u{1F337}\\u{1F63B}\\u{1F613}\\u2B50\\u2705\\u{1F97A}\\u{1F308}\\u{1F608}\\u{1F918}\\u{1F4A6}\\u2714\\u{1F623}\\u{1F3C3}\\u{1F490}\\u2639\\u{1F38A}\\u{1F498}\\u{1F620}\\u261D\\u{1F615}\\u{1F33A}\\u{1F382}\\u{1F33B}\\u{1F610}\\u{1F595}\\u{1F49D}\\u{1F64A}\\u{1F639}\\u{1F5E3}\\u{1F4AB}\\u{1F480}\\u{1F451}\\u{1F3B5}\\u{1F91E}\\u{1F61B}\\u{1F534}\\u{1F624}\\u{1F33C}\\u{1F62B}\\u26BD\\u{1F919}\\u2615\\u{1F3C6}\\u{1F92B}\\u{1F448}\\u{1F62E}\\u{1F646}\\u{1F37B}\\u{1F343}\\u{1F436}\\u{1F481}\\u{1F632}\\u{1F33F}\\u{1F9E1}\\u{1F381}\\u26A1\\u{1F31E}\\u{1F388}\\u274C\\u270A\\u{1F44B}\\u{1F630}\\u{1F928}\\u{1F636}\\u{1F91D}\\u{1F6B6}\\u{1F4B0}\\u{1F353}\\u{1F4A2}\\u{1F91F}\\u{1F641}\\u{1F6A8}\\u{1F4A8}\\u{1F92C}\\u2708\\u{1F380}\\u{1F37A}\\u{1F913}\\u{1F619}\\u{1F49F}\\u{1F331}\\u{1F616}\\u{1F476}\\u{1F974}\\u25B6\\u27A1\\u2753\\u{1F48E}\\u{1F4B8}\\u2B07\\u{1F628}\\u{1F31A}\\u{1F98B}\\u{1F637}\\u{1F57A}\\u26A0\\u{1F645}\\u{1F61F}\\u{1F635}\\u{1F44E}\\u{1F932}\\u{1F920}\\u{1F927}\\u{1F4CC}\\u{1F535}\\u{1F485}\\u{1F9D0}\\u{1F43E}\\u{1F352}\\u{1F617}\\u{1F911}\\u{1F30A}\\u{1F92F}\\u{1F437}\\u260E\\u{1F4A7}\\u{1F62F}\\u{1F486}\\u{1F446}\\u{1F3A4}\\u{1F647}\\u{1F351}\\u2744\\u{1F334}\\u{1F4A3}\\u{1F438}\\u{1F48C}\\u{1F4CD}\\u{1F940}\\u{1F922}\\u{1F445}\\u{1F4A1}\\u{1F4A9}\\u{1F450}\\u{1F4F8}\\u{1F47B}\\u{1F910}\\u{1F92E}\\u{1F3BC}\\u{1F975}\\u{1F6A9}\\u{1F34E}\\u{1F34A}\\u{1F47C}\\u{1F48D}\\u{1F4E3}\\u{1F942}\"),\n  Rs = ce.reduce((s, e, t) => (s[t] = e, s), []),\n  Ts = ce.reduce((s, e, t) => (s[e.codePointAt(0)] = t, s), []);\nfunction zs(s) {\n  return s.reduce((e, t) => (e += Rs[t], e), \"\");\n}\nfunction Ps(s) {\n  const e = [];\n  for (const t of s) {\n    const i = Ts[t.codePointAt(0)];\n    if (i === void 0) throw new Error(`Non-base256emoji character: ${t}`);\n    e.push(i);\n  }\n  return new Uint8Array(e);\n}\nconst xs = K({\n  prefix: \"\\u{1F680}\",\n  name: \"base256emoji\",\n  encode: zs,\n  decode: Ps\n});\nvar Ls = Object.freeze({\n    __proto__: null,\n    base256emoji: xs\n  }),\n  Fs = De,\n  le = 128,\n  Us = 127,\n  Ns = ~Us,\n  Bs = Math.pow(2, 31);\nfunction De(s, e, t) {\n  e = e || [], t = t || 0;\n  for (var i = t; s >= Bs;) e[t++] = s & 255 | le, s /= 128;\n  for (; s & Ns;) e[t++] = s & 255 | le, s >>>= 7;\n  return e[t] = s | 0, De.bytes = t - i + 1, e;\n}\nvar Ms = J,\n  Ks = 128,\n  de = 127;\nfunction J(s, i) {\n  var t = 0,\n    i = i || 0,\n    r = 0,\n    n = i,\n    a,\n    o = s.length;\n  do {\n    if (n >= o) throw J.bytes = 0, new RangeError(\"Could not decode varint\");\n    a = s[n++], t += r < 28 ? (a & de) << r : (a & de) * Math.pow(2, r), r += 7;\n  } while (a >= Ks);\n  return J.bytes = n - i, t;\n}\nvar ks = Math.pow(2, 7),\n  $s = Math.pow(2, 14),\n  js = Math.pow(2, 21),\n  Ys = Math.pow(2, 28),\n  Vs = Math.pow(2, 35),\n  Gs = Math.pow(2, 42),\n  qs = Math.pow(2, 49),\n  Js = Math.pow(2, 56),\n  Ws = Math.pow(2, 63),\n  Xs = function (s) {\n    return s < ks ? 1 : s < $s ? 2 : s < js ? 3 : s < Ys ? 4 : s < Vs ? 5 : s < Gs ? 6 : s < qs ? 7 : s < Js ? 8 : s < Ws ? 9 : 10;\n  },\n  Hs = {\n    encode: Fs,\n    decode: Ms,\n    encodingLength: Xs\n  },\n  ge = Hs;\nconst pe = (s, e, t = 0) => (ge.encode(s, e, t), e),\n  be = s => ge.encodingLength(s),\n  W = (s, e) => {\n    const t = e.byteLength,\n      i = be(s),\n      r = i + be(t),\n      n = new Uint8Array(r + t);\n    return pe(s, n, 0), pe(t, n, i), n.set(e, r), new Zs(s, t, e, n);\n  };\nclass Zs {\n  constructor(e, t, i, r) {\n    this.code = e, this.size = t, this.digest = i, this.bytes = r;\n  }\n}\nconst fe = ({\n  name: s,\n  code: e,\n  encode: t\n}) => new Qs(s, e, t);\nclass Qs {\n  constructor(e, t, i) {\n    this.name = e, this.code = t, this.encode = i;\n  }\n  digest(e) {\n    if (e instanceof Uint8Array) {\n      const t = this.encode(e);\n      return t instanceof Uint8Array ? W(this.code, t) : t.then(i => W(this.code, i));\n    } else throw Error(\"Unknown type, must be binary type\");\n  }\n}\nconst ye = s => async e => new Uint8Array(await crypto.subtle.digest(s, e)),\n  ei = fe({\n    name: \"sha2-256\",\n    code: 18,\n    encode: ye(\"SHA-256\")\n  }),\n  ti = fe({\n    name: \"sha2-512\",\n    code: 19,\n    encode: ye(\"SHA-512\")\n  });\nvar si = Object.freeze({\n  __proto__: null,\n  sha256: ei,\n  sha512: ti\n});\nconst me = 0,\n  ii = \"identity\",\n  Ee = ue,\n  ri = s => W(me, Ee(s)),\n  ni = {\n    code: me,\n    name: ii,\n    encode: Ee,\n    digest: ri\n  };\nvar ai = Object.freeze({\n  __proto__: null,\n  identity: ni\n});\nnew TextEncoder(), new TextDecoder();\nconst ve = {\n  ...Zt,\n  ...es,\n  ...ss,\n  ...rs,\n  ...os,\n  ...fs,\n  ...Es,\n  ...Cs,\n  ...Os,\n  ...Ls\n};\n({\n  ...si,\n  ...ai\n});\nfunction oi(s = 0) {\n  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? globalThis.Buffer.allocUnsafe(s) : new Uint8Array(s);\n}\nfunction we(s, e, t, i) {\n  return {\n    name: s,\n    prefix: e,\n    encoder: {\n      name: s,\n      prefix: e,\n      encode: t\n    },\n    decoder: {\n      decode: i\n    }\n  };\n}\nconst Ce = we(\"utf8\", \"u\", s => {\n    const e = new TextDecoder(\"utf8\");\n    return \"u\" + e.decode(s);\n  }, s => new TextEncoder().encode(s.substring(1))),\n  X = we(\"ascii\", \"a\", s => {\n    let e = \"a\";\n    for (let t = 0; t < s.length; t++) e += String.fromCharCode(s[t]);\n    return e;\n  }, s => {\n    s = s.substring(1);\n    const e = oi(s.length);\n    for (let t = 0; t < s.length; t++) e[t] = s.charCodeAt(t);\n    return e;\n  }),\n  ui = {\n    utf8: Ce,\n    \"utf-8\": Ce,\n    hex: ve.base16,\n    latin1: X,\n    ascii: X,\n    binary: X,\n    ...ve\n  };\nfunction hi(s, e = \"utf8\") {\n  const t = ui[e];\n  if (!t) throw new Error(`Unsupported encoding \"${e}\"`);\n  return (e === \"utf8\" || e === \"utf-8\") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(s, \"utf8\") : t.decoder.decode(`${t.prefix}${s}`);\n}\nconst H = \"wc\",\n  _e = 2,\n  k = \"core\",\n  z = `${H}@${2}:${k}:`,\n  Se = {\n    name: k,\n    logger: \"error\"\n  },\n  Ie = {\n    database: \":memory:\"\n  },\n  Ae = \"crypto\",\n  Z = \"client_ed25519_seed\",\n  Oe = At,\n  Re = \"keychain\",\n  Te = \"0.3\",\n  ze = \"messages\",\n  Pe = \"0.3\",\n  xe = Ot,\n  Le = \"publisher\",\n  ci = \"irn\",\n  Fe = \"error\",\n  Ue = \"wss://relay.walletconnect.com\",\n  Ne = \"relayer\",\n  L = {\n    message: \"relayer_message\",\n    connect: \"relayer_connect\",\n    disconnect: \"relayer_disconnect\",\n    error: \"relayer_error\"\n  },\n  Be = \"_subscription\",\n  T = {\n    payload: \"payload\",\n    connect: \"connect\",\n    disconnect: \"disconnect\",\n    error: \"error\"\n  },\n  Me = Rt,\n  li = {\n    database: \":memory:\"\n  },\n  Ke = \"2.0.0-rc.1\",\n  ke = \"0.3\",\n  O = {\n    created: \"subscription_created\",\n    deleted: \"subscription_deleted\",\n    expired: \"subscription_expired\",\n    disabled: \"subscription_disabled\",\n    sync: \"subscription_sync\"\n  },\n  Di = Tt,\n  $e = \"subscription\",\n  je = \"0.3\",\n  Ye = zt * 1e3;\nclass Ve {\n  constructor(e, t) {\n    this.core = e, this.logger = t, this.keychain = new Map(), this.name = Re, this.version = Te, this.initialized = !1, this.storagePrefix = z, this.init = async () => {\n      if (!this.initialized) {\n        const i = await this.getKeyChain();\n        typeof i < \"u\" && (this.keychain = i), this.initialized = !0;\n      }\n    }, this.has = i => (this.isInitialized(), this.keychain.has(i)), this.set = async (i, r) => {\n      this.isInitialized(), this.keychain.set(i, r), await this.persist();\n    }, this.get = i => {\n      this.isInitialized();\n      const r = this.keychain.get(i);\n      if (typeof r > \"u\") {\n        const {\n          message: n\n        } = m(\"NO_MATCHING_KEY\", `${this.name}: ${i}`);\n        throw new Error(n);\n      }\n      return r;\n    }, this.del = async i => {\n      this.isInitialized(), this.keychain.delete(i), await this.persist();\n    }, this.core = e, this.logger = I(t, this.name);\n  }\n  get context() {\n    return A(this.logger);\n  }\n  get storageKey() {\n    return this.storagePrefix + this.version + \"//\" + this.name;\n  }\n  async setKeyChain(e) {\n    await this.core.storage.setItem(this.storageKey, ie(e));\n  }\n  async getKeyChain() {\n    const e = await this.core.storage.getItem(this.storageKey);\n    return typeof e < \"u\" ? re(e) : void 0;\n  }\n  async persist() {\n    await this.setKeyChain(this.keychain);\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const {\n        message: e\n      } = m(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n}\nclass Ge {\n  constructor(e, t, i) {\n    this.core = e, this.logger = t, this.name = Ae, this.initialized = !1, this.init = async () => {\n      this.initialized || (await this.keychain.init(), this.initialized = !0);\n    }, this.hasKeys = r => (this.isInitialized(), this.keychain.has(r)), this.getClientId = async () => {\n      this.isInitialized();\n      const r = await this.getClientSeed(),\n        n = N.generateKeyPair(r);\n      return N.encodeIss(n.publicKey);\n    }, this.generateKeyPair = () => {\n      this.isInitialized();\n      const r = bt();\n      return this.setPrivateKey(r.publicKey, r.privateKey);\n    }, this.signJWT = async r => {\n      this.isInitialized();\n      const n = await this.getClientSeed(),\n        a = N.generateKeyPair(n),\n        o = ne(),\n        u = Oe;\n      return await N.signJWT(o, r, u, a);\n    }, this.generateSharedKey = (r, n, a) => {\n      this.isInitialized();\n      const o = this.getPrivateKey(r),\n        u = ft(o, n);\n      return this.setSymKey(u, a);\n    }, this.setSymKey = async (r, n) => {\n      this.isInitialized();\n      const a = n || yt(r);\n      return await this.keychain.set(a, r), a;\n    }, this.deleteKeyPair = async r => {\n      this.isInitialized(), await this.keychain.del(r);\n    }, this.deleteSymKey = async r => {\n      this.isInitialized(), await this.keychain.del(r);\n    }, this.encode = async (r, n, a) => {\n      this.isInitialized();\n      const o = mt(a),\n        u = gt(n);\n      if (ae(o)) {\n        const F = o.senderPublicKey,\n          Y = o.receiverPublicKey;\n        r = await this.generateSharedKey(F, Y);\n      }\n      const p = this.getSymKey(r),\n        {\n          type: c,\n          senderPublicKey: l\n        } = o;\n      return Et({\n        type: c,\n        symKey: p,\n        message: u,\n        senderPublicKey: l\n      });\n    }, this.decode = async (r, n, a) => {\n      this.isInitialized();\n      const o = vt(n, a);\n      if (ae(o)) {\n        const c = o.receiverPublicKey,\n          l = o.senderPublicKey;\n        r = await this.generateSharedKey(c, l);\n      }\n      const u = this.getSymKey(r),\n        p = wt({\n          symKey: u,\n          encoded: n\n        });\n      return pt(p);\n    }, this.core = e, this.logger = I(t, this.name), this.keychain = i || new Ve(this.core, this.logger);\n  }\n  get context() {\n    return A(this.logger);\n  }\n  async setPrivateKey(e, t) {\n    return await this.keychain.set(e, t), e;\n  }\n  getPrivateKey(e) {\n    return this.keychain.get(e);\n  }\n  async getClientSeed() {\n    let e = \"\";\n    try {\n      e = this.keychain.get(Z);\n    } catch {\n      e = ne(), await this.keychain.set(Z, e);\n    }\n    return hi(e, \"base16\");\n  }\n  getSymKey(e) {\n    return this.keychain.get(e);\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const {\n        message: e\n      } = m(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n}\nclass qe extends ut {\n  constructor(e, t) {\n    super(e, t), this.logger = e, this.core = t, this.messages = new Map(), this.name = ze, this.version = Pe, this.initialized = !1, this.storagePrefix = z, this.init = async () => {\n      if (!this.initialized) {\n        this.logger.trace(\"Initialized\");\n        try {\n          const i = await this.getRelayerMessages();\n          typeof i < \"u\" && (this.messages = i), this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({\n            type: \"method\",\n            method: \"restore\",\n            size: this.messages.size\n          });\n        } catch (i) {\n          this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(i);\n        } finally {\n          this.initialized = !0;\n        }\n      }\n    }, this.set = async (i, r) => {\n      this.isInitialized();\n      const n = B(r);\n      let a = this.messages.get(i);\n      return typeof a > \"u\" && (a = {}), typeof a[n] < \"u\" || (a[n] = r, this.messages.set(i, a), await this.persist()), n;\n    }, this.get = i => {\n      this.isInitialized();\n      let r = this.messages.get(i);\n      return typeof r > \"u\" && (r = {}), r;\n    }, this.has = (i, r) => {\n      this.isInitialized();\n      const n = this.get(i),\n        a = B(r);\n      return typeof n[a] < \"u\";\n    }, this.del = async i => {\n      this.isInitialized(), this.messages.delete(i), await this.persist();\n    }, this.logger = I(e, this.name), this.core = t;\n  }\n  get context() {\n    return A(this.logger);\n  }\n  get storageKey() {\n    return this.storagePrefix + this.version + \"//\" + this.name;\n  }\n  async setRelayerMessages(e) {\n    await this.core.storage.setItem(this.storageKey, ie(e));\n  }\n  async getRelayerMessages() {\n    const e = await this.core.storage.getItem(this.storageKey);\n    return typeof e < \"u\" ? re(e) : void 0;\n  }\n  async persist() {\n    await this.setRelayerMessages(this.messages);\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const {\n        message: e\n      } = m(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n}\nclass di extends ht {\n  constructor(e, t) {\n    super(e, t), this.relayer = e, this.logger = t, this.events = new M.EventEmitter(), this.name = Le, this.queue = new Map(), this.publish = async (i, r, n) => {\n      this.logger.debug(\"Publishing Payload\"), this.logger.trace({\n        type: \"method\",\n        method: \"publish\",\n        params: {\n          topic: i,\n          message: r,\n          opts: n\n        }\n      });\n      try {\n        const a = n?.ttl || xe,\n          o = V(n),\n          u = n?.prompt || !1,\n          p = n?.tag || 0,\n          c = {\n            topic: i,\n            message: r,\n            opts: {\n              ttl: a,\n              relay: o,\n              prompt: u,\n              tag: p\n            }\n          },\n          l = B(r);\n        this.queue.set(l, c), await this.rpcPublish(i, r, a, o, u, p), this.onPublish(l, c), this.logger.debug(\"Successfully Published Payload\"), this.logger.trace({\n          type: \"method\",\n          method: \"publish\",\n          params: {\n            topic: i,\n            message: r,\n            opts: n\n          }\n        });\n      } catch (a) {\n        throw this.logger.debug(\"Failed to Publish Payload\"), this.logger.error(a), a;\n      }\n    }, this.on = (i, r) => {\n      this.events.on(i, r);\n    }, this.once = (i, r) => {\n      this.events.once(i, r);\n    }, this.off = (i, r) => {\n      this.events.off(i, r);\n    }, this.removeListener = (i, r) => {\n      this.events.removeListener(i, r);\n    }, this.relayer = e, this.logger = I(t, this.name), this.registerEventListeners();\n  }\n  get context() {\n    return A(this.logger);\n  }\n  rpcPublish(e, t, i, r, n, a) {\n    var o, u, p, c;\n    const l = {\n      method: G(r.protocol).publish,\n      params: {\n        topic: e,\n        message: t,\n        ttl: i,\n        prompt: n,\n        tag: a\n      }\n    };\n    return q((o = l.params) == null ? void 0 : o.prompt) && ((u = l.params) == null || delete u.prompt), q((p = l.params) == null ? void 0 : p.tag) && ((c = l.params) == null || delete c.tag), this.logger.debug(\"Outgoing Relay Payload\"), this.logger.trace({\n      type: \"message\",\n      direction: \"outgoing\",\n      request: l\n    }), this.relayer.provider.request(l);\n  }\n  onPublish(e, t) {\n    this.queue.delete(e);\n  }\n  checkQueue() {\n    this.queue.forEach(async e => {\n      const {\n          topic: t,\n          message: i,\n          opts: {\n            ttl: r,\n            relay: n,\n            prompt: a,\n            tag: o\n          }\n        } = e,\n        u = B(i);\n      await this.rpcPublish(t, i, r, n, a, o), this.onPublish(u, e);\n    });\n  }\n  registerEventListeners() {\n    this.relayer.core.heartbeat.on(te.pulse, () => {\n      this.checkQueue();\n    });\n  }\n}\nclass gi {\n  constructor() {\n    this.map = new Map(), this.set = (e, t) => {\n      const i = this.get(e);\n      this.exists(e, t) || this.map.set(e, [...i, t]);\n    }, this.get = e => this.map.get(e) || [], this.exists = (e, t) => this.get(e).includes(t), this.delete = (e, t) => {\n      if (typeof t > \"u\") {\n        this.map.delete(e);\n        return;\n      }\n      if (!this.map.has(e)) return;\n      const i = this.get(e);\n      if (!this.exists(e, t)) return;\n      const r = i.filter(n => n !== t);\n      if (!r.length) {\n        this.map.delete(e);\n        return;\n      }\n      this.map.set(e, r);\n    }, this.clear = () => {\n      this.map.clear();\n    };\n  }\n  get topics() {\n    return Array.from(this.map.keys());\n  }\n}\nvar pi = Object.defineProperty,\n  bi = Object.defineProperties,\n  fi = Object.getOwnPropertyDescriptors,\n  Je = Object.getOwnPropertySymbols,\n  yi = Object.prototype.hasOwnProperty,\n  mi = Object.prototype.propertyIsEnumerable,\n  We = (s, e, t) => e in s ? pi(s, e, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: t\n  }) : s[e] = t,\n  $ = (s, e) => {\n    for (var t in e || (e = {})) yi.call(e, t) && We(s, t, e[t]);\n    if (Je) for (var t of Je(e)) mi.call(e, t) && We(s, t, e[t]);\n    return s;\n  },\n  Q = (s, e) => bi(s, fi(e));\nclass Xe extends ct {\n  constructor(e, t) {\n    super(e, t), this.relayer = e, this.logger = t, this.subscriptions = new Map(), this.topicMap = new gi(), this.events = new M.EventEmitter(), this.name = $e, this.version = je, this.pending = new Map(), this.cached = [], this.initialized = !1, this.pendingSubscriptionWatchLabel = \"pending_sub_watch_label\", this.pendingSubInterval = 20, this.storagePrefix = z, this.init = async () => {\n      this.initialized || (this.logger.trace(\"Initialized\"), await this.restore(), await this.reset(), this.registerEventListeners(), this.onEnable());\n    }, this.subscribe = async (i, r) => {\n      this.isInitialized(), this.logger.debug(\"Subscribing Topic\"), this.logger.trace({\n        type: \"method\",\n        method: \"subscribe\",\n        params: {\n          topic: i,\n          opts: r\n        }\n      });\n      try {\n        const n = V(r),\n          a = {\n            topic: i,\n            relay: n\n          };\n        this.pending.set(i, a);\n        const o = await this.rpcSubscribe(i, n);\n        return this.onSubscribe(o, a), this.logger.debug(\"Successfully Subscribed Topic\"), this.logger.trace({\n          type: \"method\",\n          method: \"subscribe\",\n          params: {\n            topic: i,\n            opts: r\n          }\n        }), o;\n      } catch (n) {\n        throw this.logger.debug(\"Failed to Subscribe Topic\"), this.logger.error(n), n;\n      }\n    }, this.unsubscribe = async (i, r) => {\n      this.isInitialized(), typeof r?.id < \"u\" ? await this.unsubscribeById(i, r.id, r) : await this.unsubscribeByTopic(i, r);\n    }, this.isSubscribed = async i => this.topics.includes(i) ? !0 : await new Promise((r, n) => {\n      const a = new Pt();\n      a.start(this.pendingSubscriptionWatchLabel);\n      const o = setInterval(() => {\n        !this.pending.has(i) && this.topics.includes(i) && (clearInterval(o), a.stop(this.pendingSubscriptionWatchLabel), r(!0)), a.elapsed(this.pendingSubscriptionWatchLabel) >= Ye && (clearInterval(o), a.stop(this.pendingSubscriptionWatchLabel), n(!1));\n      }, this.pendingSubInterval);\n    }), this.on = (i, r) => {\n      this.events.on(i, r);\n    }, this.once = (i, r) => {\n      this.events.once(i, r);\n    }, this.off = (i, r) => {\n      this.events.off(i, r);\n    }, this.removeListener = (i, r) => {\n      this.events.removeListener(i, r);\n    }, this.relayer = e, this.logger = I(t, this.name);\n  }\n  get context() {\n    return A(this.logger);\n  }\n  get storageKey() {\n    return this.storagePrefix + this.version + \"//\" + this.name;\n  }\n  get length() {\n    return this.subscriptions.size;\n  }\n  get ids() {\n    return Array.from(this.subscriptions.keys());\n  }\n  get values() {\n    return Array.from(this.subscriptions.values());\n  }\n  get topics() {\n    return this.topicMap.topics;\n  }\n  hasSubscription(e, t) {\n    let i = !1;\n    try {\n      i = this.getSubscription(e).topic === t;\n    } catch {}\n    return i;\n  }\n  onEnable() {\n    this.cached = [], this.initialized = !0;\n  }\n  onDisable() {\n    this.cached = this.values, this.subscriptions.clear(), this.topicMap.clear(), this.initialized = !1;\n  }\n  async unsubscribeByTopic(e, t) {\n    const i = this.topicMap.get(e);\n    await Promise.all(i.map(async r => await this.unsubscribeById(e, r, t)));\n  }\n  async unsubscribeById(e, t, i) {\n    this.logger.debug(\"Unsubscribing Topic\"), this.logger.trace({\n      type: \"method\",\n      method: \"unsubscribe\",\n      params: {\n        topic: e,\n        id: t,\n        opts: i\n      }\n    });\n    try {\n      const r = V(i);\n      await this.rpcUnsubscribe(e, t, r);\n      const n = Ct(\"USER_DISCONNECTED\", `${this.name}, ${e}`);\n      await this.onUnsubscribe(e, t, n), this.logger.debug(\"Successfully Unsubscribed Topic\"), this.logger.trace({\n        type: \"method\",\n        method: \"unsubscribe\",\n        params: {\n          topic: e,\n          id: t,\n          opts: i\n        }\n      });\n    } catch (r) {\n      throw this.logger.debug(\"Failed to Unsubscribe Topic\"), this.logger.error(r), r;\n    }\n  }\n  async rpcSubscribe(e, t) {\n    const i = {\n      method: G(t.protocol).subscribe,\n      params: {\n        topic: e\n      }\n    };\n    return this.logger.debug(\"Outgoing Relay Payload\"), this.logger.trace({\n      type: \"payload\",\n      direction: \"outgoing\",\n      request: i\n    }), await this.relayer.provider.request(i);\n  }\n  rpcUnsubscribe(e, t, i) {\n    const r = {\n      method: G(i.protocol).unsubscribe,\n      params: {\n        topic: e,\n        id: t\n      }\n    };\n    return this.logger.debug(\"Outgoing Relay Payload\"), this.logger.trace({\n      type: \"payload\",\n      direction: \"outgoing\",\n      request: r\n    }), this.relayer.provider.request(r);\n  }\n  onSubscribe(e, t) {\n    this.setSubscription(e, Q($({}, t), {\n      id: e\n    })), this.pending.delete(t.topic);\n  }\n  onResubscribe(e, t) {\n    this.addSubscription(e, Q($({}, t), {\n      id: e\n    })), this.pending.delete(t.topic);\n  }\n  async onUnsubscribe(e, t, i) {\n    this.events.removeAllListeners(t), this.hasSubscription(t, e) && this.deleteSubscription(t, i), await this.relayer.messages.del(e);\n  }\n  async setRelayerSubscriptions(e) {\n    await this.relayer.core.storage.setItem(this.storageKey, e);\n  }\n  async getRelayerSubscriptions() {\n    return await this.relayer.core.storage.getItem(this.storageKey);\n  }\n  setSubscription(e, t) {\n    this.subscriptions.has(e) || (this.logger.debug(\"Setting subscription\"), this.logger.trace({\n      type: \"method\",\n      method: \"setSubscription\",\n      id: e,\n      subscription: t\n    }), this.addSubscription(e, t));\n  }\n  addSubscription(e, t) {\n    this.subscriptions.set(e, $({}, t)), this.topicMap.set(t.topic, e), this.events.emit(O.created, t);\n  }\n  getSubscription(e) {\n    this.logger.debug(\"Getting subscription\"), this.logger.trace({\n      type: \"method\",\n      method: \"getSubscription\",\n      id: e\n    });\n    const t = this.subscriptions.get(e);\n    if (!t) {\n      const {\n        message: i\n      } = m(\"NO_MATCHING_KEY\", `${this.name}: ${e}`);\n      throw new Error(i);\n    }\n    return t;\n  }\n  deleteSubscription(e, t) {\n    this.logger.debug(\"Deleting subscription\"), this.logger.trace({\n      type: \"method\",\n      method: \"deleteSubscription\",\n      id: e,\n      reason: t\n    });\n    const i = this.getSubscription(e);\n    this.subscriptions.delete(e), this.topicMap.delete(i.topic, e), this.events.emit(O.deleted, Q($({}, i), {\n      reason: t\n    }));\n  }\n  async persist() {\n    await this.setRelayerSubscriptions(this.values), this.events.emit(O.sync);\n  }\n  async reset() {\n    !this.cached.length || (await Promise.all(this.cached.map(async e => await this.resubscribe(e))));\n  }\n  async restore() {\n    try {\n      const e = await this.getRelayerSubscriptions();\n      if (typeof e > \"u\" || !e.length) return;\n      if (this.subscriptions.size) {\n        const {\n          message: t\n        } = m(\"RESTORE_WILL_OVERRIDE\", this.name);\n        throw this.logger.error(t), new Error(t);\n      }\n      this.cached = e, this.logger.debug(`Successfully Restored subscriptions for ${this.name}`), this.logger.trace({\n        type: \"method\",\n        method: \"restore\",\n        subscriptions: this.values\n      });\n    } catch (e) {\n      this.logger.debug(`Failed to Restore subscriptions for ${this.name}`), this.logger.error(e);\n    }\n  }\n  async resubscribe(e) {\n    if (!this.ids.includes(e.id)) {\n      const {\n          topic: t,\n          relay: i\n        } = e,\n        r = {\n          topic: t,\n          relay: i\n        };\n      this.pending.set(r.topic, r);\n      const n = await this.rpcSubscribe(r.topic, r.relay);\n      this.onResubscribe(n, r);\n    }\n  }\n  async onConnect() {\n    await this.reset(), this.onEnable();\n  }\n  onDisconnect() {\n    this.onDisable();\n  }\n  checkPending() {\n    this.pending.forEach(async e => {\n      const t = await this.rpcSubscribe(e.topic, e.relay);\n      this.onSubscribe(t, e);\n    });\n  }\n  registerEventListeners() {\n    this.relayer.core.heartbeat.on(te.pulse, () => {\n      this.checkPending();\n    }), this.relayer.provider.on(T.connect, async () => {\n      await this.onConnect();\n    }), this.relayer.provider.on(T.disconnect, () => {\n      this.onDisconnect();\n    }), this.events.on(O.created, async e => {\n      const t = O.created;\n      this.logger.info(`Emitting ${t}`), this.logger.debug({\n        type: \"event\",\n        event: t,\n        data: e\n      }), await this.persist();\n    }), this.events.on(O.deleted, async e => {\n      const t = O.deleted;\n      this.logger.info(`Emitting ${t}`), this.logger.debug({\n        type: \"event\",\n        event: t,\n        data: e\n      }), await this.persist();\n    });\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const {\n        message: e\n      } = m(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n}\nvar Ei = Object.defineProperty,\n  He = Object.getOwnPropertySymbols,\n  vi = Object.prototype.hasOwnProperty,\n  wi = Object.prototype.propertyIsEnumerable,\n  Ze = (s, e, t) => e in s ? Ei(s, e, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: t\n  }) : s[e] = t,\n  Ci = (s, e) => {\n    for (var t in e || (e = {})) vi.call(e, t) && Ze(s, t, e[t]);\n    if (He) for (var t of He(e)) wi.call(e, t) && Ze(s, t, e[t]);\n    return s;\n  };\nclass Qe extends lt {\n  constructor(e) {\n    super(e), this.protocol = \"wc\", this.version = 2, this.events = new M.EventEmitter(), this.name = Ne, this.initialized = !1, this.core = e.core, this.logger = typeof e.logger < \"u\" && typeof e.logger != \"string\" ? I(e.logger, this.name) : ee(se({\n      level: e.logger || Fe\n    })), this.messages = new qe(this.logger, e.core), this.subscriber = new Xe(this, this.logger), this.publisher = new di(this, this.logger), this.relayUrl = e?.relayUrl || Ue, this.projectId = e.projectId, this.provider = {};\n  }\n  async init() {\n    this.logger.trace(\"Initialized\");\n    const e = await this.core.crypto.signJWT(this.relayUrl);\n    this.provider = this.createProvider(e), await Promise.all([this.messages.init(), this.provider.connect(), this.subscriber.init()]), this.registerEventListeners(), this.initialized = !0;\n  }\n  get context() {\n    return A(this.logger);\n  }\n  get connected() {\n    return this.provider.connection.connected;\n  }\n  get connecting() {\n    return this.provider.connection.connecting;\n  }\n  async publish(e, t, i) {\n    this.isInitialized(), await this.publisher.publish(e, t, i), await this.recordMessageEvent({\n      topic: e,\n      message: t\n    });\n  }\n  async subscribe(e, t) {\n    return this.isInitialized(), await this.subscriber.subscribe(e, t);\n  }\n  async unsubscribe(e, t) {\n    this.isInitialized(), await this.subscriber.unsubscribe(e, t);\n  }\n  on(e, t) {\n    this.events.on(e, t);\n  }\n  once(e, t) {\n    this.events.once(e, t);\n  }\n  off(e, t) {\n    this.events.off(e, t);\n  }\n  removeListener(e, t) {\n    this.events.removeListener(e, t);\n  }\n  createProvider(e) {\n    return new Lt(new Nt(_t({\n      sdkVersion: Ke,\n      protocol: this.protocol,\n      version: this.version,\n      relayUrl: this.relayUrl,\n      projectId: this.projectId,\n      auth: e\n    })));\n  }\n  async recordMessageEvent(e) {\n    const {\n      topic: t,\n      message: i\n    } = e;\n    await this.messages.set(t, i);\n  }\n  async shouldIgnoreMessageEvent(e) {\n    const {\n      topic: t,\n      message: i\n    } = e;\n    return (await this.subscriber.isSubscribed(t)) ? this.messages.has(t, i) : !0;\n  }\n  async onProviderPayload(e) {\n    if (this.logger.debug(\"Incoming Relay Payload\"), this.logger.trace({\n      type: \"payload\",\n      direction: \"incoming\",\n      payload: e\n    }), Ft(e)) {\n      if (!e.method.endsWith(Be)) return;\n      const t = e.params,\n        {\n          topic: i,\n          message: r\n        } = t.data,\n        n = {\n          topic: i,\n          message: r\n        };\n      this.logger.debug(\"Emitting Relayer Payload\"), this.logger.trace(Ci({\n        type: \"event\",\n        event: t.id\n      }, n)), this.events.emit(t.id, n), await this.acknowledgePayload(e), await this.onMessageEvent(n);\n    }\n  }\n  async onMessageEvent(e) {\n    (await this.shouldIgnoreMessageEvent(e)) || (this.events.emit(L.message, e), await this.recordMessageEvent(e));\n  }\n  async acknowledgePayload(e) {\n    const t = Ut(e.id, !0);\n    await this.provider.connection.send(t);\n  }\n  registerEventListeners() {\n    this.provider.on(T.payload, e => this.onProviderPayload(e)), this.provider.on(T.connect, () => {\n      this.events.emit(L.connect);\n    }), this.provider.on(T.disconnect, () => {\n      this.events.emit(L.disconnect), setTimeout(() => {\n        this.provider.connect();\n      }, xt(Me));\n    }), this.provider.on(T.error, e => this.events.emit(L.error, e));\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const {\n        message: e\n      } = m(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n}\nvar _i = Object.defineProperty,\n  et = Object.getOwnPropertySymbols,\n  Si = Object.prototype.hasOwnProperty,\n  Ii = Object.prototype.propertyIsEnumerable,\n  tt = (s, e, t) => e in s ? _i(s, e, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: t\n  }) : s[e] = t,\n  st = (s, e) => {\n    for (var t in e || (e = {})) Si.call(e, t) && tt(s, t, e[t]);\n    if (et) for (var t of et(e)) Ii.call(e, t) && tt(s, t, e[t]);\n    return s;\n  };\nclass Ai extends Dt {\n  constructor(e, t, i, r = z, n = void 0) {\n    super(e, t, i, r), this.core = e, this.logger = t, this.name = i, this.map = new Map(), this.version = ke, this.cached = [], this.initialized = !1, this.storagePrefix = z, this.init = async () => {\n      this.initialized || (this.logger.trace(\"Initialized\"), await this.restore(), this.cached.forEach(a => {\n        St(a) ? this.map.set(a.id, a) : It(a) ? this.map.set(a.topic, a) : this.getKey && a !== null && !q(a) && this.map.set(this.getKey(a), a);\n      }), this.cached = [], this.initialized = !0);\n    }, this.set = async (a, o) => {\n      this.isInitialized(), this.map.has(a) ? await this.update(a, o) : (this.logger.debug(\"Setting value\"), this.logger.trace({\n        type: \"method\",\n        method: \"set\",\n        key: a,\n        value: o\n      }), this.map.set(a, o), await this.persist());\n    }, this.get = a => (this.isInitialized(), this.logger.debug(\"Getting value\"), this.logger.trace({\n      type: \"method\",\n      method: \"get\",\n      key: a\n    }), this.getData(a)), this.getAll = a => a ? this.values.filter(o => Object.keys(a).every(u => Bt(o[u], a[u]))) : this.values, this.update = async (a, o) => {\n      this.isInitialized(), this.logger.debug(\"Updating value\"), this.logger.trace({\n        type: \"method\",\n        method: \"update\",\n        key: a,\n        update: o\n      });\n      const u = st(st({}, this.getData(a)), o);\n      this.map.set(a, u), await this.persist();\n    }, this.delete = async (a, o) => {\n      this.isInitialized(), this.map.has(a) && (this.logger.debug(\"Deleting value\"), this.logger.trace({\n        type: \"method\",\n        method: \"delete\",\n        key: a,\n        reason: o\n      }), this.map.delete(a), await this.persist());\n    }, this.logger = I(t, this.name), this.storagePrefix = r, this.getKey = n;\n  }\n  get context() {\n    return A(this.logger);\n  }\n  get storageKey() {\n    return this.storagePrefix + this.version + \"//\" + this.name;\n  }\n  get length() {\n    return this.map.size;\n  }\n  get keys() {\n    return Array.from(this.map.keys());\n  }\n  get values() {\n    return Array.from(this.map.values());\n  }\n  async setDataStore(e) {\n    await this.core.storage.setItem(this.storageKey, e);\n  }\n  async getDataStore() {\n    return await this.core.storage.getItem(this.storageKey);\n  }\n  getData(e) {\n    const t = this.map.get(e);\n    if (!t) {\n      const {\n        message: i\n      } = m(\"NO_MATCHING_KEY\", `${this.name}: ${e}`);\n      throw this.logger.error(i), new Error(i);\n    }\n    return t;\n  }\n  async persist() {\n    await this.setDataStore(this.values);\n  }\n  async restore() {\n    try {\n      const e = await this.getDataStore();\n      if (typeof e > \"u\" || !e.length) return;\n      if (this.map.size) {\n        const {\n          message: t\n        } = m(\"RESTORE_WILL_OVERRIDE\", this.name);\n        throw this.logger.error(t), new Error(t);\n      }\n      this.cached = e, this.logger.debug(`Successfully Restored value for ${this.name}`), this.logger.trace({\n        type: \"method\",\n        method: \"restore\",\n        value: this.values\n      });\n    } catch (e) {\n      this.logger.debug(`Failed to Restore value for ${this.name}`), this.logger.error(e);\n    }\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const {\n        message: e\n      } = m(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n}\nvar Oi = Object.defineProperty,\n  it = Object.getOwnPropertySymbols,\n  Ri = Object.prototype.hasOwnProperty,\n  Ti = Object.prototype.propertyIsEnumerable,\n  rt = (s, e, t) => e in s ? Oi(s, e, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: t\n  }) : s[e] = t,\n  nt = (s, e) => {\n    for (var t in e || (e = {})) Ri.call(e, t) && rt(s, t, e[t]);\n    if (it) for (var t of it(e)) Ti.call(e, t) && rt(s, t, e[t]);\n    return s;\n  };\nclass j extends dt {\n  constructor(e) {\n    super(e), this.protocol = H, this.version = _e, this.name = k, this.events = new M.EventEmitter(), this.initialized = !1, this.on = (i, r) => this.events.on(i, r), this.once = (i, r) => this.events.once(i, r), this.off = (i, r) => this.events.off(i, r), this.removeListener = (i, r) => this.events.removeListener(i, r), this.projectId = e?.projectId;\n    const t = typeof e?.logger < \"u\" && typeof e?.logger != \"string\" ? e.logger : ee(se({\n      level: e?.logger || Se.logger\n    }));\n    this.logger = I(t, this.name), this.heartbeat = new ot(), this.crypto = new Ge(this, this.logger, e?.keychain), this.storage = e != null && e.storage ? e.storage : new at(nt(nt({}, Ie), e?.storageOptions)), this.relayer = new Qe({\n      core: this,\n      logger: this.logger,\n      relayUrl: e?.relayUrl,\n      projectId: this.projectId\n    });\n  }\n  static async init(e) {\n    const t = new j(e);\n    return await t.initialize(), t;\n  }\n  get context() {\n    return A(this.logger);\n  }\n  async start() {\n    this.initialized || (await this.initialize());\n  }\n  async initialize() {\n    this.logger.trace(\"Initialized\");\n    try {\n      await this.crypto.init(), await this.relayer.init(), await this.heartbeat.init(), this.initialized = !0, this.logger.info(\"Core Initilization Success\");\n    } catch (e) {\n      throw this.logger.info(\"Core Initilization Failure\"), this.logger.error(e.message), e;\n    }\n  }\n}\nconst zi = j;\nexport { k as CORE_CONTEXT, Se as CORE_DEFAULT, H as CORE_PROTOCOL, Ie as CORE_STORAGE_OPTIONS, z as CORE_STORAGE_PREFIX, _e as CORE_VERSION, Z as CRYPTO_CLIENT_SEED, Ae as CRYPTO_CONTEXT, Oe as CRYPTO_JWT_TTL, zi as Core, Ge as Crypto, Re as KEYCHAIN_CONTEXT, Te as KEYCHAIN_STORAGE_VERSION, Ve as KeyChain, ze as MESSAGES_CONTEXT, Pe as MESSAGES_STORAGE_VERSION, qe as MessageTracker, Ye as PENDING_SUB_RESOLUTION_TIMEOUT, Le as PUBLISHER_CONTEXT, xe as PUBLISHER_DEFAULT_TTL, Ne as RELAYER_CONTEXT, Fe as RELAYER_DEFAULT_LOGGER, ci as RELAYER_DEFAULT_PROTOCOL, Ue as RELAYER_DEFAULT_RELAY_URL, L as RELAYER_EVENTS, T as RELAYER_PROVIDER_EVENTS, Me as RELAYER_RECONNECT_TIMEOUT, Ke as RELAYER_SDK_VERSION, li as RELAYER_STORAGE_OPTIONS, Be as RELAYER_SUBSCRIBER_SUFFIX, Qe as Relayer, ke as STORE_STORAGE_VERSION, $e as SUBSCRIBER_CONTEXT, Di as SUBSCRIBER_DEFAULT_TTL, O as SUBSCRIBER_EVENTS, je as SUBSCRIBER_STORAGE_VERSION, Ai as Store, Xe as Subscriber, j as default };","map":{"version":3,"names":[],"sources":["C:\\Users\\user\\Desktop\\BCEndterm\\node_modules\\node_modules\\events\\events.js","C:\\Users\\user\\Desktop\\BCEndterm\\node_modules\\node_modules\\multiformats\\esm\\vendor\\base-x.js","C:\\Users\\user\\Desktop\\BCEndterm\\node_modules\\node_modules\\multiformats\\esm\\src\\bytes.js","C:\\Users\\user\\Desktop\\BCEndterm\\node_modules\\node_modules\\multiformats\\esm\\src\\bases\\base.js","C:\\Users\\user\\Desktop\\BCEndterm\\node_modules\\node_modules\\multiformats\\esm\\src\\bases\\identity.js","C:\\Users\\user\\Desktop\\BCEndterm\\node_modules\\node_modules\\multiformats\\esm\\src\\bases\\base2.js","C:\\Users\\user\\Desktop\\BCEndterm\\node_modules\\node_modules\\multiformats\\esm\\src\\bases\\base8.js","C:\\Users\\user\\Desktop\\BCEndterm\\node_modules\\node_modules\\multiformats\\esm\\src\\bases\\base10.js","C:\\Users\\user\\Desktop\\BCEndterm\\node_modules\\node_modules\\multiformats\\esm\\src\\bases\\base16.js","C:\\Users\\user\\Desktop\\BCEndterm\\node_modules\\node_modules\\multiformats\\esm\\src\\bases\\base32.js","C:\\Users\\user\\Desktop\\BCEndterm\\node_modules\\node_modules\\multiformats\\esm\\src\\bases\\base36.js","C:\\Users\\user\\Desktop\\BCEndterm\\node_modules\\node_modules\\multiformats\\esm\\src\\bases\\base58.js","C:\\Users\\user\\Desktop\\BCEndterm\\node_modules\\node_modules\\multiformats\\esm\\src\\bases\\base64.js","C:\\Users\\user\\Desktop\\BCEndterm\\node_modules\\node_modules\\multiformats\\esm\\src\\bases\\base256emoji.js","C:\\Users\\user\\Desktop\\BCEndterm\\node_modules\\node_modules\\multiformats\\esm\\vendor\\varint.js","C:\\Users\\user\\Desktop\\BCEndterm\\node_modules\\node_modules\\multiformats\\esm\\src\\varint.js","C:\\Users\\user\\Desktop\\BCEndterm\\node_modules\\node_modules\\multiformats\\esm\\src\\hashes\\digest.js","C:\\Users\\user\\Desktop\\BCEndterm\\node_modules\\node_modules\\multiformats\\esm\\src\\hashes\\hasher.js","C:\\Users\\user\\Desktop\\BCEndterm\\node_modules\\node_modules\\multiformats\\esm\\src\\hashes\\sha2-browser.js","C:\\Users\\user\\Desktop\\BCEndterm\\node_modules\\node_modules\\multiformats\\esm\\src\\hashes\\identity.js","C:\\Users\\user\\Desktop\\BCEndterm\\node_modules\\node_modules\\multiformats\\esm\\src\\codecs\\json.js","C:\\Users\\user\\Desktop\\BCEndterm\\node_modules\\node_modules\\multiformats\\esm\\src\\basics.js","C:\\Users\\user\\Desktop\\BCEndterm\\node_modules\\node_modules\\uint8arrays\\esm\\src\\alloc.js","C:\\Users\\user\\Desktop\\BCEndterm\\node_modules\\node_modules\\uint8arrays\\esm\\src\\util\\bases.js","C:\\Users\\user\\Desktop\\BCEndterm\\node_modules\\node_modules\\uint8arrays\\esm\\src\\from-string.js","C:\\Users\\user\\Desktop\\BCEndterm\\node_modules\\@walletconnect\\core\\src\\constants\\core.ts","C:\\Users\\user\\Desktop\\BCEndterm\\node_modules\\@walletconnect\\core\\src\\constants\\crypto.ts","C:\\Users\\user\\Desktop\\BCEndterm\\node_modules\\@walletconnect\\core\\src\\constants\\keychain.ts","C:\\Users\\user\\Desktop\\BCEndterm\\node_modules\\@walletconnect\\core\\src\\constants\\messages.ts","C:\\Users\\user\\Desktop\\BCEndterm\\node_modules\\@walletconnect\\core\\src\\constants\\publisher.ts","C:\\Users\\user\\Desktop\\BCEndterm\\node_modules\\@walletconnect\\core\\src\\constants\\relayer.ts","C:\\Users\\user\\Desktop\\BCEndterm\\node_modules\\@walletconnect\\core\\src\\constants\\store.ts","C:\\Users\\user\\Desktop\\BCEndterm\\node_modules\\@walletconnect\\core\\src\\constants\\subscriber.ts","C:\\Users\\user\\Desktop\\BCEndterm\\node_modules\\@walletconnect\\core\\src\\controllers\\keychain.ts","C:\\Users\\user\\Desktop\\BCEndterm\\node_modules\\@walletconnect\\core\\src\\controllers\\crypto.ts","C:\\Users\\user\\Desktop\\BCEndterm\\node_modules\\@walletconnect\\core\\src\\controllers\\messages.ts","C:\\Users\\user\\Desktop\\BCEndterm\\node_modules\\@walletconnect\\core\\src\\controllers\\publisher.ts","C:\\Users\\user\\Desktop\\BCEndterm\\node_modules\\@walletconnect\\core\\src\\controllers\\topicmap.ts","C:\\Users\\user\\Desktop\\BCEndterm\\node_modules\\@walletconnect\\core\\src\\controllers\\subscriber.ts","C:\\Users\\user\\Desktop\\BCEndterm\\node_modules\\@walletconnect\\core\\src\\controllers\\relayer.ts","C:\\Users\\user\\Desktop\\BCEndterm\\node_modules\\@walletconnect\\core\\src\\controllers\\store.ts","C:\\Users\\user\\Desktop\\BCEndterm\\node_modules\\@walletconnect\\core\\src\\core.ts","C:\\Users\\user\\Desktop\\BCEndterm\\node_modules\\@walletconnect\\core\\src\\index.ts"],"sourcesContent":["// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction EventEmitter() {\n  this._events = this._events || {};\n  this._maxListeners = this._maxListeners || undefined;\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!isNumber(n) || n < 0 || isNaN(n))\n    throw TypeError('n must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nEventEmitter.prototype.emit = function(type) {\n  var er, handler, len, args, i, listeners;\n\n  if (!this._events)\n    this._events = {};\n\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events.error ||\n        (isObject(this._events.error) && !this._events.error.length)) {\n      er = arguments[1];\n      if (er instanceof Error) {\n        throw er; // Unhandled 'error' event\n      } else {\n        // At least give some kind of context to the user\n        var err = new Error('Uncaught, unspecified \"error\" event. (' + er + ')');\n        err.context = er;\n        throw err;\n      }\n    }\n  }\n\n  handler = this._events[type];\n\n  if (isUndefined(handler))\n    return false;\n\n  if (isFunction(handler)) {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n  } else if (isObject(handler)) {\n    args = Array.prototype.slice.call(arguments, 1);\n    listeners = handler.slice();\n    len = listeners.length;\n    for (i = 0; i < len; i++)\n      listeners[i].apply(this, args);\n  }\n\n  return true;\n};\n\nEventEmitter.prototype.addListener = function(type, listener) {\n  var m;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events)\n    this._events = {};\n\n  // To avoid recursion in the case that type === \"newListener\"! Before\n  // adding it to the listeners, first emit \"newListener\".\n  if (this._events.newListener)\n    this.emit('newListener', type,\n              isFunction(listener.listener) ?\n              listener.listener : listener);\n\n  if (!this._events[type])\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  else if (isObject(this._events[type]))\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  else\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n\n  // Check for listener leak\n  if (isObject(this._events[type]) && !this._events[type].warned) {\n    if (!isUndefined(this._maxListeners)) {\n      m = this._maxListeners;\n    } else {\n      m = EventEmitter.defaultMaxListeners;\n    }\n\n    if (m && m > 0 && this._events[type].length > m) {\n      this._events[type].warned = true;\n      console.error('(node) warning: possible EventEmitter memory ' +\n                    'leak detected. %d listeners added. ' +\n                    'Use emitter.setMaxListeners() to increase limit.',\n                    this._events[type].length);\n      if (typeof console.trace === 'function') {\n        // not supported in IE 10\n        console.trace();\n      }\n    }\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  var fired = false;\n\n  function g() {\n    this.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(this, arguments);\n    }\n  }\n\n  g.listener = listener;\n  this.on(type, g);\n\n  return this;\n};\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener = function(type, listener) {\n  var list, position, length, i;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events || !this._events[type])\n    return this;\n\n  list = this._events[type];\n  length = list.length;\n  position = -1;\n\n  if (list === listener ||\n      (isFunction(list.listener) && list.listener === listener)) {\n    delete this._events[type];\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n\n  } else if (isObject(list)) {\n    for (i = length; i-- > 0;) {\n      if (list[i] === listener ||\n          (list[i].listener && list[i].listener === listener)) {\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0)\n      return this;\n\n    if (list.length === 1) {\n      list.length = 0;\n      delete this._events[type];\n    } else {\n      list.splice(position, 1);\n    }\n\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  var key, listeners;\n\n  if (!this._events)\n    return this;\n\n  // not listening for removeListener, no need to emit\n  if (!this._events.removeListener) {\n    if (arguments.length === 0)\n      this._events = {};\n    else if (this._events[type])\n      delete this._events[type];\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    for (key in this._events) {\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = {};\n    return this;\n  }\n\n  listeners = this._events[type];\n\n  if (isFunction(listeners)) {\n    this.removeListener(type, listeners);\n  } else if (listeners) {\n    // LIFO order\n    while (listeners.length)\n      this.removeListener(type, listeners[listeners.length - 1]);\n  }\n  delete this._events[type];\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  var ret;\n  if (!this._events || !this._events[type])\n    ret = [];\n  else if (isFunction(this._events[type]))\n    ret = [this._events[type]];\n  else\n    ret = this._events[type].slice();\n  return ret;\n};\n\nEventEmitter.prototype.listenerCount = function(type) {\n  if (this._events) {\n    var evlistener = this._events[type];\n\n    if (isFunction(evlistener))\n      return 1;\n    else if (evlistener)\n      return evlistener.length;\n  }\n  return 0;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  return emitter.listenerCount(type);\n};\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\n","function base(ALPHABET, name) {\n  if (ALPHABET.length >= 255) {\n    throw new TypeError('Alphabet too long');\n  }\n  var BASE_MAP = new Uint8Array(256);\n  for (var j = 0; j < BASE_MAP.length; j++) {\n    BASE_MAP[j] = 255;\n  }\n  for (var i = 0; i < ALPHABET.length; i++) {\n    var x = ALPHABET.charAt(i);\n    var xc = x.charCodeAt(0);\n    if (BASE_MAP[xc] !== 255) {\n      throw new TypeError(x + ' is ambiguous');\n    }\n    BASE_MAP[xc] = i;\n  }\n  var BASE = ALPHABET.length;\n  var LEADER = ALPHABET.charAt(0);\n  var FACTOR = Math.log(BASE) / Math.log(256);\n  var iFACTOR = Math.log(256) / Math.log(BASE);\n  function encode(source) {\n    if (source instanceof Uint8Array);\n    else if (ArrayBuffer.isView(source)) {\n      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);\n    } else if (Array.isArray(source)) {\n      source = Uint8Array.from(source);\n    }\n    if (!(source instanceof Uint8Array)) {\n      throw new TypeError('Expected Uint8Array');\n    }\n    if (source.length === 0) {\n      return '';\n    }\n    var zeroes = 0;\n    var length = 0;\n    var pbegin = 0;\n    var pend = source.length;\n    while (pbegin !== pend && source[pbegin] === 0) {\n      pbegin++;\n      zeroes++;\n    }\n    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;\n    var b58 = new Uint8Array(size);\n    while (pbegin !== pend) {\n      var carry = source[pbegin];\n      var i = 0;\n      for (var it1 = size - 1; (carry !== 0 || i < length) && it1 !== -1; it1--, i++) {\n        carry += 256 * b58[it1] >>> 0;\n        b58[it1] = carry % BASE >>> 0;\n        carry = carry / BASE >>> 0;\n      }\n      if (carry !== 0) {\n        throw new Error('Non-zero carry');\n      }\n      length = i;\n      pbegin++;\n    }\n    var it2 = size - length;\n    while (it2 !== size && b58[it2] === 0) {\n      it2++;\n    }\n    var str = LEADER.repeat(zeroes);\n    for (; it2 < size; ++it2) {\n      str += ALPHABET.charAt(b58[it2]);\n    }\n    return str;\n  }\n  function decodeUnsafe(source) {\n    if (typeof source !== 'string') {\n      throw new TypeError('Expected String');\n    }\n    if (source.length === 0) {\n      return new Uint8Array();\n    }\n    var psz = 0;\n    if (source[psz] === ' ') {\n      return;\n    }\n    var zeroes = 0;\n    var length = 0;\n    while (source[psz] === LEADER) {\n      zeroes++;\n      psz++;\n    }\n    var size = (source.length - psz) * FACTOR + 1 >>> 0;\n    var b256 = new Uint8Array(size);\n    while (source[psz]) {\n      var carry = BASE_MAP[source.charCodeAt(psz)];\n      if (carry === 255) {\n        return;\n      }\n      var i = 0;\n      for (var it3 = size - 1; (carry !== 0 || i < length) && it3 !== -1; it3--, i++) {\n        carry += BASE * b256[it3] >>> 0;\n        b256[it3] = carry % 256 >>> 0;\n        carry = carry / 256 >>> 0;\n      }\n      if (carry !== 0) {\n        throw new Error('Non-zero carry');\n      }\n      length = i;\n      psz++;\n    }\n    if (source[psz] === ' ') {\n      return;\n    }\n    var it4 = size - length;\n    while (it4 !== size && b256[it4] === 0) {\n      it4++;\n    }\n    var vch = new Uint8Array(zeroes + (size - it4));\n    var j = zeroes;\n    while (it4 !== size) {\n      vch[j++] = b256[it4++];\n    }\n    return vch;\n  }\n  function decode(string) {\n    var buffer = decodeUnsafe(string);\n    if (buffer) {\n      return buffer;\n    }\n    throw new Error(`Non-${ name } character`);\n  }\n  return {\n    encode: encode,\n    decodeUnsafe: decodeUnsafe,\n    decode: decode\n  };\n}\nvar src = base;\nvar _brrp__multiformats_scope_baseX = src;\nexport default _brrp__multiformats_scope_baseX;","const empty = new Uint8Array(0);\nconst toHex = d => d.reduce((hex, byte) => hex + byte.toString(16).padStart(2, '0'), '');\nconst fromHex = hex => {\n  const hexes = hex.match(/../g);\n  return hexes ? new Uint8Array(hexes.map(b => parseInt(b, 16))) : empty;\n};\nconst equals = (aa, bb) => {\n  if (aa === bb)\n    return true;\n  if (aa.byteLength !== bb.byteLength) {\n    return false;\n  }\n  for (let ii = 0; ii < aa.byteLength; ii++) {\n    if (aa[ii] !== bb[ii]) {\n      return false;\n    }\n  }\n  return true;\n};\nconst coerce = o => {\n  if (o instanceof Uint8Array && o.constructor.name === 'Uint8Array')\n    return o;\n  if (o instanceof ArrayBuffer)\n    return new Uint8Array(o);\n  if (ArrayBuffer.isView(o)) {\n    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);\n  }\n  throw new Error('Unknown type, must be binary type');\n};\nconst isBinary = o => o instanceof ArrayBuffer || ArrayBuffer.isView(o);\nconst fromString = str => new TextEncoder().encode(str);\nconst toString = b => new TextDecoder().decode(b);\nexport {\n  equals,\n  coerce,\n  isBinary,\n  fromHex,\n  toHex,\n  fromString,\n  toString,\n  empty\n};","import basex from '../../vendor/base-x.js';\nimport { coerce } from '../bytes.js';\nclass Encoder {\n  constructor(name, prefix, baseEncode) {\n    this.name = name;\n    this.prefix = prefix;\n    this.baseEncode = baseEncode;\n  }\n  encode(bytes) {\n    if (bytes instanceof Uint8Array) {\n      return `${ this.prefix }${ this.baseEncode(bytes) }`;\n    } else {\n      throw Error('Unknown type, must be binary type');\n    }\n  }\n}\nclass Decoder {\n  constructor(name, prefix, baseDecode) {\n    this.name = name;\n    this.prefix = prefix;\n    if (prefix.codePointAt(0) === undefined) {\n      throw new Error('Invalid prefix character');\n    }\n    this.prefixCodePoint = prefix.codePointAt(0);\n    this.baseDecode = baseDecode;\n  }\n  decode(text) {\n    if (typeof text === 'string') {\n      if (text.codePointAt(0) !== this.prefixCodePoint) {\n        throw Error(`Unable to decode multibase string ${ JSON.stringify(text) }, ${ this.name } decoder only supports inputs prefixed with ${ this.prefix }`);\n      }\n      return this.baseDecode(text.slice(this.prefix.length));\n    } else {\n      throw Error('Can only multibase decode strings');\n    }\n  }\n  or(decoder) {\n    return or(this, decoder);\n  }\n}\nclass ComposedDecoder {\n  constructor(decoders) {\n    this.decoders = decoders;\n  }\n  or(decoder) {\n    return or(this, decoder);\n  }\n  decode(input) {\n    const prefix = input[0];\n    const decoder = this.decoders[prefix];\n    if (decoder) {\n      return decoder.decode(input);\n    } else {\n      throw RangeError(`Unable to decode multibase string ${ JSON.stringify(input) }, only inputs prefixed with ${ Object.keys(this.decoders) } are supported`);\n    }\n  }\n}\nexport const or = (left, right) => new ComposedDecoder({\n  ...left.decoders || { [left.prefix]: left },\n  ...right.decoders || { [right.prefix]: right }\n});\nexport class Codec {\n  constructor(name, prefix, baseEncode, baseDecode) {\n    this.name = name;\n    this.prefix = prefix;\n    this.baseEncode = baseEncode;\n    this.baseDecode = baseDecode;\n    this.encoder = new Encoder(name, prefix, baseEncode);\n    this.decoder = new Decoder(name, prefix, baseDecode);\n  }\n  encode(input) {\n    return this.encoder.encode(input);\n  }\n  decode(input) {\n    return this.decoder.decode(input);\n  }\n}\nexport const from = ({name, prefix, encode, decode}) => new Codec(name, prefix, encode, decode);\nexport const baseX = ({prefix, name, alphabet}) => {\n  const {encode, decode} = basex(alphabet, name);\n  return from({\n    prefix,\n    name,\n    encode,\n    decode: text => coerce(decode(text))\n  });\n};\nconst decode = (string, alphabet, bitsPerChar, name) => {\n  const codes = {};\n  for (let i = 0; i < alphabet.length; ++i) {\n    codes[alphabet[i]] = i;\n  }\n  let end = string.length;\n  while (string[end - 1] === '=') {\n    --end;\n  }\n  const out = new Uint8Array(end * bitsPerChar / 8 | 0);\n  let bits = 0;\n  let buffer = 0;\n  let written = 0;\n  for (let i = 0; i < end; ++i) {\n    const value = codes[string[i]];\n    if (value === undefined) {\n      throw new SyntaxError(`Non-${ name } character`);\n    }\n    buffer = buffer << bitsPerChar | value;\n    bits += bitsPerChar;\n    if (bits >= 8) {\n      bits -= 8;\n      out[written++] = 255 & buffer >> bits;\n    }\n  }\n  if (bits >= bitsPerChar || 255 & buffer << 8 - bits) {\n    throw new SyntaxError('Unexpected end of data');\n  }\n  return out;\n};\nconst encode = (data, alphabet, bitsPerChar) => {\n  const pad = alphabet[alphabet.length - 1] === '=';\n  const mask = (1 << bitsPerChar) - 1;\n  let out = '';\n  let bits = 0;\n  let buffer = 0;\n  for (let i = 0; i < data.length; ++i) {\n    buffer = buffer << 8 | data[i];\n    bits += 8;\n    while (bits > bitsPerChar) {\n      bits -= bitsPerChar;\n      out += alphabet[mask & buffer >> bits];\n    }\n  }\n  if (bits) {\n    out += alphabet[mask & buffer << bitsPerChar - bits];\n  }\n  if (pad) {\n    while (out.length * bitsPerChar & 7) {\n      out += '=';\n    }\n  }\n  return out;\n};\nexport const rfc4648 = ({name, prefix, bitsPerChar, alphabet}) => {\n  return from({\n    prefix,\n    name,\n    encode(input) {\n      return encode(input, alphabet, bitsPerChar);\n    },\n    decode(input) {\n      return decode(input, alphabet, bitsPerChar, name);\n    }\n  });\n};","import { from } from './base.js';\nimport {\n  fromString,\n  toString\n} from '../bytes.js';\nexport const identity = from({\n  prefix: '\\0',\n  name: 'identity',\n  encode: buf => toString(buf),\n  decode: str => fromString(str)\n});","import { rfc4648 } from './base.js';\nexport const base2 = rfc4648({\n  prefix: '0',\n  name: 'base2',\n  alphabet: '01',\n  bitsPerChar: 1\n});","import { rfc4648 } from './base.js';\nexport const base8 = rfc4648({\n  prefix: '7',\n  name: 'base8',\n  alphabet: '01234567',\n  bitsPerChar: 3\n});","import { baseX } from './base.js';\nexport const base10 = baseX({\n  prefix: '9',\n  name: 'base10',\n  alphabet: '0123456789'\n});","import { rfc4648 } from './base.js';\nexport const base16 = rfc4648({\n  prefix: 'f',\n  name: 'base16',\n  alphabet: '0123456789abcdef',\n  bitsPerChar: 4\n});\nexport const base16upper = rfc4648({\n  prefix: 'F',\n  name: 'base16upper',\n  alphabet: '0123456789ABCDEF',\n  bitsPerChar: 4\n});","import { rfc4648 } from './base.js';\nexport const base32 = rfc4648({\n  prefix: 'b',\n  name: 'base32',\n  alphabet: 'abcdefghijklmnopqrstuvwxyz234567',\n  bitsPerChar: 5\n});\nexport const base32upper = rfc4648({\n  prefix: 'B',\n  name: 'base32upper',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567',\n  bitsPerChar: 5\n});\nexport const base32pad = rfc4648({\n  prefix: 'c',\n  name: 'base32pad',\n  alphabet: 'abcdefghijklmnopqrstuvwxyz234567=',\n  bitsPerChar: 5\n});\nexport const base32padupper = rfc4648({\n  prefix: 'C',\n  name: 'base32padupper',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=',\n  bitsPerChar: 5\n});\nexport const base32hex = rfc4648({\n  prefix: 'v',\n  name: 'base32hex',\n  alphabet: '0123456789abcdefghijklmnopqrstuv',\n  bitsPerChar: 5\n});\nexport const base32hexupper = rfc4648({\n  prefix: 'V',\n  name: 'base32hexupper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV',\n  bitsPerChar: 5\n});\nexport const base32hexpad = rfc4648({\n  prefix: 't',\n  name: 'base32hexpad',\n  alphabet: '0123456789abcdefghijklmnopqrstuv=',\n  bitsPerChar: 5\n});\nexport const base32hexpadupper = rfc4648({\n  prefix: 'T',\n  name: 'base32hexpadupper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV=',\n  bitsPerChar: 5\n});\nexport const base32z = rfc4648({\n  prefix: 'h',\n  name: 'base32z',\n  alphabet: 'ybndrfg8ejkmcpqxot1uwisza345h769',\n  bitsPerChar: 5\n});","import { baseX } from './base.js';\nexport const base36 = baseX({\n  prefix: 'k',\n  name: 'base36',\n  alphabet: '0123456789abcdefghijklmnopqrstuvwxyz'\n});\nexport const base36upper = baseX({\n  prefix: 'K',\n  name: 'base36upper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n});","import { baseX } from './base.js';\nexport const base58btc = baseX({\n  name: 'base58btc',\n  prefix: 'z',\n  alphabet: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n});\nexport const base58flickr = baseX({\n  name: 'base58flickr',\n  prefix: 'Z',\n  alphabet: '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'\n});","import { rfc4648 } from './base.js';\nexport const base64 = rfc4648({\n  prefix: 'm',\n  name: 'base64',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',\n  bitsPerChar: 6\n});\nexport const base64pad = rfc4648({\n  prefix: 'M',\n  name: 'base64pad',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',\n  bitsPerChar: 6\n});\nexport const base64url = rfc4648({\n  prefix: 'u',\n  name: 'base64url',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_',\n  bitsPerChar: 6\n});\nexport const base64urlpad = rfc4648({\n  prefix: 'U',\n  name: 'base64urlpad',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=',\n  bitsPerChar: 6\n});","import { from } from './base.js';\nconst alphabet = Array.from('\\uD83D\\uDE80\\uD83E\\uDE90\\u2604\\uD83D\\uDEF0\\uD83C\\uDF0C\\uD83C\\uDF11\\uD83C\\uDF12\\uD83C\\uDF13\\uD83C\\uDF14\\uD83C\\uDF15\\uD83C\\uDF16\\uD83C\\uDF17\\uD83C\\uDF18\\uD83C\\uDF0D\\uD83C\\uDF0F\\uD83C\\uDF0E\\uD83D\\uDC09\\u2600\\uD83D\\uDCBB\\uD83D\\uDDA5\\uD83D\\uDCBE\\uD83D\\uDCBF\\uD83D\\uDE02\\u2764\\uD83D\\uDE0D\\uD83E\\uDD23\\uD83D\\uDE0A\\uD83D\\uDE4F\\uD83D\\uDC95\\uD83D\\uDE2D\\uD83D\\uDE18\\uD83D\\uDC4D\\uD83D\\uDE05\\uD83D\\uDC4F\\uD83D\\uDE01\\uD83D\\uDD25\\uD83E\\uDD70\\uD83D\\uDC94\\uD83D\\uDC96\\uD83D\\uDC99\\uD83D\\uDE22\\uD83E\\uDD14\\uD83D\\uDE06\\uD83D\\uDE44\\uD83D\\uDCAA\\uD83D\\uDE09\\u263A\\uD83D\\uDC4C\\uD83E\\uDD17\\uD83D\\uDC9C\\uD83D\\uDE14\\uD83D\\uDE0E\\uD83D\\uDE07\\uD83C\\uDF39\\uD83E\\uDD26\\uD83C\\uDF89\\uD83D\\uDC9E\\u270C\\u2728\\uD83E\\uDD37\\uD83D\\uDE31\\uD83D\\uDE0C\\uD83C\\uDF38\\uD83D\\uDE4C\\uD83D\\uDE0B\\uD83D\\uDC97\\uD83D\\uDC9A\\uD83D\\uDE0F\\uD83D\\uDC9B\\uD83D\\uDE42\\uD83D\\uDC93\\uD83E\\uDD29\\uD83D\\uDE04\\uD83D\\uDE00\\uD83D\\uDDA4\\uD83D\\uDE03\\uD83D\\uDCAF\\uD83D\\uDE48\\uD83D\\uDC47\\uD83C\\uDFB6\\uD83D\\uDE12\\uD83E\\uDD2D\\u2763\\uD83D\\uDE1C\\uD83D\\uDC8B\\uD83D\\uDC40\\uD83D\\uDE2A\\uD83D\\uDE11\\uD83D\\uDCA5\\uD83D\\uDE4B\\uD83D\\uDE1E\\uD83D\\uDE29\\uD83D\\uDE21\\uD83E\\uDD2A\\uD83D\\uDC4A\\uD83E\\uDD73\\uD83D\\uDE25\\uD83E\\uDD24\\uD83D\\uDC49\\uD83D\\uDC83\\uD83D\\uDE33\\u270B\\uD83D\\uDE1A\\uD83D\\uDE1D\\uD83D\\uDE34\\uD83C\\uDF1F\\uD83D\\uDE2C\\uD83D\\uDE43\\uD83C\\uDF40\\uD83C\\uDF37\\uD83D\\uDE3B\\uD83D\\uDE13\\u2B50\\u2705\\uD83E\\uDD7A\\uD83C\\uDF08\\uD83D\\uDE08\\uD83E\\uDD18\\uD83D\\uDCA6\\u2714\\uD83D\\uDE23\\uD83C\\uDFC3\\uD83D\\uDC90\\u2639\\uD83C\\uDF8A\\uD83D\\uDC98\\uD83D\\uDE20\\u261D\\uD83D\\uDE15\\uD83C\\uDF3A\\uD83C\\uDF82\\uD83C\\uDF3B\\uD83D\\uDE10\\uD83D\\uDD95\\uD83D\\uDC9D\\uD83D\\uDE4A\\uD83D\\uDE39\\uD83D\\uDDE3\\uD83D\\uDCAB\\uD83D\\uDC80\\uD83D\\uDC51\\uD83C\\uDFB5\\uD83E\\uDD1E\\uD83D\\uDE1B\\uD83D\\uDD34\\uD83D\\uDE24\\uD83C\\uDF3C\\uD83D\\uDE2B\\u26BD\\uD83E\\uDD19\\u2615\\uD83C\\uDFC6\\uD83E\\uDD2B\\uD83D\\uDC48\\uD83D\\uDE2E\\uD83D\\uDE46\\uD83C\\uDF7B\\uD83C\\uDF43\\uD83D\\uDC36\\uD83D\\uDC81\\uD83D\\uDE32\\uD83C\\uDF3F\\uD83E\\uDDE1\\uD83C\\uDF81\\u26A1\\uD83C\\uDF1E\\uD83C\\uDF88\\u274C\\u270A\\uD83D\\uDC4B\\uD83D\\uDE30\\uD83E\\uDD28\\uD83D\\uDE36\\uD83E\\uDD1D\\uD83D\\uDEB6\\uD83D\\uDCB0\\uD83C\\uDF53\\uD83D\\uDCA2\\uD83E\\uDD1F\\uD83D\\uDE41\\uD83D\\uDEA8\\uD83D\\uDCA8\\uD83E\\uDD2C\\u2708\\uD83C\\uDF80\\uD83C\\uDF7A\\uD83E\\uDD13\\uD83D\\uDE19\\uD83D\\uDC9F\\uD83C\\uDF31\\uD83D\\uDE16\\uD83D\\uDC76\\uD83E\\uDD74\\u25B6\\u27A1\\u2753\\uD83D\\uDC8E\\uD83D\\uDCB8\\u2B07\\uD83D\\uDE28\\uD83C\\uDF1A\\uD83E\\uDD8B\\uD83D\\uDE37\\uD83D\\uDD7A\\u26A0\\uD83D\\uDE45\\uD83D\\uDE1F\\uD83D\\uDE35\\uD83D\\uDC4E\\uD83E\\uDD32\\uD83E\\uDD20\\uD83E\\uDD27\\uD83D\\uDCCC\\uD83D\\uDD35\\uD83D\\uDC85\\uD83E\\uDDD0\\uD83D\\uDC3E\\uD83C\\uDF52\\uD83D\\uDE17\\uD83E\\uDD11\\uD83C\\uDF0A\\uD83E\\uDD2F\\uD83D\\uDC37\\u260E\\uD83D\\uDCA7\\uD83D\\uDE2F\\uD83D\\uDC86\\uD83D\\uDC46\\uD83C\\uDFA4\\uD83D\\uDE47\\uD83C\\uDF51\\u2744\\uD83C\\uDF34\\uD83D\\uDCA3\\uD83D\\uDC38\\uD83D\\uDC8C\\uD83D\\uDCCD\\uD83E\\uDD40\\uD83E\\uDD22\\uD83D\\uDC45\\uD83D\\uDCA1\\uD83D\\uDCA9\\uD83D\\uDC50\\uD83D\\uDCF8\\uD83D\\uDC7B\\uD83E\\uDD10\\uD83E\\uDD2E\\uD83C\\uDFBC\\uD83E\\uDD75\\uD83D\\uDEA9\\uD83C\\uDF4E\\uD83C\\uDF4A\\uD83D\\uDC7C\\uD83D\\uDC8D\\uD83D\\uDCE3\\uD83E\\uDD42');\nconst alphabetBytesToChars = alphabet.reduce((p, c, i) => {\n  p[i] = c;\n  return p;\n}, []);\nconst alphabetCharsToBytes = alphabet.reduce((p, c, i) => {\n  p[c.codePointAt(0)] = i;\n  return p;\n}, []);\nfunction encode(data) {\n  return data.reduce((p, c) => {\n    p += alphabetBytesToChars[c];\n    return p;\n  }, '');\n}\nfunction decode(str) {\n  const byts = [];\n  for (const char of str) {\n    const byt = alphabetCharsToBytes[char.codePointAt(0)];\n    if (byt === undefined) {\n      throw new Error(`Non-base256emoji character: ${ char }`);\n    }\n    byts.push(byt);\n  }\n  return new Uint8Array(byts);\n}\nexport const base256emoji = from({\n  prefix: '\\uD83D\\uDE80',\n  name: 'base256emoji',\n  encode,\n  decode\n});","var encode_1 = encode;\nvar MSB = 128, REST = 127, MSBALL = ~REST, INT = Math.pow(2, 31);\nfunction encode(num, out, offset) {\n  out = out || [];\n  offset = offset || 0;\n  var oldOffset = offset;\n  while (num >= INT) {\n    out[offset++] = num & 255 | MSB;\n    num /= 128;\n  }\n  while (num & MSBALL) {\n    out[offset++] = num & 255 | MSB;\n    num >>>= 7;\n  }\n  out[offset] = num | 0;\n  encode.bytes = offset - oldOffset + 1;\n  return out;\n}\nvar decode = read;\nvar MSB$1 = 128, REST$1 = 127;\nfunction read(buf, offset) {\n  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;\n  do {\n    if (counter >= l) {\n      read.bytes = 0;\n      throw new RangeError('Could not decode varint');\n    }\n    b = buf[counter++];\n    res += shift < 28 ? (b & REST$1) << shift : (b & REST$1) * Math.pow(2, shift);\n    shift += 7;\n  } while (b >= MSB$1);\n  read.bytes = counter - offset;\n  return res;\n}\nvar N1 = Math.pow(2, 7);\nvar N2 = Math.pow(2, 14);\nvar N3 = Math.pow(2, 21);\nvar N4 = Math.pow(2, 28);\nvar N5 = Math.pow(2, 35);\nvar N6 = Math.pow(2, 42);\nvar N7 = Math.pow(2, 49);\nvar N8 = Math.pow(2, 56);\nvar N9 = Math.pow(2, 63);\nvar length = function (value) {\n  return value < N1 ? 1 : value < N2 ? 2 : value < N3 ? 3 : value < N4 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;\n};\nvar varint = {\n  encode: encode_1,\n  decode: decode,\n  encodingLength: length\n};\nvar _brrp_varint = varint;\nexport default _brrp_varint;","import varint from '../vendor/varint.js';\nexport const decode = data => {\n  const code = varint.decode(data);\n  return [\n    code,\n    varint.decode.bytes\n  ];\n};\nexport const encodeTo = (int, target, offset = 0) => {\n  varint.encode(int, target, offset);\n  return target;\n};\nexport const encodingLength = int => {\n  return varint.encodingLength(int);\n};","import {\n  coerce,\n  equals as equalBytes\n} from '../bytes.js';\nimport * as varint from '../varint.js';\nexport const create = (code, digest) => {\n  const size = digest.byteLength;\n  const sizeOffset = varint.encodingLength(code);\n  const digestOffset = sizeOffset + varint.encodingLength(size);\n  const bytes = new Uint8Array(digestOffset + size);\n  varint.encodeTo(code, bytes, 0);\n  varint.encodeTo(size, bytes, sizeOffset);\n  bytes.set(digest, digestOffset);\n  return new Digest(code, size, digest, bytes);\n};\nexport const decode = multihash => {\n  const bytes = coerce(multihash);\n  const [code, sizeOffset] = varint.decode(bytes);\n  const [size, digestOffset] = varint.decode(bytes.subarray(sizeOffset));\n  const digest = bytes.subarray(sizeOffset + digestOffset);\n  if (digest.byteLength !== size) {\n    throw new Error('Incorrect length');\n  }\n  return new Digest(code, size, digest, bytes);\n};\nexport const equals = (a, b) => {\n  if (a === b) {\n    return true;\n  } else {\n    return a.code === b.code && a.size === b.size && equalBytes(a.bytes, b.bytes);\n  }\n};\nexport class Digest {\n  constructor(code, size, digest, bytes) {\n    this.code = code;\n    this.size = size;\n    this.digest = digest;\n    this.bytes = bytes;\n  }\n}","import * as Digest from './digest.js';\nexport const from = ({name, code, encode}) => new Hasher(name, code, encode);\nexport class Hasher {\n  constructor(name, code, encode) {\n    this.name = name;\n    this.code = code;\n    this.encode = encode;\n  }\n  digest(input) {\n    if (input instanceof Uint8Array) {\n      const result = this.encode(input);\n      return result instanceof Uint8Array ? Digest.create(this.code, result) : result.then(digest => Digest.create(this.code, digest));\n    } else {\n      throw Error('Unknown type, must be binary type');\n    }\n  }\n}","import { from } from './hasher.js';\nconst sha = name => async data => new Uint8Array(await crypto.subtle.digest(name, data));\nexport const sha256 = from({\n  name: 'sha2-256',\n  code: 18,\n  encode: sha('SHA-256')\n});\nexport const sha512 = from({\n  name: 'sha2-512',\n  code: 19,\n  encode: sha('SHA-512')\n});","import { coerce } from '../bytes.js';\nimport * as Digest from './digest.js';\nconst code = 0;\nconst name = 'identity';\nconst encode = coerce;\nconst digest = input => Digest.create(code, encode(input));\nexport const identity = {\n  code,\n  name,\n  encode,\n  digest\n};","const textEncoder = new TextEncoder();\nconst textDecoder = new TextDecoder();\nexport const name = 'json';\nexport const code = 512;\nexport const encode = node => textEncoder.encode(JSON.stringify(node));\nexport const decode = data => JSON.parse(textDecoder.decode(data));","import * as identityBase from './bases/identity.js';\nimport * as base2 from './bases/base2.js';\nimport * as base8 from './bases/base8.js';\nimport * as base10 from './bases/base10.js';\nimport * as base16 from './bases/base16.js';\nimport * as base32 from './bases/base32.js';\nimport * as base36 from './bases/base36.js';\nimport * as base58 from './bases/base58.js';\nimport * as base64 from './bases/base64.js';\nimport * as base256emoji from './bases/base256emoji.js';\nimport * as sha2 from './hashes/sha2.js';\nimport * as identity from './hashes/identity.js';\nimport * as raw from './codecs/raw.js';\nimport * as json from './codecs/json.js';\nimport {\n  CID,\n  hasher,\n  digest,\n  varint,\n  bytes\n} from './index.js';\nconst bases = {\n  ...identityBase,\n  ...base2,\n  ...base8,\n  ...base10,\n  ...base16,\n  ...base32,\n  ...base36,\n  ...base58,\n  ...base64,\n  ...base256emoji\n};\nconst hashes = {\n  ...sha2,\n  ...identity\n};\nconst codecs = {\n  raw,\n  json\n};\nexport {\n  CID,\n  hasher,\n  digest,\n  varint,\n  bytes,\n  hashes,\n  bases,\n  codecs\n};","export function alloc(size = 0) {\n  if (globalThis.Buffer != null && globalThis.Buffer.alloc != null) {\n    return globalThis.Buffer.alloc(size);\n  }\n  return new Uint8Array(size);\n}\nexport function allocUnsafe(size = 0) {\n  if (globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null) {\n    return globalThis.Buffer.allocUnsafe(size);\n  }\n  return new Uint8Array(size);\n}","import { bases } from 'multiformats/basics';\nimport { allocUnsafe } from '../alloc.js';\nfunction createCodec(name, prefix, encode, decode) {\n  return {\n    name,\n    prefix,\n    encoder: {\n      name,\n      prefix,\n      encode\n    },\n    decoder: { decode }\n  };\n}\nconst string = createCodec('utf8', 'u', buf => {\n  const decoder = new TextDecoder('utf8');\n  return 'u' + decoder.decode(buf);\n}, str => {\n  const encoder = new TextEncoder();\n  return encoder.encode(str.substring(1));\n});\nconst ascii = createCodec('ascii', 'a', buf => {\n  let string = 'a';\n  for (let i = 0; i < buf.length; i++) {\n    string += String.fromCharCode(buf[i]);\n  }\n  return string;\n}, str => {\n  str = str.substring(1);\n  const buf = allocUnsafe(str.length);\n  for (let i = 0; i < str.length; i++) {\n    buf[i] = str.charCodeAt(i);\n  }\n  return buf;\n});\nconst BASES = {\n  utf8: string,\n  'utf-8': string,\n  hex: bases.base16,\n  latin1: ascii,\n  ascii: ascii,\n  binary: ascii,\n  ...bases\n};\nexport default BASES;","import bases from './util/bases.js';\nexport function fromString(string, encoding = 'utf8') {\n  const base = bases[encoding];\n  if (!base) {\n    throw new Error(`Unsupported encoding \"${ encoding }\"`);\n  }\n  if ((encoding === 'utf8' || encoding === 'utf-8') && globalThis.Buffer != null && globalThis.Buffer.from != null) {\n    return globalThis.Buffer.from(string, 'utf8');\n  }\n  return base.decoder.decode(`${ base.prefix }${ string }`);\n}","export const CORE_PROTOCOL = \"wc\";\nexport const CORE_VERSION = 2;\nexport const CORE_CONTEXT = \"core\";\n\nexport const CORE_STORAGE_PREFIX = `${CORE_PROTOCOL}@${CORE_VERSION}:${CORE_CONTEXT}:`;\n\nexport const CORE_DEFAULT = {\n  name: CORE_CONTEXT,\n  logger: \"error\",\n};\n\nexport const CORE_STORAGE_OPTIONS = {\n  database: \":memory:\",\n};\n","import { ONE_DAY } from \"@walletconnect/time\";\n\nexport const CRYPTO_CONTEXT = \"crypto\";\n\nexport const CRYPTO_CLIENT_SEED = \"client_ed25519_seed\";\n\nexport const CRYPTO_JWT_TTL = ONE_DAY;\n","export const KEYCHAIN_CONTEXT = \"keychain\";\n\nexport const KEYCHAIN_STORAGE_VERSION = \"0.3\";\n","export const MESSAGES_CONTEXT = \"messages\";\n\nexport const MESSAGES_STORAGE_VERSION = \"0.3\";\n","import { SIX_HOURS } from \"@walletconnect/time\";\n\nexport const PUBLISHER_DEFAULT_TTL = SIX_HOURS;\n\nexport const PUBLISHER_CONTEXT = \"publisher\";\n","import { ONE_SECOND } from \"@walletconnect/time\";\n\nexport const RELAYER_DEFAULT_PROTOCOL = \"irn\";\n\nexport const RELAYER_DEFAULT_LOGGER = \"error\";\n\nexport const RELAYER_DEFAULT_RELAY_URL = \"wss://relay.walletconnect.com\";\n\nexport const RELAYER_CONTEXT = \"relayer\";\n\nexport const RELAYER_EVENTS = {\n  message: \"relayer_message\",\n  connect: \"relayer_connect\",\n  disconnect: \"relayer_disconnect\",\n  error: \"relayer_error\",\n};\n\nexport const RELAYER_SUBSCRIBER_SUFFIX = \"_subscription\";\n\nexport const RELAYER_PROVIDER_EVENTS = {\n  payload: \"payload\",\n  connect: \"connect\",\n  disconnect: \"disconnect\",\n  error: \"error\",\n};\n\nexport const RELAYER_RECONNECT_TIMEOUT = ONE_SECOND;\n\nexport const RELAYER_STORAGE_OPTIONS = {\n  database: \":memory:\",\n};\n\n// FIXME: Always manually change this after each release (hardcoded from package.json)\n// ... this will be temporarily hardcoded until we refactor our build chain!\nexport const RELAYER_SDK_VERSION = \"2.0.0-rc.1\";\n","export const STORE_STORAGE_VERSION = \"0.3\";\n","import { THIRTY_DAYS, FIVE_SECONDS } from \"@walletconnect/time\";\n\nexport const SUBSCRIBER_EVENTS = {\n  created: \"subscription_created\",\n  deleted: \"subscription_deleted\",\n  expired: \"subscription_expired\",\n  disabled: \"subscription_disabled\",\n  sync: \"subscription_sync\",\n};\n\nexport const SUBSCRIBER_DEFAULT_TTL = THIRTY_DAYS;\n\nexport const SUBSCRIBER_CONTEXT = \"subscription\";\n\nexport const SUBSCRIBER_STORAGE_VERSION = \"0.3\";\n\nexport const PENDING_SUB_RESOLUTION_TIMEOUT = FIVE_SECONDS * 1000;\n","import { Logger } from \"pino\";\nimport { generateChildLogger, getLoggerContext } from \"@walletconnect/logger\";\nimport { ICore, IKeyChain } from \"@walletconnect/types\";\nimport { getInternalError, mapToObj, objToMap } from \"@walletconnect/utils\";\n\nimport { CORE_STORAGE_PREFIX, KEYCHAIN_CONTEXT, KEYCHAIN_STORAGE_VERSION } from \"../constants\";\n\nexport class KeyChain implements IKeyChain {\n  public keychain = new Map<string, string>();\n  public name = KEYCHAIN_CONTEXT;\n  public version = KEYCHAIN_STORAGE_VERSION;\n\n  private initialized = false;\n  private storagePrefix = CORE_STORAGE_PREFIX;\n\n  constructor(public core: ICore, public logger: Logger) {\n    this.core = core;\n    this.logger = generateChildLogger(logger, this.name);\n  }\n\n  public init: IKeyChain[\"init\"] = async () => {\n    if (!this.initialized) {\n      const keychain = await this.getKeyChain();\n      if (typeof keychain !== \"undefined\") {\n        this.keychain = keychain;\n      }\n      this.initialized = true;\n    }\n  };\n\n  get context() {\n    return getLoggerContext(this.logger);\n  }\n\n  get storageKey() {\n    return this.storagePrefix + this.version + \"//\" + this.name;\n  }\n\n  public has: IKeyChain[\"has\"] = (tag) => {\n    this.isInitialized();\n    return this.keychain.has(tag);\n  };\n\n  public set: IKeyChain[\"set\"] = async (tag, key) => {\n    this.isInitialized();\n    this.keychain.set(tag, key);\n    await this.persist();\n  };\n\n  public get: IKeyChain[\"get\"] = (tag) => {\n    this.isInitialized();\n    const key = this.keychain.get(tag);\n    if (typeof key === \"undefined\") {\n      const { message } = getInternalError(\"NO_MATCHING_KEY\", `${this.name}: ${tag}`);\n      throw new Error(message);\n    }\n    return key;\n  };\n\n  public del: IKeyChain[\"del\"] = async (tag) => {\n    this.isInitialized();\n    this.keychain.delete(tag);\n    await this.persist();\n  };\n\n  // ---------- Private ----------------------------------------------- //\n\n  private async setKeyChain(keychain: Map<string, string>) {\n    await this.core.storage.setItem<Record<string, string>>(this.storageKey, mapToObj(keychain));\n  }\n\n  private async getKeyChain() {\n    const keychain = await this.core.storage.getItem<Record<string, string>>(this.storageKey);\n    return typeof keychain !== \"undefined\" ? objToMap(keychain) : undefined;\n  }\n\n  private async persist() {\n    await this.setKeyChain(this.keychain);\n  }\n\n  private isInitialized() {\n    if (!this.initialized) {\n      const { message } = getInternalError(\"NOT_INITIALIZED\", this.name);\n      throw new Error(message);\n    }\n  }\n}\n","import { generateChildLogger, getLoggerContext } from \"@walletconnect/logger\";\nimport { safeJsonParse, safeJsonStringify } from \"@walletconnect/safe-json\";\nimport { ICore, ICrypto, IKeyChain } from \"@walletconnect/types\";\nimport * as relayAuth from \"@walletconnect/relay-auth\";\nimport { fromString } from \"uint8arrays/from-string\";\nimport {\n  decrypt,\n  deriveSymKey,\n  encrypt,\n  generateKeyPair as generateKeyPairUtil,\n  hashKey,\n  getInternalError,\n  generateRandomBytes32,\n  validateEncoding,\n  validateDecoding,\n  isTypeOneEnvelope,\n} from \"@walletconnect/utils\";\nimport { Logger } from \"pino\";\nimport { CRYPTO_CONTEXT, CRYPTO_CLIENT_SEED, CRYPTO_JWT_TTL } from \"../constants\";\nimport { KeyChain } from \"./keychain\";\n\nexport class Crypto implements ICrypto {\n  public name = CRYPTO_CONTEXT;\n  public keychain: ICrypto[\"keychain\"];\n\n  private initialized = false;\n\n  constructor(public core: ICore, public logger: Logger, keychain?: IKeyChain) {\n    this.core = core;\n    this.logger = generateChildLogger(logger, this.name);\n    this.keychain = keychain || new KeyChain(this.core, this.logger);\n  }\n\n  public init: ICrypto[\"init\"] = async () => {\n    if (!this.initialized) {\n      await this.keychain.init();\n      this.initialized = true;\n    }\n  };\n\n  get context() {\n    return getLoggerContext(this.logger);\n  }\n\n  public hasKeys: ICrypto[\"hasKeys\"] = (tag) => {\n    this.isInitialized();\n    return this.keychain.has(tag);\n  };\n\n  public getClientId: ICrypto[\"getClientId\"] = async () => {\n    this.isInitialized();\n    const seed = await this.getClientSeed();\n    const keyPair = relayAuth.generateKeyPair(seed);\n    const clientId = relayAuth.encodeIss(keyPair.publicKey);\n    return clientId;\n  };\n\n  public generateKeyPair: ICrypto[\"generateKeyPair\"] = () => {\n    this.isInitialized();\n    const keyPair = generateKeyPairUtil();\n    return this.setPrivateKey(keyPair.publicKey, keyPair.privateKey);\n  };\n\n  public signJWT: ICrypto[\"signJWT\"] = async (aud) => {\n    this.isInitialized();\n    const seed = await this.getClientSeed();\n    const keyPair = relayAuth.generateKeyPair(seed);\n    const sub = generateRandomBytes32();\n    const ttl = CRYPTO_JWT_TTL;\n    const jwt = await relayAuth.signJWT(sub, aud, ttl, keyPair);\n    return jwt;\n  };\n\n  public generateSharedKey: ICrypto[\"generateSharedKey\"] = (\n    selfPublicKey,\n    peerPublicKey,\n    overrideTopic,\n  ) => {\n    this.isInitialized();\n    const selfPrivateKey = this.getPrivateKey(selfPublicKey);\n    const symKey = deriveSymKey(selfPrivateKey, peerPublicKey);\n    return this.setSymKey(symKey, overrideTopic);\n  };\n\n  public setSymKey: ICrypto[\"setSymKey\"] = async (symKey, overrideTopic) => {\n    this.isInitialized();\n    const topic = overrideTopic || hashKey(symKey);\n    await this.keychain.set(topic, symKey);\n    return topic;\n  };\n\n  public deleteKeyPair: ICrypto[\"deleteKeyPair\"] = async (publicKey: string) => {\n    this.isInitialized();\n    await this.keychain.del(publicKey);\n  };\n\n  public deleteSymKey: ICrypto[\"deleteSymKey\"] = async (topic: string) => {\n    this.isInitialized();\n    await this.keychain.del(topic);\n  };\n\n  public encode: ICrypto[\"encode\"] = async (topic, payload, opts) => {\n    this.isInitialized();\n    const params = validateEncoding(opts);\n    const message = safeJsonStringify(payload);\n    if (isTypeOneEnvelope(params)) {\n      const selfPublicKey = params.senderPublicKey;\n      const peerPublicKey = params.receiverPublicKey;\n      topic = await this.generateSharedKey(selfPublicKey, peerPublicKey);\n    }\n    const symKey = this.getSymKey(topic);\n    const { type, senderPublicKey } = params;\n    const result = encrypt({ type, symKey, message, senderPublicKey });\n    return result;\n  };\n\n  public decode: ICrypto[\"decode\"] = async (topic, encoded, opts) => {\n    this.isInitialized();\n    const params = validateDecoding(encoded, opts);\n    if (isTypeOneEnvelope(params)) {\n      const selfPublicKey = params.receiverPublicKey;\n      const peerPublicKey = params.senderPublicKey;\n      topic = await this.generateSharedKey(selfPublicKey, peerPublicKey);\n    }\n    const symKey = this.getSymKey(topic);\n    const message = decrypt({ symKey, encoded });\n    const payload = safeJsonParse(message);\n    return payload;\n  };\n\n  // ---------- Private ----------------------------------------------- //\n\n  private async setPrivateKey(publicKey: string, privateKey: string): Promise<string> {\n    await this.keychain.set(publicKey, privateKey);\n    return publicKey;\n  }\n\n  private getPrivateKey(publicKey: string) {\n    const privateKey = this.keychain.get(publicKey);\n    return privateKey;\n  }\n\n  private async getClientSeed(): Promise<Uint8Array> {\n    let seed = \"\";\n    try {\n      seed = this.keychain.get(CRYPTO_CLIENT_SEED);\n    } catch {\n      seed = generateRandomBytes32();\n      await this.keychain.set(CRYPTO_CLIENT_SEED, seed);\n    }\n    return fromString(seed, \"base16\");\n  }\n\n  private getSymKey(topic: string) {\n    const symKey = this.keychain.get(topic);\n    return symKey;\n  }\n\n  private isInitialized() {\n    if (!this.initialized) {\n      const { message } = getInternalError(\"NOT_INITIALIZED\", this.name);\n      throw new Error(message);\n    }\n  }\n}\n","import { generateChildLogger, getLoggerContext } from \"@walletconnect/logger\";\nimport { ICore, IMessageTracker, MessageRecord } from \"@walletconnect/types\";\nimport { hashMessage, mapToObj, objToMap, getInternalError } from \"@walletconnect/utils\";\nimport { Logger } from \"pino\";\nimport { CORE_STORAGE_PREFIX, MESSAGES_CONTEXT, MESSAGES_STORAGE_VERSION } from \"../constants\";\n\nexport class MessageTracker extends IMessageTracker {\n  public messages = new Map<string, MessageRecord>();\n  public name = MESSAGES_CONTEXT;\n  public version = MESSAGES_STORAGE_VERSION;\n\n  private initialized = false;\n  private storagePrefix = CORE_STORAGE_PREFIX;\n\n  constructor(public logger: Logger, public core: ICore) {\n    super(logger, core);\n    this.logger = generateChildLogger(logger, this.name);\n    this.core = core;\n  }\n\n  public init: IMessageTracker[\"init\"] = async () => {\n    if (!this.initialized) {\n      this.logger.trace(`Initialized`);\n      try {\n        const messages = await this.getRelayerMessages();\n        if (typeof messages !== \"undefined\") {\n          this.messages = messages;\n        }\n\n        this.logger.debug(`Successfully Restored records for ${this.name}`);\n        this.logger.trace({ type: \"method\", method: \"restore\", size: this.messages.size });\n      } catch (e) {\n        this.logger.debug(`Failed to Restore records for ${this.name}`);\n        this.logger.error(e as any);\n      } finally {\n        this.initialized = true;\n      }\n    }\n  };\n\n  get context(): string {\n    return getLoggerContext(this.logger);\n  }\n\n  get storageKey(): string {\n    return this.storagePrefix + this.version + \"//\" + this.name;\n  }\n\n  public set: IMessageTracker[\"set\"] = async (topic, message) => {\n    this.isInitialized();\n    const hash = hashMessage(message);\n    let messages = this.messages.get(topic);\n    if (typeof messages === \"undefined\") {\n      messages = {};\n    }\n    if (typeof messages[hash] !== \"undefined\") {\n      return hash;\n    }\n    messages[hash] = message;\n    this.messages.set(topic, messages);\n    await this.persist();\n    return hash;\n  };\n\n  public get: IMessageTracker[\"get\"] = (topic) => {\n    this.isInitialized();\n    let messages = this.messages.get(topic);\n    if (typeof messages === \"undefined\") {\n      messages = {};\n    }\n    return messages;\n  };\n\n  public has: IMessageTracker[\"has\"] = (topic, message) => {\n    this.isInitialized();\n    const messages = this.get(topic);\n    const hash = hashMessage(message);\n    return typeof messages[hash] !== \"undefined\";\n  };\n\n  public del: IMessageTracker[\"del\"] = async (topic) => {\n    this.isInitialized();\n    this.messages.delete(topic);\n    await this.persist();\n  };\n\n  // ---------- Private ----------------------------------------------- //\n\n  private async setRelayerMessages(messages: Map<string, MessageRecord>): Promise<void> {\n    await this.core.storage.setItem<Record<string, MessageRecord>>(\n      this.storageKey,\n      mapToObj(messages),\n    );\n  }\n\n  private async getRelayerMessages(): Promise<Map<string, MessageRecord> | undefined> {\n    const messages = await this.core.storage.getItem<Record<string, MessageRecord>>(\n      this.storageKey,\n    );\n    return typeof messages !== \"undefined\" ? objToMap(messages) : undefined;\n  }\n\n  private async persist() {\n    await this.setRelayerMessages(this.messages);\n  }\n\n  private isInitialized() {\n    if (!this.initialized) {\n      const { message } = getInternalError(\"NOT_INITIALIZED\", this.name);\n      throw new Error(message);\n    }\n  }\n}\n","import { HEARTBEAT_EVENTS } from \"@walletconnect/heartbeat\";\nimport { RequestArguments } from \"@walletconnect/jsonrpc-types\";\nimport { generateChildLogger, getLoggerContext } from \"@walletconnect/logger\";\nimport { RelayJsonRpc } from \"@walletconnect/relay-api\";\nimport { IPublisher, IRelayer, PublisherTypes, RelayerTypes } from \"@walletconnect/types\";\nimport {\n  getRelayProtocolApi,\n  getRelayProtocolName,\n  hashMessage,\n  isUndefined,\n} from \"@walletconnect/utils\";\nimport { EventEmitter } from \"events\";\nimport { Logger } from \"pino\";\nimport { PUBLISHER_CONTEXT, PUBLISHER_DEFAULT_TTL } from \"../constants\";\n\nexport class Publisher extends IPublisher {\n  public events = new EventEmitter();\n  public name = PUBLISHER_CONTEXT;\n  public queue = new Map<string, PublisherTypes.Params>();\n\n  constructor(public relayer: IRelayer, public logger: Logger) {\n    super(relayer, logger);\n    this.relayer = relayer;\n    this.logger = generateChildLogger(logger, this.name);\n    this.registerEventListeners();\n  }\n\n  get context() {\n    return getLoggerContext(this.logger);\n  }\n\n  public publish: IPublisher[\"publish\"] = async (topic, message, opts) => {\n    this.logger.debug(`Publishing Payload`);\n    this.logger.trace({ type: \"method\", method: \"publish\", params: { topic, message, opts } });\n    try {\n      const ttl = opts?.ttl || PUBLISHER_DEFAULT_TTL;\n      const relay = getRelayProtocolName(opts);\n      const prompt = opts?.prompt || false;\n      const tag = opts?.tag || 0;\n      const params = { topic, message, opts: { ttl, relay, prompt, tag } };\n      const hash = hashMessage(message);\n      this.queue.set(hash, params);\n      await this.rpcPublish(topic, message, ttl, relay, prompt, tag);\n      this.onPublish(hash, params);\n      this.logger.debug(`Successfully Published Payload`);\n      this.logger.trace({ type: \"method\", method: \"publish\", params: { topic, message, opts } });\n    } catch (e) {\n      this.logger.debug(`Failed to Publish Payload`);\n      this.logger.error(e as any);\n      throw e;\n    }\n  };\n\n  public on: IPublisher[\"on\"] = (event, listener) => {\n    this.events.on(event, listener);\n  };\n\n  public once: IPublisher[\"once\"] = (event, listener) => {\n    this.events.once(event, listener);\n  };\n\n  public off: IPublisher[\"off\"] = (event, listener) => {\n    this.events.off(event, listener);\n  };\n\n  public removeListener: IPublisher[\"removeListener\"] = (event, listener) => {\n    this.events.removeListener(event, listener);\n  };\n\n  // ---------- Private ----------------------------------------------- //\n\n  private rpcPublish(\n    topic: string,\n    message: string,\n    ttl: number,\n    relay: RelayerTypes.ProtocolOptions,\n    prompt?: boolean,\n    tag?: number,\n  ) {\n    const api = getRelayProtocolApi(relay.protocol);\n    const request: RequestArguments<RelayJsonRpc.PublishParams> = {\n      method: api.publish,\n      params: {\n        topic,\n        message,\n        ttl,\n        prompt,\n        tag,\n      },\n    };\n    if (isUndefined(request.params?.prompt)) delete request.params?.prompt;\n    if (isUndefined(request.params?.tag)) delete request.params?.tag;\n    this.logger.debug(`Outgoing Relay Payload`);\n    this.logger.trace({ type: \"message\", direction: \"outgoing\", request });\n    return this.relayer.provider.request(request);\n  }\n\n  private onPublish(hash: string, _params: PublisherTypes.Params) {\n    this.queue.delete(hash);\n  }\n\n  private checkQueue() {\n    this.queue.forEach(async (params) => {\n      const {\n        topic,\n        message,\n        opts: { ttl, relay, prompt, tag },\n      } = params;\n      const hash = hashMessage(message);\n      await this.rpcPublish(topic, message, ttl, relay, prompt, tag);\n      this.onPublish(hash, params);\n    });\n  }\n\n  private registerEventListeners() {\n    this.relayer.core.heartbeat.on(HEARTBEAT_EVENTS.pulse, () => {\n      this.checkQueue();\n    });\n  }\n}\n","import { ISubscriberTopicMap } from \"@walletconnect/types\";\n\nexport class SubscriberTopicMap implements ISubscriberTopicMap {\n  public map = new Map<string, string[]>();\n\n  get topics(): string[] {\n    return Array.from(this.map.keys());\n  }\n\n  public set: ISubscriberTopicMap[\"set\"] = (topic, id) => {\n    const ids = this.get(topic);\n    if (this.exists(topic, id)) return;\n    this.map.set(topic, [...ids, id]);\n  };\n\n  public get: ISubscriberTopicMap[\"get\"] = (topic) => {\n    const ids = this.map.get(topic);\n    return ids || [];\n  };\n\n  public exists: ISubscriberTopicMap[\"exists\"] = (topic, id) => {\n    const ids = this.get(topic);\n    return ids.includes(id);\n  };\n\n  public delete: ISubscriberTopicMap[\"delete\"] = (topic, id) => {\n    if (typeof id === \"undefined\") {\n      this.map.delete(topic);\n      return;\n    }\n    if (!this.map.has(topic)) return;\n    const ids = this.get(topic);\n    if (!this.exists(topic, id)) return;\n    const remaining = ids.filter((x) => x !== id);\n    if (!remaining.length) {\n      this.map.delete(topic);\n      return;\n    }\n    this.map.set(topic, remaining);\n  };\n\n  public clear: ISubscriberTopicMap[\"clear\"] = () => {\n    this.map.clear();\n  };\n}\n","import { Logger } from \"pino\";\nimport { EventEmitter } from \"events\";\nimport { HEARTBEAT_EVENTS } from \"@walletconnect/heartbeat\";\nimport { ErrorResponse, RequestArguments } from \"@walletconnect/jsonrpc-types\";\nimport { generateChildLogger, getLoggerContext } from \"@walletconnect/logger\";\nimport { RelayJsonRpc } from \"@walletconnect/relay-api\";\nimport { Watch } from \"@walletconnect/time\";\nimport {\n  IRelayer,\n  ISubscriber,\n  RelayerTypes,\n  SubscriberEvents,\n  SubscriberTypes,\n} from \"@walletconnect/types\";\nimport {\n  getSdkError,\n  getInternalError,\n  getRelayProtocolApi,\n  getRelayProtocolName,\n} from \"@walletconnect/utils\";\nimport {\n  CORE_STORAGE_PREFIX,\n  RELAYER_PROVIDER_EVENTS,\n  SUBSCRIBER_CONTEXT,\n  SUBSCRIBER_EVENTS,\n  SUBSCRIBER_STORAGE_VERSION,\n  PENDING_SUB_RESOLUTION_TIMEOUT,\n} from \"../constants\";\nimport { SubscriberTopicMap } from \"./topicmap\";\n\nexport class Subscriber extends ISubscriber {\n  public subscriptions = new Map<string, SubscriberTypes.Active>();\n  public topicMap = new SubscriberTopicMap();\n  public events = new EventEmitter();\n  public name = SUBSCRIBER_CONTEXT;\n  public version = SUBSCRIBER_STORAGE_VERSION;\n  public pending = new Map<string, SubscriberTypes.Params>();\n\n  private cached: SubscriberTypes.Active[] = [];\n  private initialized = false;\n  private pendingSubscriptionWatchLabel = \"pending_sub_watch_label\";\n  private pendingSubInterval = 20;\n  private storagePrefix = CORE_STORAGE_PREFIX;\n\n  constructor(public relayer: IRelayer, public logger: Logger) {\n    super(relayer, logger);\n    this.relayer = relayer;\n    this.logger = generateChildLogger(logger, this.name);\n  }\n\n  public init: ISubscriber[\"init\"] = async () => {\n    if (!this.initialized) {\n      this.logger.trace(`Initialized`);\n      await this.restore();\n      await this.reset();\n      this.registerEventListeners();\n      this.onEnable();\n    }\n  };\n\n  get context() {\n    return getLoggerContext(this.logger);\n  }\n\n  get storageKey(): string {\n    return this.storagePrefix + this.version + \"//\" + this.name;\n  }\n\n  get length() {\n    return this.subscriptions.size;\n  }\n\n  get ids() {\n    return Array.from(this.subscriptions.keys());\n  }\n\n  get values() {\n    return Array.from(this.subscriptions.values());\n  }\n\n  get topics() {\n    return this.topicMap.topics;\n  }\n\n  public subscribe: ISubscriber[\"subscribe\"] = async (topic, opts) => {\n    this.isInitialized();\n    this.logger.debug(`Subscribing Topic`);\n    this.logger.trace({ type: \"method\", method: \"subscribe\", params: { topic, opts } });\n    try {\n      const relay = getRelayProtocolName(opts);\n      const params = { topic, relay };\n      this.pending.set(topic, params);\n      const id = await this.rpcSubscribe(topic, relay);\n      this.onSubscribe(id, params);\n      this.logger.debug(`Successfully Subscribed Topic`);\n      this.logger.trace({ type: \"method\", method: \"subscribe\", params: { topic, opts } });\n      return id;\n    } catch (e) {\n      this.logger.debug(`Failed to Subscribe Topic`);\n      this.logger.error(e as any);\n      throw e;\n    }\n  };\n\n  public unsubscribe: ISubscriber[\"unsubscribe\"] = async (topic, opts) => {\n    this.isInitialized();\n    if (typeof opts?.id !== \"undefined\") {\n      await this.unsubscribeById(topic, opts.id, opts);\n    } else {\n      await this.unsubscribeByTopic(topic, opts);\n    }\n  };\n\n  public isSubscribed: ISubscriber[\"isSubscribed\"] = async (topic: string) => {\n    // topic subscription is already resolved\n    if (this.topics.includes(topic)) return true;\n\n    // wait for the subscription to resolve\n    return await new Promise((resolve, reject) => {\n      const watch = new Watch();\n      watch.start(this.pendingSubscriptionWatchLabel);\n\n      const interval = setInterval(() => {\n        if (!this.pending.has(topic) && this.topics.includes(topic)) {\n          clearInterval(interval);\n          watch.stop(this.pendingSubscriptionWatchLabel);\n          resolve(true);\n        }\n        if (watch.elapsed(this.pendingSubscriptionWatchLabel) >= PENDING_SUB_RESOLUTION_TIMEOUT) {\n          clearInterval(interval);\n          watch.stop(this.pendingSubscriptionWatchLabel);\n          reject(false);\n        }\n      }, this.pendingSubInterval);\n    });\n  };\n\n  public on: ISubscriber[\"on\"] = (event, listener) => {\n    this.events.on(event, listener);\n  };\n\n  public once: ISubscriber[\"once\"] = (event, listener) => {\n    this.events.once(event, listener);\n  };\n\n  public off: ISubscriber[\"off\"] = (event, listener) => {\n    this.events.off(event, listener);\n  };\n\n  public removeListener: ISubscriber[\"removeListener\"] = (event, listener) => {\n    this.events.removeListener(event, listener);\n  };\n\n  // ---------- Private ----------------------------------------------- //\n\n  private hasSubscription(id: string, topic: string) {\n    let result = false;\n    try {\n      const subscription = this.getSubscription(id);\n      result = subscription.topic === topic;\n    } catch (e) {\n      // ignore error\n    }\n    return result;\n  }\n\n  private onEnable() {\n    this.cached = [];\n    this.initialized = true;\n  }\n\n  private onDisable() {\n    this.cached = this.values;\n    this.subscriptions.clear();\n    this.topicMap.clear();\n    this.initialized = false;\n  }\n\n  private async unsubscribeByTopic(topic: string, opts?: RelayerTypes.UnsubscribeOptions) {\n    const ids = this.topicMap.get(topic);\n    await Promise.all(ids.map(async (id) => await this.unsubscribeById(topic, id, opts)));\n  }\n\n  private async unsubscribeById(topic: string, id: string, opts?: RelayerTypes.UnsubscribeOptions) {\n    this.logger.debug(`Unsubscribing Topic`);\n    this.logger.trace({ type: \"method\", method: \"unsubscribe\", params: { topic, id, opts } });\n    try {\n      const relay = getRelayProtocolName(opts);\n      await this.rpcUnsubscribe(topic, id, relay);\n      const reason = getSdkError(\"USER_DISCONNECTED\", `${this.name}, ${topic}`);\n      await this.onUnsubscribe(topic, id, reason);\n      this.logger.debug(`Successfully Unsubscribed Topic`);\n      this.logger.trace({ type: \"method\", method: \"unsubscribe\", params: { topic, id, opts } });\n    } catch (e) {\n      this.logger.debug(`Failed to Unsubscribe Topic`);\n      this.logger.error(e as any);\n      throw e;\n    }\n  }\n\n  private async rpcSubscribe(topic: string, relay: RelayerTypes.ProtocolOptions) {\n    const api = getRelayProtocolApi(relay.protocol);\n    const request: RequestArguments<RelayJsonRpc.SubscribeParams> = {\n      method: api.subscribe,\n      params: {\n        topic,\n      },\n    };\n    this.logger.debug(`Outgoing Relay Payload`);\n    this.logger.trace({ type: \"payload\", direction: \"outgoing\", request });\n    return await this.relayer.provider.request(request);\n  }\n\n  private rpcUnsubscribe(topic: string, id: string, relay: RelayerTypes.ProtocolOptions) {\n    const api = getRelayProtocolApi(relay.protocol);\n    const request: RequestArguments<RelayJsonRpc.UnsubscribeParams> = {\n      method: api.unsubscribe,\n      params: {\n        topic,\n        id,\n      },\n    };\n    this.logger.debug(`Outgoing Relay Payload`);\n    this.logger.trace({ type: \"payload\", direction: \"outgoing\", request });\n    return this.relayer.provider.request(request);\n  }\n\n  private onSubscribe(id: string, params: SubscriberTypes.Params) {\n    this.setSubscription(id, { ...params, id });\n    this.pending.delete(params.topic);\n  }\n\n  private onResubscribe(id: string, params: SubscriberTypes.Params) {\n    this.addSubscription(id, { ...params, id });\n    this.pending.delete(params.topic);\n  }\n\n  private async onUnsubscribe(topic: string, id: string, reason: ErrorResponse) {\n    this.events.removeAllListeners(id);\n    if (this.hasSubscription(id, topic)) {\n      this.deleteSubscription(id, reason);\n    }\n    await this.relayer.messages.del(topic);\n  }\n\n  private async setRelayerSubscriptions(subscriptions: SubscriberTypes.Active[]) {\n    await this.relayer.core.storage.setItem<SubscriberTypes.Active[]>(\n      this.storageKey,\n      subscriptions,\n    );\n  }\n\n  private async getRelayerSubscriptions() {\n    const subscriptions = await this.relayer.core.storage.getItem<SubscriberTypes.Active[]>(\n      this.storageKey,\n    );\n    return subscriptions;\n  }\n\n  private setSubscription(id: string, subscription: SubscriberTypes.Active) {\n    if (this.subscriptions.has(id)) return;\n    this.logger.debug(`Setting subscription`);\n    this.logger.trace({ type: \"method\", method: \"setSubscription\", id, subscription });\n    this.addSubscription(id, subscription);\n  }\n\n  private addSubscription(id: string, subscription: SubscriberTypes.Active) {\n    this.subscriptions.set(id, { ...subscription });\n    this.topicMap.set(subscription.topic, id);\n    this.events.emit(SUBSCRIBER_EVENTS.created, subscription);\n  }\n\n  private getSubscription(id: string) {\n    this.logger.debug(`Getting subscription`);\n    this.logger.trace({ type: \"method\", method: \"getSubscription\", id });\n    const subscription = this.subscriptions.get(id);\n    if (!subscription) {\n      const { message } = getInternalError(\"NO_MATCHING_KEY\", `${this.name}: ${id}`);\n      throw new Error(message);\n    }\n    return subscription;\n  }\n\n  private deleteSubscription(id: string, reason: ErrorResponse) {\n    this.logger.debug(`Deleting subscription`);\n    this.logger.trace({ type: \"method\", method: \"deleteSubscription\", id, reason });\n    const subscription = this.getSubscription(id);\n    this.subscriptions.delete(id);\n    this.topicMap.delete(subscription.topic, id);\n    this.events.emit(SUBSCRIBER_EVENTS.deleted, {\n      ...subscription,\n      reason,\n    } as SubscriberEvents.Deleted);\n  }\n\n  private async persist() {\n    await this.setRelayerSubscriptions(this.values);\n    this.events.emit(SUBSCRIBER_EVENTS.sync);\n  }\n\n  private async reset() {\n    if (!this.cached.length) return;\n    await Promise.all(\n      this.cached.map(async (subscription) => await this.resubscribe(subscription)),\n    );\n  }\n\n  private async restore() {\n    try {\n      const persisted = await this.getRelayerSubscriptions();\n      if (typeof persisted === \"undefined\") return;\n      if (!persisted.length) return;\n      if (this.subscriptions.size) {\n        const { message } = getInternalError(\"RESTORE_WILL_OVERRIDE\", this.name);\n        this.logger.error(message);\n        throw new Error(message);\n      }\n      this.cached = persisted;\n      this.logger.debug(`Successfully Restored subscriptions for ${this.name}`);\n      this.logger.trace({ type: \"method\", method: \"restore\", subscriptions: this.values });\n    } catch (e) {\n      this.logger.debug(`Failed to Restore subscriptions for ${this.name}`);\n      this.logger.error(e as any);\n    }\n  }\n\n  private async resubscribe(subscription: SubscriberTypes.Active) {\n    if (!this.ids.includes(subscription.id)) {\n      const { topic, relay } = subscription;\n      const params = { topic, relay };\n      this.pending.set(params.topic, params);\n      const id = await this.rpcSubscribe(params.topic, params.relay);\n      this.onResubscribe(id, params);\n    }\n  }\n\n  private async onConnect() {\n    await this.reset();\n    this.onEnable();\n  }\n\n  private onDisconnect() {\n    this.onDisable();\n  }\n\n  private checkPending() {\n    this.pending.forEach(async (params) => {\n      const id = await this.rpcSubscribe(params.topic, params.relay);\n      this.onSubscribe(id, params);\n    });\n  }\n\n  private registerEventListeners() {\n    this.relayer.core.heartbeat.on(HEARTBEAT_EVENTS.pulse, () => {\n      this.checkPending();\n    });\n    this.relayer.provider.on(RELAYER_PROVIDER_EVENTS.connect, async () => {\n      await this.onConnect();\n    });\n    this.relayer.provider.on(RELAYER_PROVIDER_EVENTS.disconnect, () => {\n      this.onDisconnect();\n    });\n    this.events.on(SUBSCRIBER_EVENTS.created, async (createdEvent: SubscriberEvents.Created) => {\n      const eventName = SUBSCRIBER_EVENTS.created;\n      this.logger.info(`Emitting ${eventName}`);\n      this.logger.debug({ type: \"event\", event: eventName, data: createdEvent });\n      await this.persist();\n    });\n    this.events.on(SUBSCRIBER_EVENTS.deleted, async (deletedEvent: SubscriberEvents.Deleted) => {\n      const eventName = SUBSCRIBER_EVENTS.deleted;\n      this.logger.info(`Emitting ${eventName}`);\n      this.logger.debug({ type: \"event\", event: eventName, data: deletedEvent });\n      await this.persist();\n    });\n  }\n\n  private isInitialized() {\n    if (!this.initialized) {\n      const { message } = getInternalError(\"NOT_INITIALIZED\", this.name);\n      throw new Error(message);\n    }\n  }\n}\n","import pino, { Logger } from \"pino\";\nimport { EventEmitter } from \"events\";\nimport { JsonRpcProvider } from \"@walletconnect/jsonrpc-provider\";\nimport {\n  formatJsonRpcResult,\n  IJsonRpcProvider,\n  isJsonRpcRequest,\n  JsonRpcPayload,\n  JsonRpcRequest,\n} from \"@walletconnect/jsonrpc-utils\";\nimport WsConnection from \"@walletconnect/jsonrpc-ws-connection\";\nimport {\n  generateChildLogger,\n  getDefaultLoggerOptions,\n  getLoggerContext,\n} from \"@walletconnect/logger\";\nimport { RelayJsonRpc } from \"@walletconnect/relay-api\";\nimport { toMiliseconds } from \"@walletconnect/time\";\nimport {\n  ICore,\n  IMessageTracker,\n  IPublisher,\n  IRelayer,\n  ISubscriber,\n  RelayerOptions,\n  RelayerTypes,\n} from \"@walletconnect/types\";\nimport { formatRelayRpcUrl, getInternalError } from \"@walletconnect/utils\";\n\nimport {\n  RELAYER_SDK_VERSION,\n  RELAYER_CONTEXT,\n  RELAYER_DEFAULT_LOGGER,\n  RELAYER_EVENTS,\n  RELAYER_PROVIDER_EVENTS,\n  RELAYER_RECONNECT_TIMEOUT,\n  RELAYER_SUBSCRIBER_SUFFIX,\n  RELAYER_DEFAULT_RELAY_URL,\n} from \"../constants\";\nimport { MessageTracker } from \"./messages\";\nimport { Publisher } from \"./publisher\";\nimport { Subscriber } from \"./subscriber\";\n\nexport class Relayer extends IRelayer {\n  public protocol = \"wc\";\n  public version = 2;\n\n  public core: ICore;\n  public logger: Logger;\n  public events = new EventEmitter();\n  public provider: IJsonRpcProvider;\n  public messages: IMessageTracker;\n  public subscriber: ISubscriber;\n  public publisher: IPublisher;\n  public name = RELAYER_CONTEXT;\n\n  private initialized = false;\n\n  private relayUrl: string;\n  private projectId: string | undefined;\n\n  constructor(opts: RelayerOptions) {\n    super(opts);\n    this.core = opts.core;\n    this.logger =\n      typeof opts.logger !== \"undefined\" && typeof opts.logger !== \"string\"\n        ? generateChildLogger(opts.logger, this.name)\n        : pino(getDefaultLoggerOptions({ level: opts.logger || RELAYER_DEFAULT_LOGGER }));\n    this.messages = new MessageTracker(this.logger, opts.core);\n    this.subscriber = new Subscriber(this, this.logger);\n    this.publisher = new Publisher(this, this.logger);\n\n    this.relayUrl = opts?.relayUrl || RELAYER_DEFAULT_RELAY_URL;\n    this.projectId = opts.projectId;\n\n    // re-assigned during init()\n    this.provider = {} as IJsonRpcProvider;\n  }\n\n  public async init() {\n    this.logger.trace(`Initialized`);\n    const auth = await this.core.crypto.signJWT(this.relayUrl);\n    this.provider = this.createProvider(auth);\n    await Promise.all([this.messages.init(), this.provider.connect(), this.subscriber.init()]);\n    this.registerEventListeners();\n    this.initialized = true;\n  }\n\n  get context() {\n    return getLoggerContext(this.logger);\n  }\n\n  get connected() {\n    return this.provider.connection.connected;\n  }\n\n  get connecting() {\n    return this.provider.connection.connecting;\n  }\n\n  public async publish(topic: string, message: string, opts?: RelayerTypes.PublishOptions) {\n    this.isInitialized();\n    await this.publisher.publish(topic, message, opts);\n    await this.recordMessageEvent({ topic, message });\n  }\n\n  public async subscribe(topic: string, opts?: RelayerTypes.SubscribeOptions) {\n    this.isInitialized();\n    const id = await this.subscriber.subscribe(topic, opts);\n    return id;\n  }\n\n  public async unsubscribe(topic: string, opts?: RelayerTypes.UnsubscribeOptions) {\n    this.isInitialized();\n    await this.subscriber.unsubscribe(topic, opts);\n  }\n\n  public on(event: string, listener: any) {\n    this.events.on(event, listener);\n  }\n\n  public once(event: string, listener: any) {\n    this.events.once(event, listener);\n  }\n\n  public off(event: string, listener: any) {\n    this.events.off(event, listener);\n  }\n\n  public removeListener(event: string, listener: any) {\n    this.events.removeListener(event, listener);\n  }\n\n  // ---------- Private ----------------------------------------------- //\n\n  private createProvider(auth: string) {\n    return new JsonRpcProvider(\n      new WsConnection(\n        formatRelayRpcUrl({\n          sdkVersion: RELAYER_SDK_VERSION,\n          protocol: this.protocol,\n          version: this.version,\n          relayUrl: this.relayUrl,\n          projectId: this.projectId,\n          auth,\n        }),\n      ),\n    );\n  }\n\n  private async recordMessageEvent(messageEvent: RelayerTypes.MessageEvent) {\n    const { topic, message } = messageEvent;\n    await this.messages.set(topic, message);\n  }\n\n  private async shouldIgnoreMessageEvent(messageEvent: RelayerTypes.MessageEvent) {\n    const { topic, message } = messageEvent;\n    if (!(await this.subscriber.isSubscribed(topic))) return true;\n    const exists = this.messages.has(topic, message);\n    return exists;\n  }\n\n  private async onProviderPayload(payload: JsonRpcPayload) {\n    this.logger.debug(`Incoming Relay Payload`);\n    this.logger.trace({ type: \"payload\", direction: \"incoming\", payload });\n    if (isJsonRpcRequest(payload)) {\n      if (!payload.method.endsWith(RELAYER_SUBSCRIBER_SUFFIX)) return;\n      const event = (payload as JsonRpcRequest<RelayJsonRpc.SubscriptionParams>).params;\n      const { topic, message } = event.data;\n      const messageEvent = { topic, message } as RelayerTypes.MessageEvent;\n      this.logger.debug(`Emitting Relayer Payload`);\n      this.logger.trace({ type: \"event\", event: event.id, ...messageEvent });\n      this.events.emit(event.id, messageEvent);\n      await this.acknowledgePayload(payload);\n      await this.onMessageEvent(messageEvent);\n    }\n  }\n\n  private async onMessageEvent(messageEvent: RelayerTypes.MessageEvent) {\n    if (await this.shouldIgnoreMessageEvent(messageEvent)) return;\n    this.events.emit(RELAYER_EVENTS.message, messageEvent);\n    await this.recordMessageEvent(messageEvent);\n  }\n\n  private async acknowledgePayload(payload: JsonRpcPayload) {\n    const response = formatJsonRpcResult(payload.id, true);\n    await this.provider.connection.send(response);\n  }\n\n  private registerEventListeners() {\n    this.provider.on(RELAYER_PROVIDER_EVENTS.payload, (payload: JsonRpcPayload) =>\n      this.onProviderPayload(payload),\n    );\n    this.provider.on(RELAYER_PROVIDER_EVENTS.connect, () => {\n      this.events.emit(RELAYER_EVENTS.connect);\n    });\n    this.provider.on(RELAYER_PROVIDER_EVENTS.disconnect, () => {\n      this.events.emit(RELAYER_EVENTS.disconnect);\n      // Attempt reconnection after one second.\n      setTimeout(() => {\n        this.provider.connect();\n      }, toMiliseconds(RELAYER_RECONNECT_TIMEOUT));\n    });\n    this.provider.on(RELAYER_PROVIDER_EVENTS.error, (err: unknown) =>\n      this.events.emit(RELAYER_EVENTS.error, err),\n    );\n  }\n\n  private isInitialized() {\n    if (!this.initialized) {\n      const { message } = getInternalError(\"NOT_INITIALIZED\", this.name);\n      throw new Error(message);\n    }\n  }\n}\n","import { generateChildLogger, getLoggerContext } from \"@walletconnect/logger\";\nimport { ICore, IStore } from \"@walletconnect/types\";\nimport {\n  getInternalError,\n  isProposalStruct,\n  isSessionStruct,\n  isUndefined,\n} from \"@walletconnect/utils\";\nimport { Logger } from \"pino\";\nimport { CORE_STORAGE_PREFIX, STORE_STORAGE_VERSION } from \"../constants\";\nimport isEqual from \"lodash.isequal\";\n\nexport class Store<Key, Data extends Record<string, any>> extends IStore<Key, Data> {\n  public map = new Map<Key, Data>();\n  public version = STORE_STORAGE_VERSION;\n\n  private cached: Data[] = [];\n  private initialized = false;\n\n  /**\n   * Regenerates the value key to retrieve it from cache\n   */\n  private getKey: ((data: Data) => Key) | undefined;\n\n  private storagePrefix = CORE_STORAGE_PREFIX;\n\n  /**\n   * @param {ICore} core Core\n   * @param {Logger} logger Logger\n   * @param {string} name Store's name\n   * @param {Store<Key, Data>[\"getKey\"]} getKey Regenerates the value key to retrieve it from cache\n   * @param {string} storagePrefix Prefixes value keys\n   */\n  constructor(\n    public core: ICore,\n    public logger: Logger,\n    public name: string,\n    storagePrefix: string = CORE_STORAGE_PREFIX,\n    getKey: Store<Key, Data>[\"getKey\"] = undefined,\n  ) {\n    super(core, logger, name, storagePrefix);\n    this.logger = generateChildLogger(logger, this.name);\n    this.storagePrefix = storagePrefix;\n    this.getKey = getKey;\n  }\n\n  public init: IStore<Key, Data>[\"init\"] = async () => {\n    if (!this.initialized) {\n      this.logger.trace(`Initialized`);\n\n      await this.restore();\n\n      this.cached.forEach((value) => {\n        if (isProposalStruct(value)) {\n          // TODO(pedro) revert type casting as any\n          this.map.set(value.id as any, value);\n        } else if (isSessionStruct(value)) {\n          // TODO(pedro) revert type casting as any\n          this.map.set(value.topic as any, value);\n        } else if (this.getKey && value !== null && !isUndefined(value)) {\n          this.map.set(this.getKey(value), value);\n        }\n      });\n\n      this.cached = [];\n      this.initialized = true;\n    }\n  };\n\n  get context() {\n    return getLoggerContext(this.logger);\n  }\n\n  get storageKey(): string {\n    return this.storagePrefix + this.version + \"//\" + this.name;\n  }\n\n  get length() {\n    return this.map.size;\n  }\n\n  get keys() {\n    return Array.from(this.map.keys());\n  }\n\n  get values() {\n    return Array.from(this.map.values());\n  }\n\n  public set: IStore<Key, Data>[\"set\"] = async (key, value) => {\n    this.isInitialized();\n    if (this.map.has(key)) {\n      await this.update(key, value);\n    } else {\n      this.logger.debug(`Setting value`);\n      this.logger.trace({ type: \"method\", method: \"set\", key, value });\n      this.map.set(key, value);\n      await this.persist();\n    }\n  };\n\n  public get: IStore<Key, Data>[\"get\"] = (key) => {\n    this.isInitialized();\n    this.logger.debug(`Getting value`);\n    this.logger.trace({ type: \"method\", method: \"get\", key });\n    const value = this.getData(key);\n    return value;\n  };\n\n  public getAll: IStore<Key, Data>[\"getAll\"] = (filter) => {\n    if (!filter) return this.values;\n\n    return this.values.filter((value) =>\n      Object.keys(filter).every((key) => isEqual(value[key], filter[key])),\n    );\n  };\n\n  public update: IStore<Key, Data>[\"update\"] = async (key, update) => {\n    this.isInitialized();\n    this.logger.debug(`Updating value`);\n    this.logger.trace({ type: \"method\", method: \"update\", key, update });\n    const value = { ...this.getData(key), ...update };\n    this.map.set(key, value);\n    await this.persist();\n  };\n\n  public delete: IStore<Key, Data>[\"delete\"] = async (key, reason) => {\n    this.isInitialized();\n    if (!this.map.has(key)) return;\n    this.logger.debug(`Deleting value`);\n    this.logger.trace({ type: \"method\", method: \"delete\", key, reason });\n    this.map.delete(key);\n    await this.persist();\n  };\n\n  // ---------- Private ----------------------------------------------- //\n\n  private async setDataStore(value: Data[]) {\n    await this.core.storage.setItem<Data[]>(this.storageKey, value);\n  }\n\n  private async getDataStore() {\n    const value = await this.core.storage.getItem<Data[]>(this.storageKey);\n    return value;\n  }\n\n  private getData(key: Key) {\n    const value = this.map.get(key);\n    if (!value) {\n      const { message } = getInternalError(\"NO_MATCHING_KEY\", `${this.name}: ${key}`);\n      this.logger.error(message);\n      throw new Error(message);\n    }\n    return value;\n  }\n\n  private async persist() {\n    await this.setDataStore(this.values);\n  }\n\n  private async restore() {\n    try {\n      const persisted = await this.getDataStore();\n      if (typeof persisted === \"undefined\") return;\n      if (!persisted.length) return;\n      if (this.map.size) {\n        const { message } = getInternalError(\"RESTORE_WILL_OVERRIDE\", this.name);\n        this.logger.error(message);\n        throw new Error(message);\n      }\n      this.cached = persisted;\n      this.logger.debug(`Successfully Restored value for ${this.name}`);\n      this.logger.trace({ type: \"method\", method: \"restore\", value: this.values });\n    } catch (e) {\n      this.logger.debug(`Failed to Restore value for ${this.name}`);\n      this.logger.error(e as any);\n    }\n  }\n\n  private isInitialized() {\n    if (!this.initialized) {\n      const { message } = getInternalError(\"NOT_INITIALIZED\", this.name);\n      throw new Error(message);\n    }\n  }\n}\n","import pino from \"pino\";\nimport { EventEmitter } from \"events\";\n\nimport KeyValueStorage from \"@walletconnect/keyvaluestorage\";\nimport { HeartBeat } from \"@walletconnect/heartbeat\";\nimport {\n  generateChildLogger,\n  getDefaultLoggerOptions,\n  getLoggerContext,\n} from \"@walletconnect/logger\";\nimport { CoreTypes, ICore } from \"@walletconnect/types\";\n\nimport { Crypto, Relayer } from \"./controllers\";\nimport {\n  CORE_CONTEXT,\n  CORE_DEFAULT,\n  CORE_PROTOCOL,\n  CORE_STORAGE_OPTIONS,\n  CORE_VERSION,\n} from \"./constants\";\n\nexport class Core extends ICore {\n  public readonly protocol = CORE_PROTOCOL;\n  public readonly version = CORE_VERSION;\n\n  public readonly name: ICore[\"name\"] = CORE_CONTEXT;\n  public readonly relayUrl: ICore[\"relayUrl\"];\n  public readonly projectId: ICore[\"projectId\"];\n  public events: ICore[\"events\"] = new EventEmitter();\n  public logger: ICore[\"logger\"];\n  public heartbeat: ICore[\"heartbeat\"];\n  public relayer: ICore[\"relayer\"];\n  public crypto: ICore[\"crypto\"];\n  public storage: ICore[\"storage\"];\n\n  private initialized = false;\n\n  static async init(opts?: CoreTypes.Options) {\n    const core = new Core(opts);\n    await core.initialize();\n\n    return core;\n  }\n\n  constructor(opts?: CoreTypes.Options) {\n    super(opts);\n\n    this.projectId = opts?.projectId;\n    const logger =\n      typeof opts?.logger !== \"undefined\" && typeof opts?.logger !== \"string\"\n        ? opts.logger\n        : pino(getDefaultLoggerOptions({ level: opts?.logger || CORE_DEFAULT.logger }));\n    this.logger = generateChildLogger(logger, this.name);\n    this.heartbeat = new HeartBeat();\n    this.crypto = new Crypto(this, this.logger, opts?.keychain);\n    this.storage = opts?.storage\n      ? opts.storage\n      : new KeyValueStorage({ ...CORE_STORAGE_OPTIONS, ...opts?.storageOptions });\n    this.relayer = new Relayer({\n      core: this,\n      logger: this.logger,\n      relayUrl: opts?.relayUrl,\n      projectId: this.projectId,\n    });\n  }\n\n  get context() {\n    return getLoggerContext(this.logger);\n  }\n\n  // ---------- Public ----------------------------------------------- //\n\n  public async start() {\n    if (this.initialized) return;\n    await this.initialize();\n  }\n\n  // ---------- Events ----------------------------------------------- //\n\n  public on = (name: any, listener: any) => {\n    return this.events.on(name, listener);\n  };\n\n  public once = (name: any, listener: any) => {\n    return this.events.once(name, listener);\n  };\n\n  public off = (name: any, listener: any) => {\n    return this.events.off(name, listener);\n  };\n\n  public removeListener = (name: any, listener: any) => {\n    return this.events.removeListener(name, listener);\n  };\n\n  // ---------- Private ----------------------------------------------- //\n\n  private async initialize() {\n    this.logger.trace(`Initialized`);\n    try {\n      await this.crypto.init();\n      await this.relayer.init();\n      await this.heartbeat.init();\n      this.initialized = true;\n      this.logger.info(`Core Initilization Success`);\n    } catch (error) {\n      this.logger.info(`Core Initilization Failure`);\n      this.logger.error((error as any).message);\n      throw error;\n    }\n  }\n}\n","import { Core as WalletConnectCore } from \"./core\";\n\nexport * from \"./constants\";\nexport * from \"./controllers\";\n\nexport const Core = WalletConnectCore;\nexport default WalletConnectCore;\n"],"mappings":"","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}